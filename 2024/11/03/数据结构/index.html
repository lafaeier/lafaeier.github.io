<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | Hephaestus</title><meta name="author" content="surtr lafael"><meta name="copyright" content="surtr lafael"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前情提要算数指数，对数，级数，模运算 证明方法递归简论c++ 算法分析时间复杂度 依次为小于等于，大于等于，等于，小于 部分公式 前n项和 s&#x3D;\frac{n(a_n+a_0)}{2} s&#x3D;\frac{a_1(1-q^{n-1})}{1-q}一般的，计算复杂度即为计算最内层循环的次数，需要等差和等比的前n项和。 空间复杂度 表，栈和队列抽象数据类型（ADT）能够实现类似于删除，插入，修改，搜索，比">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://www.lafael.top/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Hephaestus">
<meta property="og:description" content="前情提要算数指数，对数，级数，模运算 证明方法递归简论c++ 算法分析时间复杂度 依次为小于等于，大于等于，等于，小于 部分公式 前n项和 s&#x3D;\frac{n(a_n+a_0)}{2} s&#x3D;\frac{a_1(1-q^{n-1})}{1-q}一般的，计算复杂度即为计算最内层循环的次数，需要等差和等比的前n项和。 空间复杂度 表，栈和队列抽象数据类型（ADT）能够实现类似于删除，插入，修改，搜索，比">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/78170818.jpg">
<meta property="article:published_time" content="2024-11-02T16:24:08.000Z">
<meta property="article:modified_time" content="2024-12-20T14:11:13.200Z">
<meta property="article:author" content="surtr lafael">
<meta property="article:tag" content="课内基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/78170818.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/微信图片_20240324121443.jpg"><link rel="canonical" href="https://www.lafael.top/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: surtr lafael","link":"链接: ","source":"来源: Hephaestus","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-20 22:11:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/78170818.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hephaestus"><span class="site-name">Hephaestus</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-02T16:24:08.000Z" title="发表于 2024-11-03 00:24:08">2024-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-20T14:11:13.200Z" title="更新于 2024-12-20 22:11:13">2024-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">数据结构基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><h2 id="算数"><a href="#算数" class="headerlink" title="算数"></a>算数</h2><p>指数，对数，级数，模运算</p>
<h2 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h2><h2 id="递归简论"><a href="#递归简论" class="headerlink" title="递归简论"></a>递归简论</h2><h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006140755.png></p>
<p>依次为小于等于，大于等于，等于，小于</p>
<h3 id="部分公式"><a href="#部分公式" class="headerlink" title="部分公式"></a>部分公式</h3><script type="math/tex; mode=display">
前n项和 s=\frac{n(a_n+a_0)}{2}</script><script type="math/tex; mode=display">
s=\frac{a_1(1-q^{n-1})}{1-q}</script><p>一般的，计算复杂度即为计算最内层循环的次数，需要等差和等比的前n项和。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><hr>
<h1 id="表，栈和队列"><a href="#表，栈和队列" class="headerlink" title="表，栈和队列"></a>表，栈和队列</h1><h2 id="抽象数据类型（ADT）"><a href="#抽象数据类型（ADT）" class="headerlink" title="抽象数据类型（ADT）"></a>抽象数据类型（ADT）</h2><p>能够实现类似于删除，插入，修改，搜索，比较等操作的数据结构，不同于整数，实数等的数据结构</p>
<h2 id="表（List）"><a href="#表（List）" class="headerlink" title="表（List）"></a>表（List）</h2><p>也称顺序存储（sequential）</p>
<h3 id="List的数组实现"><a href="#List的数组实现" class="headerlink" title="List的数组实现"></a>List的数组实现</h3><p>有四个主要的数据成员：存储长度，最大长度，数组，当前指针<br>有两个主要函数:插入（curr前插入），删除（curr节点删除并返回）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">List</span>&#123;  </span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">     <span class="comment">//存储数据的数组  </span></span><br><span class="line">     vector&lt;T&gt; data;  </span><br><span class="line">     <span class="comment">//帮提供给用户的指针</span></span><br><span class="line">     <span class="comment">//接下来所有的操作都要依赖此指针</span></span><br><span class="line">     <span class="type">int</span> curr;  </span><br><span class="line">     <span class="comment">//逻辑上的大小</span></span><br><span class="line">     <span class="type">int</span> listSize;</span><br><span class="line">     <span class="comment">//实际上为应对扩容而实现的大小  </span></span><br><span class="line">     <span class="type">int</span> maxSize;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="comment">//用最值创建列表</span></span><br><span class="line">     <span class="built_in">List</span>(<span class="type">int</span> max=<span class="number">120</span>):<span class="built_in">maxSize</span>(max+<span class="number">10</span>),<span class="built_in">listSize</span>(max)  </span><br><span class="line">     &#123;  </span><br><span class="line">         data.<span class="built_in">resize</span>(max+<span class="number">10</span>);  </span><br><span class="line">         <span class="comment">//按最大内容分配，当然用户能使用的只有ListSize</span></span><br><span class="line">         curr=<span class="number">0</span>;  </span><br><span class="line">     &#125; </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//主要函数1</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span>  </span></span><br><span class="line"><span class="function">     <span class="comment">//在curr前插入</span></span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(listSize&gt;=maxSize)  </span><br><span class="line">         <span class="comment">//若已满，则扩容  </span></span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="built_in">resize</span>(maxSize+<span class="number">10</span>);  </span><br><span class="line">             maxSize+=<span class="number">10</span>;  </span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">         <span class="comment">//从0开始，故以listSize起手</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=listSize;i&gt;curr;i--)  </span><br><span class="line">         &#123;  </span><br><span class="line">             data[i]=data[i<span class="number">-1</span>];  </span><br><span class="line">         &#125;  </span><br><span class="line">         data[curr]=num;  </span><br><span class="line">          </span><br><span class="line">         <span class="comment">//插入一位，故只加一</span></span><br><span class="line">         listSize++;   </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要函数2</span></span><br><span class="line">     <span class="function">T <span class="title">remove</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(curr==listSize)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="type">int</span> empt=curr;  </span><br><span class="line">             curr--;  </span><br><span class="line">             listSize--;  </span><br><span class="line">             <span class="keyword">return</span> data[empt];  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="type">int</span> empt2=data[curr];  </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=curr+<span class="number">1</span>;curr&lt;=listSize;i++)  </span><br><span class="line">         &#123;  </span><br><span class="line">             data[i<span class="number">-1</span>]=data[i];  </span><br><span class="line">         &#125;  </span><br><span class="line">         listSize--;  </span><br><span class="line">         <span class="keyword">return</span> empt2;  </span><br><span class="line">     &#125; </span><br><span class="line">      </span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">move</span><span class="params">(<span class="type">int</span> pos)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(pos&lt;<span class="number">0</span>||pos&gt;=listSize)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">         &#123;  </span><br><span class="line">             curr=pos;  </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> n)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         data.<span class="built_in">resize</span>(n+<span class="number">10</span>);  </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">moveToStart</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         curr=<span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">moveToEnd</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         curr=listSize;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">prev</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(curr&gt;<span class="number">0</span>)  </span><br><span class="line">         curr--;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(curr&lt;listSize)  </span><br><span class="line">         curr++;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> listSize;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">currPos</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> curr;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> data[curr];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> num)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         data[curr]=num;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         maxSize=<span class="number">0</span>;  </span><br><span class="line">         listSize=<span class="number">0</span>;  </span><br><span class="line">         <span class="built_in">resize</span>(<span class="number">0</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">       </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="List的链表实现"><a href="#List的链表实现" class="headerlink" title="List的链表实现"></a>List的链表实现</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>链（next link）</p>
<p>有四个主要的数据成员：头指针，尾指针，当前指针。不需要数组，一切插入都基于这三个指针。<br>有两个主要函数:链表节点的构造（用于插入算法），插入（curr后插入），删除（curr后节点删除并返回值）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">link</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     E element;  </span><br><span class="line">     link* next;    </span><br><span class="line">     <span class="comment">//构造函数，用于插入</span></span><br><span class="line">     <span class="built_in">list</span>(<span class="type">const</span> E&amp;elemval,link* nextval=<span class="literal">nullptr</span>)  </span><br><span class="line">     &#123;  </span><br><span class="line">         element=elemval;  </span><br><span class="line">         next=nextval;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="built_in">list</span>(link* nextval=<span class="literal">nullptr</span>)  </span><br><span class="line">     &#123;  </span><br><span class="line">         next=nextval;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;   </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">List</span>:<span class="keyword">public</span> link&lt;E&gt;  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     link&lt;E&gt;* head;  </span><br><span class="line">     link&lt;E&gt;* tail;  </span><br><span class="line">     link&lt;E&gt;* curr;  </span><br><span class="line">     <span class="type">int</span> size;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">List</span>()  </span><br><span class="line">     &#123;  </span><br><span class="line">         curr=tail=head=<span class="keyword">new</span> link&lt;E&gt;;  </span><br><span class="line">         size=<span class="number">0</span>;  </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//在curr后插入  </span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; item)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(tail==curr)  </span><br><span class="line">         &#123;  </span><br><span class="line">             curr-&gt;element=item;  </span><br><span class="line">             tail=curr-&gt;next;  </span><br><span class="line">             <span class="keyword">if</span>(tail==<span class="literal">nullptr</span>)  </span><br><span class="line">             &#123;  </span><br><span class="line">                 tail=<span class="keyword">new</span> link&lt;E&gt;;  </span><br><span class="line">             &#125;  </span><br><span class="line">             size++;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">         <span class="comment">//调用构造函数</span></span><br><span class="line">         curr-&gt;next=<span class="keyword">new</span> <span class="built_in">link</span>&lt;E&gt;(item,curr-&gt;next);  </span><br><span class="line">     &#125;</span><br><span class="line">       </span><br><span class="line">     <span class="comment">//从尾节点插入</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> E&amp; item)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         tail-&gt;element=item;  </span><br><span class="line">         tail=tail-&gt;next=<span class="keyword">new</span> link&lt;E&gt;;  </span><br><span class="line">         size++;  </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//去除curr后的节点</span></span><br><span class="line">     <span class="function">E <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">	     E it=curr-&gt;next-&gt;element;</span><br><span class="line">	     link&lt;E&gt;* temp=curr-&gt;next;</span><br><span class="line">	     </span><br><span class="line">	     <span class="keyword">if</span>(tail==curr-&gt;next)</span><br><span class="line">	     &#123;</span><br><span class="line">     tail=curr;</span><br><span class="line">	     &#125;</span><br><span class="line">	     <span class="keyword">else</span></span><br><span class="line">	     curr-&gt;next=curr-&gt;next-&gt;next;</span><br><span class="line">	     </span><br><span class="line">	     <span class="comment">//可能需要注意一下空指针</span></span><br><span class="line">	     detele temp;</span><br><span class="line">	     </span><br><span class="line">	     cnt--;</span><br><span class="line">	     <span class="keyword">return</span> it;</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(curr!==tail)  </span><br><span class="line">         &#123;  </span><br><span class="line">             curr=curr-&gt;next;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">prev</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(curr!==head)  </span><br><span class="line">         &#123;  </span><br><span class="line">             link&lt;E&gt;* temp=head;  </span><br><span class="line">             <span class="keyword">while</span>(temp-&gt;next!=curr)  </span><br><span class="line">             &#123;  </span><br><span class="line">                 temp=temp-&gt;next;  </span><br><span class="line">             &#125;  </span><br><span class="line">             curr=temp;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>无官方代码，凑合看一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">link</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	link* pre;</span><br><span class="line">	link* next;</span><br><span class="line">	T value;</span><br><span class="line">	<span class="built_in">link</span>(link* prev = <span class="literal">nullptr</span>, T element = <span class="number">0</span>, link* nex = <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pre = prev;</span><br><span class="line">		value = element;</span><br><span class="line">		next = nex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	link&lt;T&gt;* head;</span><br><span class="line">	link&lt;T&gt;* tail;</span><br><span class="line">	link&lt;T&gt;* curr;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="built_in">list</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		curr = tail = head = <span class="keyword">new</span> link&lt;T&gt;;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在curr后插入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (curr == tail)</span><br><span class="line">		&#123;</span><br><span class="line">			curr-&gt;element = num;</span><br><span class="line">			tail = curr-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (tail == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tail = <span class="keyword">new</span> <span class="built_in">link</span>&lt;T&gt;(curr,<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			link* temp = curr-&gt;next;</span><br><span class="line">			curr-&gt;next = <span class="keyword">new</span> <span class="built_in">link</span>&lt;T&gt;(curr,num, curr-&gt;next);</span><br><span class="line">			temp-&gt;prev = curr-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tail-&gt;value = item;</span><br><span class="line">		tail-&gt;next = <span class="keyword">new</span> <span class="built_in">link</span>&lt;T&gt;(tail,<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		T item = curr-&gt;next-&gt;value;</span><br><span class="line">		link&lt;T&gt;* temp = curr-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (curr-&gt;next == tail)</span><br><span class="line">		&#123;</span><br><span class="line">			tail = curr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">			temp-&gt;next-&gt;prev = curr;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		<span class="keyword">return</span> item;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比较数组实现和链表实现：<br>$n<em>(P+E)$表示链表实现的空间占用，n是总的节点数，P是指针空间大小，E是数据空间大小<br>$E</em>N$表示数组实现的空间占用，N是数组的元素数目，E是数据空间大小<br>值更小的更优</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>1.本身是可迭代的、</p>
<p>2.本身可以访问到下一个元素（指针）</p>
<p>迭代器是STL中数据结构的单位</p>
<p>常量容器和非常量容器使用诸如begin（），end（）方法时返回的迭代器不同，分别为const_iterator和iterator</p>
<h2 id="vector的实现"><a href="#vector的实现" class="headerlink" title="vector的实现"></a>vector的实现</h2><p>稍看几眼即可<br><code>&#123;&#125;</code> 也可以用于初始化容器类型或其他支持初始化列表的类型。例如，你可以用 <code>&#123;&#125;</code> 来初始化一个 <code>std::vector&lt;int&gt;</code> 对象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">object</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Vector</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">Vector</span>(<span class="type">int</span> size=<span class="number">0</span> ):<span class="built_in">thisSize</span>(size),<span class="built_in">theCapacity</span>(size+spare)  </span><br><span class="line">     &#123;  </span><br><span class="line">         node=<span class="keyword">new</span> object[theCapacity];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; rhs):<span class="built_in">theSize</span>(rhs.theSize),<span class="built_in">theCapacity</span>(rhs.theCapacity),<span class="built_in">node</span>(<span class="literal">nullptr</span>)  </span><br><span class="line">     &#123;  </span><br><span class="line">         node=<span class="keyword">new</span> object[theCapacity];  </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=thesize;++i)  </span><br><span class="line">         &#123;  </span><br><span class="line">             node[i]=rhs.node[i];  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     Vector &amp;<span class="keyword">operator</span>= (<span class="type">const</span> Vector&amp; rhs)  </span><br><span class="line">     &#123;  </span><br><span class="line">         Vector empt=rhs;  </span><br><span class="line">         <span class="built_in">swap</span>(*<span class="keyword">this</span>,empt);  </span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     ~<span class="built_in">Vector</span> ()  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="keyword">delete</span> [] node;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="built_in">Vector</span>(Vector &amp;&amp;rhs):<span class="built_in">theSize</span>(rhs.theSize),<span class="built_in">theCapacity</span>(rhs.theCapacity),<span class="built_in">node</span>(rhs.node)  </span><br><span class="line">     &#123;  </span><br><span class="line">         rhs.node=<span class="literal">nullptr</span>;  </span><br><span class="line">         rhs.theSize=<span class="number">0</span>;  </span><br><span class="line">         rhs.theCapacity=<span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     Vector &amp; <span class="keyword">operator</span>=(Vector &amp;&amp; rhs)  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs);  </span><br><span class="line">         <span class="built_in">swap</span>(theSize,rhs.theSize);  </span><br><span class="line">         <span class="built_in">swap</span>(theCapacity,rhs.theCapacity);  </span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> newSize)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(newSize&gt;theCapacity)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="built_in">reserver</span>(newSize);  </span><br><span class="line">         &#125;  </span><br><span class="line">         theSize=newSize;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">int</span> newCapacity)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(newCapacity&lt;theSize)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="keyword">return</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">         object *newArry=<span class="keyword">new</span> object[newCapacity];  </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;theSize;++i)  </span><br><span class="line">         &#123;  </span><br><span class="line">             newArry[i]=node[i];  </span><br><span class="line">         &#125;  </span><br><span class="line">         theCapacity=newCapacity;  </span><br><span class="line">         <span class="built_in">swao</span>(node,newArry)  </span><br><span class="line">         <span class="keyword">delete</span> [] newArry;  </span><br><span class="line">     &#125;  </span><br><span class="line">     object &amp;operate[](<span class="type">int</span> index)  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="keyword">return</span> node[index];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="type">const</span> object&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)<span class="type">const</span>  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="keyword">return</span> node[inex];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">size</span>()==<span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> theSize;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> theCapacity;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> object &amp;node)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(theSize==theCapacity)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="built_in">reserve</span>(<span class="number">2</span>*theCapacity+<span class="number">1</span>);  </span><br><span class="line">         &#125;  </span><br><span class="line">          node[theSize++]=x;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(onject &amp;&amp; x)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(theSize==theCapacity)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="built_in">reserve</span>(<span class="number">2</span>*theCapacity+<span class="number">1</span>);  </span><br><span class="line">         &#125;  </span><br><span class="line">         node[theSize++]=std::<span class="built_in">move</span>(x);  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         theSizs--;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">const</span> object&amp; <span class="title">back</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> node[theSize<span class="number">-1</span>];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">typedef</span> object* iterator;  </span><br><span class="line">     <span class="keyword">typedef</span> <span class="type">const</span> object* const_iterator;  </span><br><span class="line">     <span class="function">iterator <span class="title">begin</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> &amp;node[<span class="number">0</span>];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> &amp;node[<span class="number">0</span>];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> &amp;node[theSize];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function">const_iterator <span class="title">end</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> &amp;node[theSize];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> spare=<span class="number">16</span>;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     object *node;  </span><br><span class="line">     <span class="type">int</span> theSize;  </span><br><span class="line">     <span class="type">int</span> theCapacity;  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="栈ADT"><a href="#栈ADT" class="headerlink" title="栈ADT"></a>栈ADT</h2><p>栈本身的三个重要函数：push，pop，topValue</p>
<h3 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h3><p>重要函数为：push（单向链表，插入方向与指针方向相反），pop（弹出方向和指针方向相同）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">link</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     E element;  </span><br><span class="line">     link* next;    </span><br><span class="line">     <span class="built_in">list</span>(<span class="type">const</span> E&amp;elemval,link* nextval=<span class="literal">nullptr</span>)  </span><br><span class="line">     &#123;  </span><br><span class="line">         element=elemval;  </span><br><span class="line">         next=nextval;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="built_in">list</span>(link* nextval=<span class="literal">nullptr</span>)  </span><br><span class="line">     &#123;  </span><br><span class="line">         next=nextval;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Stack</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     <span class="type">void</span> opertaor=(<span class="type">const</span> Stack&amp;);  </span><br><span class="line">     <span class="built_in">Stack</span>(<span class="type">const</span> Stack&amp;);  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> E&amp; item)</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> E <span class="title">pop</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> E&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>=<span class="number">0</span>;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">LStack</span>:<span class="keyword">public</span> Stack&lt;E&gt;  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     link&lt;E&gt;* top;  </span><br><span class="line">     <span class="type">int</span> size;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">LStack</span>(<span class="type">int</span> sz=<span class="number">0</span>)<span class="comment">//default  </span></span><br><span class="line">     &#123;  </span><br><span class="line">         top=<span class="literal">nullptr</span>;  </span><br><span class="line">         size=<span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     ~<span class="built_in">LStack</span>()  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="built_in">clear</span>();  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">while</span>(top!=<span class="literal">nullptr</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">             link&lt;E&gt;* temp=top;  </span><br><span class="line">             top=top-&gt;next;  </span><br><span class="line">             <span class="keyword">delete</span> temp;  </span><br><span class="line">         &#125;  </span><br><span class="line">         size=<span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(constE&amp; item)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         top=<span class="keyword">new</span> <span class="built_in">link</span>&lt;E&gt;(item,top);  </span><br><span class="line">         size++;  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//每次push，都会新建一个节点，他的next是上一个节点，top始终在栈顶  </span></span><br><span class="line">     <span class="function">E <span class="title">pop</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(size&gt;<span class="number">0</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">             E it=top-&gt;element;  </span><br><span class="line">             link&lt;E&gt;* empt=top;  </span><br><span class="line">             top=top-&gt;next;  </span><br><span class="line">             size--;  </span><br><span class="line">             <span class="keyword">delete</span> empt;  </span><br><span class="line">             <span class="keyword">return</span> it;    </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function">constE&amp; <span class="title">topValue</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> top-&gt;element;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;  </span><br></pre></td></tr></table></figure>
<h3 id="栈-stack-的数组实现"><a href="#栈-stack-的数组实现" class="headerlink" title="栈(stack)的数组实现"></a>栈(stack)的数组实现</h3><p>有三个重要的数据成员：maxSize（因为不考虑扩充数组），top（定位），一个数组<br>使用vector的pop，push等实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Stack</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     <span class="type">void</span> opertaor=(<span class="type">const</span> Stack&amp;);  </span><br><span class="line">     <span class="built_in">Stack</span>(<span class="type">const</span> Stack&amp;);  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> E&amp; item)</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> E <span class="title">pop</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> E&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>=<span class="number">0</span>;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">AStack</span>:<span class="keyword">public</span> Stack&lt;E&gt;  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     <span class="type">int</span> maxsize;  </span><br><span class="line">     <span class="type">int</span> top;<span class="comment">//top领先实值  </span></span><br><span class="line">     E* listArry;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">AStack</span>(<span class="type">int</span> size=<span class="number">10</span>)<span class="comment">//default  </span></span><br><span class="line">     &#123;  </span><br><span class="line">         maxsize=size;  </span><br><span class="line">         top=<span class="number">0</span>;  </span><br><span class="line">         listArry=<span class="keyword">new</span> E[maxsize];  </span><br><span class="line">           </span><br><span class="line">     &#125;  </span><br><span class="line">     ~<span class="built_in">AStack</span>()  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="keyword">delete</span> []listArry;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> E&amp; item)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(top&lt;maxsize)  </span><br><span class="line">         &#123;  </span><br><span class="line">             listArry[top++]=item;  </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function">E <span class="title">pop</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> listArry[--top];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">const</span> E&amp; <span class="title">topValue</span><span class="params">()</span> <span class="type">const</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> listArry[top<span class="number">-1</span>];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         top=<span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历的实现（栈）"><a href="#中序遍历的实现（栈）" class="headerlink" title="中序遍历的实现（栈）"></a>中序遍历的实现（栈）</h3><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><h3 id="队列的数组实现（循环队列-loop-circule-）"><a href="#队列的数组实现（循环队列-loop-circule-）" class="headerlink" title="队列的数组实现（循环队列(loop circule)）"></a>队列的数组实现（循环队列(loop circule)）</h3><p> 考虑到普通队列使用数组实现会导致空间的大量浪费，故使用循环队列<br> 事实上，以数组实现的队列满与空要看初始条件，在下面的例子中，由于空间多加了1位，所以初始条件位rear=0，front=1，此时队列自然为空（差值为1），队列是否为空也要靠这个判断。若差值为2，则自然为满。这种情况下，花费了两个空间标识了头与尾节点</p>
<p> 若初始条件不会扩充空间，那么设置rear=0，front=0；差值为0，队列为空，差值为1，队列为满。这种情况下，花费了一个空间标识了头与尾节点，一般的，实践中更习惯这种用法</p>
<p>重要函数为：enqueue(注意取模和越界判断)和dequeue（取模）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Queue</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Queeue&amp;)&#123;&#125;;  </span><br><span class="line">     <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp;)&#123;&#125;;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">Queue</span>()&#123;&#125;;  </span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">Queue</span>()=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">const</span> E&amp; x)</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> E <span class="title">dequeue</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> E&amp; <span class="title">frontValue</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">AQueue</span>:<span class="keyword">public</span> Queue&lt;E&gt;  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     <span class="type">int</span> maxSize;  </span><br><span class="line">     <span class="type">int</span> front;  </span><br><span class="line">     <span class="type">int</span> rear;  </span><br><span class="line">     E* array;  </span><br><span class="line">     <span class="comment">//int currSize;可用于检测是否溢出  </span></span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">AQueue</span>(<span class="type">int</span> size=<span class="number">10</span>)<span class="comment">//default  </span></span><br><span class="line">     &#123;  </span><br><span class="line">         maxSize=size+<span class="number">1</span>;  </span><br><span class="line">         rear=<span class="number">0</span>;  </span><br><span class="line">         front=<span class="number">1</span>;  </span><br><span class="line">         listArry=<span class="keyword">new</span> E[maxSize];  </span><br><span class="line">           </span><br><span class="line">     &#125;  </span><br><span class="line">     ~<span class="built_in">AQueue</span>()  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="keyword">delete</span> []listArry;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         rear=<span class="number">0</span>;  </span><br><span class="line">         front=<span class="number">1</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(constE&amp; item)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>((rear+<span class="number">2</span>)%maxSize!=front)  </span><br><span class="line">         &#123;  </span><br><span class="line">             rear=(rear+<span class="number">1</span>)%maxSize;<span class="comment">//比设定值大一</span></span><br><span class="line">             listArry[rear]=item;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;<span class="comment">//先增后写入</span></span><br><span class="line">     <span class="function">E <span class="title">dequeue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         E item=listArry[front];  </span><br><span class="line">         front=(front+<span class="number">1</span>)%maxSize;  </span><br><span class="line">         <span class="keyword">return</span> item;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">const</span> E&amp; <span class="title">frontValue</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> listArry[front];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> (rear+maxSize-front)%maxSize;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">       </span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="队列的链表实现（非循环队列）"><a href="#队列的链表实现（非循环队列）" class="headerlink" title="队列的链表实现（非循环队列）"></a>队列的链表实现（非循环队列）</h3><p>重要函数为：enqueue（顺着指针方向），dequeue（顺着指针方向）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不考虑使用循环列表  </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">link</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     E element;  </span><br><span class="line">     link* next;    </span><br><span class="line">     <span class="built_in">list</span>(<span class="type">const</span> E&amp;elemval,link* nextval=<span class="literal">nullptr</span>)  </span><br><span class="line">     &#123;  </span><br><span class="line">         element=elemval;  </span><br><span class="line">         next=nextval;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="built_in">list</span>(link* nextval=<span class="literal">nullptr</span>)  </span><br><span class="line">     &#123;  </span><br><span class="line">         next=nextval;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Queue</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Queeue&amp;)&#123;&#125;;  </span><br><span class="line">     <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp;)&#123;&#125;;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">Queue</span>()&#123;&#125;;  </span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">Queue</span>()=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">const</span> E&amp; x)</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> E <span class="title">dequeue</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> E&amp; <span class="title">frontValue</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">LQueue</span>:<span class="keyword">public</span> Queue&lt;E&gt;  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="comment">//存在两种方法，一是留下一个空的节点，一个是不留，本方法采用后者，因为前者易实现  </span></span><br><span class="line">     <span class="keyword">private</span>:  </span><br><span class="line">     <span class="type">int</span> maxSize;  </span><br><span class="line">     link* front;  </span><br><span class="line">     link* raer;  </span><br><span class="line">     <span class="type">int</span> len;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="built_in">AQueue</span>(<span class="type">int</span> size=<span class="number">10</span>)<span class="comment">//default  </span></span><br><span class="line">     &#123;  </span><br><span class="line">         maxSize=size;  </span><br><span class="line">         front=<span class="literal">nullptr</span>;  </span><br><span class="line">         rear=<span class="literal">nullptr</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     ~<span class="built_in">AQueue</span>()  </span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="keyword">while</span>(front!=<span class="literal">nullptr</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">             link* empt=front;  </span><br><span class="line">             front=front-&gt;next;  </span><br><span class="line">             <span class="keyword">delete</span> empt;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">while</span>(front!=<span class="literal">nullptr</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">             link* empt=front;  </span><br><span class="line">             front=front-&gt;next;  </span><br><span class="line">             <span class="keyword">delete</span> empt;  </span><br><span class="line">         &#125;  </span><br><span class="line">         rear=<span class="literal">nullptr</span>;  </span><br><span class="line">         front=<span class="literal">nullptr</span>;  </span><br><span class="line">         len=<span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(constE&amp; item)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(len==<span class="number">0</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">             link* empt=<span class="keyword">new</span> <span class="built_in">link</span>(item);  </span><br><span class="line">             front=empt;  </span><br><span class="line">             rear=empt;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span>&#123;  </span><br><span class="line">             link* empt=<span class="keyword">new</span> <span class="built_in">link</span>(item);  </span><br><span class="line">             rear-&gt;next=empt;  </span><br><span class="line">             rear=empt;  </span><br><span class="line">         &#125;  </span><br><span class="line">         len++;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function">E <span class="title">dequeue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(front!=rear)  </span><br><span class="line">         &#123;  </span><br><span class="line">             E item=front-&gt;element;  </span><br><span class="line">             link* empt=front;  </span><br><span class="line">             front=front-&gt;next;  </span><br><span class="line">             <span class="keyword">delete</span> empt;  </span><br><span class="line">             len--;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">const</span> E&amp; <span class="title">frontValue</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> front-&gt;element;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> len;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">       </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>根：无父</p>
<p>节点：</p>
<p>树叶：有父无子</p>
<p>兄弟：有相同父亲</p>
<p>路径：两节点间的线段数量</p>
<p>深度(depth)：根到该节点的线段数，即深度是从0</p>
<p>高(height)：该点到最远的叶节点</p>
<p>真祖先—真后裔：父子不相等</p>
<h2 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h2><p>考虑到为每个节点设置超出实际范围的指针数不灵活，改为为每个节点设置指向下一个兄弟和自己的儿子的指针。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">object</span>&gt;  </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">treeNode</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     object data;  </span><br><span class="line">     treeNode* brother;  </span><br><span class="line">     treeNode* child;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> ​  </span><br></pre></td></tr></table></figure></p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><h3 id="先序遍历-preorder-："><a href="#先序遍历-preorder-：" class="headerlink" title="先序遍历(preorder)："></a>先序遍历(preorder)：</h3><p>根—左子树—-右子树`</p>
<h3 id="中序遍历-inorder-："><a href="#中序遍历-inorder-：" class="headerlink" title="中序遍历(inorder)："></a>中序遍历(inorder)：</h3><p>左子树—根—-右子树<br>一般通过表达式构建中序遍历树，再以此得到其他遍历</p>
<h3 id="后续遍历-postorder-："><a href="#后续遍历-postorder-：" class="headerlink" title="后续遍历(postorder)："></a>后续遍历(postorder)：</h3><p>左子树—右子树—-根</p>
<h3 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(treeNode* Tree)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(Tree==<span class="literal">NULL</span>)  </span><br><span class="line">         <span class="keyword">return</span>;  </span><br><span class="line">         cout&lt;&lt;Tree-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">         <span class="built_in">preorder</span>(Tree-&gt;left);  </span><br><span class="line">         <span class="built_in">preorder</span>(Tree-&gt;right);  </span><br><span class="line">         <span class="keyword">return</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(tree* Tree)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="built_in">preorder</span>(root);  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">ineorder</span><span class="params">(treeNode* Tree)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(Tree==<span class="literal">NULL</span>)  </span><br><span class="line">         <span class="keyword">return</span>;  </span><br><span class="line">         <span class="built_in">preorder</span>(Tree-&gt;left);  </span><br><span class="line">         cout&lt;&lt;Tree-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">         <span class="built_in">preorder</span>(Tree-&gt;right);  </span><br><span class="line">         <span class="keyword">return</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">ineorder</span><span class="params">(tree* Tree)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="built_in">ineorder</span>(root);  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(treeNode* Tree)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(Tree==<span class="literal">NULL</span>)  </span><br><span class="line">         <span class="keyword">return</span>;  </span><br><span class="line">         <span class="built_in">preorder</span>(Tree-&gt;left);  </span><br><span class="line">         <span class="built_in">preorder</span>(Tree-&gt;right);  </span><br><span class="line">         cout&lt;&lt;Tree-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">         <span class="keyword">return</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(tree* Tree)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="built_in">postorder</span>(root);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>通过遍历得到的图的结果可能不唯一，但若有一个树的两个遍历时，那么就可以得到唯一的结果<br>-此处应链接一已知前序和中序求原树的代码</p>
<h2 id="二叉树-Binary-tree"><a href="#二叉树-Binary-tree" class="headerlink" title="二叉树(Binary tree)"></a>二叉树(Binary tree)</h2><p>每个节点的儿子数不多于2</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>左子树的所有值小于根，右子树的所有值大于根</p>
<h4 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h4><p>叶为操作数，节点为操作符。以三种不同的遍历方式能得到三种不同的表达式</p>
<p>即从先序等三种遍历的结果回溯到原本的树</p>
<h2 id="二叉查找树-1"><a href="#二叉查找树-1" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>关键的函数有：contains（用bool反馈是否存在），findmin，insert（有点巧妙），delete（区别三种情况，无子，单子，）<br>指针的引用与普通指针的区别在于你想修改的是指针指向的地址的数据还是指针副本的数据，即指针副本的指向关系不会同步到本体上，但引用会</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinNode</span>  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> E&amp; <span class="title">element</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setElement</span><span class="params">(E&amp;)</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> BinNode&lt;E&gt;* <span class="title">left</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> BinNode&lt;E&gt;* <span class="title">right</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setLeft</span><span class="params">(BinNode&lt;E&gt;*)</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setRight</span><span class="params">(BinNode&lt;E&gt;*)</span></span>=<span class="number">0</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>=<span class="number">0</span>;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinaryNode</span>:<span class="keyword">public</span> BinNode&lt;E&gt;  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     E element;  </span><br><span class="line">     BinaryNode* leftChild;  </span><br><span class="line">     BinaryNode* rightChild;  </span><br><span class="line">     <span class="built_in">BinaryNode</span>(<span class="type">const</span> E&amp; theElement,BinaryNode* lt,BinaryNode* rt):<span class="built_in">element</span>(theElement),<span class="built_in">leftChild</span>(lt),<span class="built_in">rightChild</span>(rt)&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">E</span>&gt;  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>:<span class="keyword">public</span> BinaryNode&lt;E&gt;  </span><br><span class="line"> &#123;  </span><br><span class="line">	 <span class="keyword">private</span>:</span><br><span class="line">	 BinaryNode* root;</span><br><span class="line">	 </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     <span class="comment">//必须传入一个变量t来实现递归</span></span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> E&amp; x,BinaryNode* t)</span><span class="type">const</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=t-&gt;element)<span class="keyword">return</span> <span class="built_in">contains</span>(x,t-&gt;<span class="built_in">left</span>());  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=t-&gt;element)<span class="keyword">return</span> <span class="built_in">contains</span>(x,t-&gt;<span class="built_in">right</span>());  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;</span><br><span class="line">     <span class="function">BinaryNode* <span class="title">findMin</span><span class="params">(BinaryNode* t)</span><span class="type">const</span></span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line">         <span class="keyword">if</span>(t-&gt;<span class="built_in">left</span>()==<span class="literal">nullptr</span>)<span class="keyword">return</span> t;  </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">findMin</span>(t-&gt;<span class="built_in">left</span>());  </span><br><span class="line">     &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直到找到一个位置合适的空节点</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; x,BinaryNode* &amp;t)</span><span class="comment">//注意&amp;  </span></span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)  </span><br><span class="line">         t=<span class="keyword">new</span> <span class="built_in">BinaryNode</span>&lt;E&gt;(x,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;element&lt;x)<span class="keyword">return</span> <span class="built_in">insert</span>(x,t-&gt;left);  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;element&gt;x)<span class="keyword">return</span> <span class="built_in">insert</span>(x,t-&gt;right);  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span>;  </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//先寻找</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> E&amp;x,BinaryNode*&amp; t)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;  </span><br><span class="line">         <span class="keyword">if</span>(x&lt;t-&gt;element)<span class="built_in">Delete</span>(x,t-&gt;left);  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;t-&gt;element)<span class="built_in">Delete</span>(x,t-&gt;right);  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;<span class="built_in">left</span>()!=<span class="literal">nullptr</span>&amp;&amp;t-&gt;<span class="built_in">right</span>()!=<span class="literal">nullptr</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">         <span class="comment">//右子树中找最小元</span></span><br><span class="line">             BinaryNode* tmp=<span class="built_in">findMin</span>(t-&gt;<span class="built_in">right</span>());  </span><br><span class="line">             t-&gt;element=tmp-&gt;element;  </span><br><span class="line">             <span class="built_in">Delete</span>(tmp-&gt;element,t-&gt;<span class="built_in">right</span>());  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">         &#123;  </span><br><span class="line"></span><br><span class="line">			<span class="comment">//此出设计较为巧妙</span></span><br><span class="line"></span><br><span class="line">             BinaryNode* oldNode=t;  </span><br><span class="line">             t=t-&gt;<span class="built_in">left</span>()!=<span class="literal">nullptr</span>?t-&gt;<span class="built_in">left</span>():t-&gt;<span class="built_in">right</span>();  </span><br><span class="line">             <span class="keyword">delete</span> oldNode;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="AVL（注）"><a href="#AVL（注）" class="headerlink" title="AVL（注）"></a>AVL（注）</h2><p>是二叉搜索树的衍生，但就平衡问题展开旋转操作</p>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><h4 id="单旋"><a href="#单旋" class="headerlink" title="单旋"></a>单旋</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotateWithLeftChild</span><span class="params">(AvlNode*&amp; t)</span><span class="comment">//左左的单旋转，即单旋中的右旋  </span></span></span><br><span class="line"><span class="function">     <span class="comment">//使用&amp;确保我们操作的对象是t的父节点parent的parent-&gt;left  </span></span></span><br><span class="line"><span class="function">     <span class="comment">//好比两个指针指向同一个空间，但是改变其中一个指针的指向不会影响另一个指针一样  </span></span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         AvlNode* newTop=t-&gt;left;<span class="comment">//新根节点  </span></span><br><span class="line">         t-&gt;left=newTop-&gt;right;<span class="comment">//易子  </span></span><br><span class="line">         newTop-&gt;right=t;<span class="comment">//交替  </span></span><br><span class="line">         t=newTop;<span class="comment">//变根  </span></span><br><span class="line"> ​  </span><br><span class="line">         t-&gt;right-&gt;height=<span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;right-&gt;left),<span class="built_in">height</span>(t-&gt;right-&gt;right))+<span class="number">1</span>;  </span><br><span class="line">         t-&gt;height=<span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left),<span class="built_in">height</span>(t-&gt;right))+<span class="number">1</span>;  </span><br><span class="line">         <span class="comment">//不需要更新左子树的高度，因为没有改动  </span></span><br><span class="line"> ​  </span><br><span class="line">     &#125;<span class="comment">//中间节点的右子变为原根节点的左子</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">rotateWithRightChild</span><span class="params">(AvlNode*&amp; t)</span><span class="comment">//单旋中的左旋  </span></span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         AVlNode* newTop=t-&gt;right;  </span><br><span class="line">         t-&gt;right=newTop-&gt;left;  </span><br><span class="line">         newTop-&gt;left=t;  </span><br><span class="line">         t=newTop;  </span><br><span class="line"> ​  </span><br><span class="line">         t-&gt;left-&gt;height=<span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;right-&gt;left),<span class="built_in">height</span>(t-&gt;right-&gt;right))+<span class="number">1</span>;  </span><br><span class="line">         t-&gt;height=<span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left),<span class="built_in">height</span>(t-&gt;right))+<span class="number">1</span>;  </span><br><span class="line">     &#125;<span class="comment">//中间节点的左子变为原根节点的右子</span></span><br></pre></td></tr></table></figure>
<h4 id="双旋"><a href="#双旋" class="headerlink" title="双旋"></a>双旋</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="function"><span class="type">void</span> <span class="title">doubleWithLeftChild</span><span class="params">(AvlNode*&amp; t)</span><span class="comment">//双旋中的右旋，只使用于目标节点左孩子的左孩子为空  </span></span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="comment">// Step 1: 先对 t-&gt;left 进行单右旋转 (即左旋转)  </span></span><br><span class="line">         <span class="built_in">rotateWithRightChild</span>(t-&gt;left);  </span><br><span class="line"> ​  </span><br><span class="line">         <span class="comment">// Step 2: 再对 t 进行单左旋转 (即右旋转)  </span></span><br><span class="line">         <span class="built_in">rotateWithLeftChild</span>(t);  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">doubleWithRightChild</span><span class="params">(AvlNode*&amp; t)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="built_in">rotateWithLeftChild</span>(t-&gt;right);<span class="comment">//先左  </span></span><br><span class="line">         <span class="built_in">rorateWithRightChild</span>(t-&gt;left);<span class="comment">//后右  </span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AVL树的旋转，归结为：<br>自从下往上第一个不平衡的节点起，向下按顺序寻找两个节点（若这两个节点的形状机符合单旋转，又符合双旋转，则取单旋转），将这三个节点排序，原来的不平衡节点的父节点放置在先已经排序的根节点上，其余的子节点按原旋转方法放置。</p>
<h3 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(AvlNode* t)</span><span class="type">const</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> t==<span class="literal">nullptr</span>?<span class="number">-1</span>:t-&gt;height;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; x,AvlNode*&amp;t)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">             t=<span class="keyword">new</span> AvlNode&#123;x,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>&#125;;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;t-&gt;data)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="built_in">insert</span>(x,t-&gt;left);  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span>&#123;  </span><br><span class="line">             <span class="built_in">insert</span>(x,t-&gt;right)  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="built_in">balance</span>(t);  </span><br><span class="line">         <span class="comment">//递归特性，从真正插入的那时算起，一层一层的开始balance，balance结尾还会重新计算高度</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">balance</span><span class="params">(AvlNode* &amp; t)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;  </span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">height</span>(t-&gt;left)-<span class="built_in">height</span>(t-&gt;right)&gt;IMBALANCE)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">height</span>(t-&gt;left-&gt;left)&gt;=<span class="built_in">height</span>(t-&gt;left-&gt;right))  </span><br><span class="line">             &#123;  </span><br><span class="line">                 <span class="built_in">rotateWithLeftChild</span>(t);<span class="comment">//单旋，左左  </span></span><br><span class="line">             &#125;  </span><br><span class="line">             <span class="keyword">else</span>  </span><br><span class="line">             &#123;  </span><br><span class="line">                 <span class="built_in">doubleWithLeftChild</span>(t);<span class="comment">//双旋，左右  </span></span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">height</span>(t-&gt;right)-<span class="built_in">height</span>(t-&gt;left)&gt;IMBALANCE)  </span><br><span class="line">             &#123;  </span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">height</span>(t-&gt;right-&gt;right)&gt;=<span class="built_in">height</span>(t-&gt;right-&gt;left))  </span><br><span class="line">                 &#123;  </span><br><span class="line">                     <span class="built_in">rotateWithRightChild</span>(t);  </span><br><span class="line">                 &#125;  </span><br><span class="line">                 <span class="keyword">else</span>&#123;  </span><br><span class="line">                     <span class="built_in">doubleWithRightChild</span>(t);  </span><br><span class="line">                 &#125;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         t-&gt;height=<span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left),<span class="built_in">max</span>(t-&gt;right))+<span class="number">1</span>;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>注：每次balance都会重新矫正这层的高度，因此放在顺序结构的最下层，以便递归时从小到大的进行balance</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> E&amp;x,AvlNode*&amp; t)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;  </span><br><span class="line"> ​  </span><br><span class="line">         <span class="keyword">if</span>(x&lt;t-&gt;element)<span class="built_in">Delete</span>(x,t-&gt;left);  </span><br><span class="line"> ​  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;t-&gt;element)<span class="built_in">Delete</span>(x,t-&gt;right);  </span><br><span class="line"> ​  </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;<span class="built_in">left</span>()!=<span class="literal">nullptr</span>&amp;&amp;t-&gt;<span class="built_in">right</span>()!=<span class="literal">nullptr</span>)  </span><br><span class="line">         &#123;  </span><br><span class="line">             BinaryNode* tmp=<span class="built_in">findMin</span>(t-&gt;<span class="built_in">right</span>());  </span><br><span class="line">             t-&gt;element=tmp-&gt;element;  </span><br><span class="line">             <span class="built_in">Delete</span>(tmp-&gt;element,t-&gt;<span class="built_in">right</span>());  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">         &#123;  </span><br><span class="line">             BinaryNode* oldNode=t;  </span><br><span class="line">             t=t-&gt;<span class="built_in">left</span>()!=<span class="literal">nullptr</span>?t-&gt;<span class="built_in">left</span>():t-&gt;<span class="built_in">right</span>();  </span><br><span class="line">             <span class="keyword">delete</span> oldNode;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="built_in">balance</span>(t);  </span><br><span class="line">         <span class="comment">//递归同理</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="伸展树-spread-tree"><a href="#伸展树-spread-tree" class="headerlink" title="伸展树(spread tree)"></a>伸展树(spread tree)</h2><p>内部节点结构为<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241125163742.png></p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>假设findR</p>
<p>伸展树的每次find都会使被访问到的节点旋转到根节点</p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006141941.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006141957.png" alt=""><br>这种旋转，应先旋转Q，P，再R，Q</p>
<h3 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h3><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006142020.png" alt=""><br>看上去就像是移动了两个节点（仅对“一字型”而言），其余一致</p>
<p>注：因为伸展树的旋转树是硬转，可能平衡，也可能不平衡，故有时为了把目标节点旋转到根节点的位置，需要补充空节点。其余与AVL一致</p>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>即正常插入值后再将其旋转到根上</p>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>访问一次该节点，置到根上后删除，取左子树的最大值，展开到根，原本的右子树作为现在的根的右子树</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树相比于二叉树，有更多的子代。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>数据项存储在叶上</p>
</li>
<li><p>阶数(order)M表示节点<strong>最大的子树数量</strong>，因此其最多可以存储M-1个关键字，第i个关键字代表第i+1个子树的最小值</p>
</li>
<li><p>根的儿子数在<strong>2~M</strong>之间</p>
</li>
<li><p>非叶非根节点的孩子数在⌈ M/2⌉~M之间，关键词数另计</p>
</li>
<li><p>所有叶节点存储的数据项数在⌈ L/2⌉~L之间</p>
</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006142037.png" alt=""></p>
<p>如上图，B+树适用于数据库索引，按键值排序，并且每个叶节点之间用指针链接</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B-树"></a>B-树</h3><p>B-树实际上就是B树，我们通常把叶节点用指针链接起来的B-树称为B+树</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Find</span>(ElementType K, Btree T)&#123;</span><br><span class="line"></span><br><span class="line">  B = T;<span class="comment">//B表示当前节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (B is <span class="keyword">not</span> a leaf)&#123;</span><br><span class="line"></span><br><span class="line">   find the Pi in node B that points to the proper subtree that K will be in;</span><br><span class="line"></span><br><span class="line">   B = Pi;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now we’re at a leaf */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> key K is the jth key in  leaf  B,</span><br><span class="line"></span><br><span class="line">   use the jth record pointer to find the</span><br><span class="line"></span><br><span class="line">   associated record;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* K is not in leaf B */</span> report failure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="查找过程讲解："><a href="#查找过程讲解：" class="headerlink" title="查找过程讲解："></a>查找过程讲解：</h5><ol>
<li><p><strong>初始化</strong>：从树的根节点 <code>T</code> 开始，将当前节点 <code>B</code> 设置为根节点 <code>T</code>，即 <code>B = T</code>。这个过程是从根开始的，因为 B-树的查找和普通树的查找类似，都是从根节点依次向下递归进入子树进行查找。</p>
</li>
<li><p><strong>遍历非叶节点</strong>：</p>
<ul>
<li>伪代码中的 <code>while (B is not a leaf)</code> 意味着查找过程中只要没有到达叶子节点，就继续向下查找。</li>
<li>在非叶节点中，B-树节点包含多个关键字，每个关键字对应一个范围，将关键字 <code>K</code> 与当前节点的关键字进行比较，找到 <code>K</code> 所在的范围，确定 <code>Pi</code>，即指向合适子树的指针。</li>
<li>找到正确的子树后，将当前节点 <code>B</code> 设为该子树的根节点，即 <code>B = Pi</code>，继续遍历子树。</li>
</ul>
</li>
<li><p><strong>进入叶节点</strong>：</p>
<ul>
<li>当遍历到叶子节点时，循环结束，此时 <code>B</code> 是一个叶子节点。</li>
<li>B-树的所有数据记录或数据的指针都存储在叶子节点中，因此需要在叶子节点上确认是否包含要查找的关键字 <code>K</code>。</li>
</ul>
</li>
<li><p><strong>查找关键字</strong>：</p>
<ul>
<li>如果关键字 <code>K</code> 存在于当前叶子节点 <code>B</code> 中，且是第 <code>j</code> 个关键字，则通过 <code>j</code> 对应的记录指针找到与 <code>K</code> 相关的记录。</li>
<li>如果在叶子节点中没有找到 <code>K</code>，即关键字不在当前节点中，报告查找失败。</li>
</ul>
</li>
</ol>
<h5 id="B-树查找的核心思想"><a href="#B-树查找的核心思想" class="headerlink" title="B-树查找的核心思想"></a>B-树查找的核心思想</h5><ul>
<li><p><strong>分层查找</strong>：B-树的查找是通过逐层向下，逐渐缩小查找范围的过程。每次查找都通过在非叶节点中找到指向子树的指针，递归地进入对应子树，直到最终找到或确认关键字不存在。</p>
</li>
<li><p><strong>多路分支</strong>：每个B-树节点（尤其是非叶节点）通常包含多个关键字，因此每个节点的查找类似于在多个范围中确定属于哪一个范围，并选择相应的子树。</p>
</li>
<li><p><strong>叶子节点存储数据</strong>：B-树的叶子节点保存了所有关键字及其相关数据或指针，因此最终查找的结果都会在叶子节点中完成。</p>
<h4 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Insert</span>(ElementType K, Btree B)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   find the leaf node LB of B in which K belongs;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">if</span> <span class="title">notfull</span><span class="params">(LB)</span> insert K into LB</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     split LB into two nodes LB <span class="keyword">and</span> LB2 with</span><br><span class="line"></span><br><span class="line">      j = <span class="built_in">int</span>((L+<span class="number">1</span>)/<span class="number">2</span>) keys in LB <span class="keyword">and</span> the rest in LB2;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ( <span class="built_in">IsNull</span>(<span class="built_in">Parent</span>(LB)) )</span><br><span class="line"></span><br><span class="line">           <span class="built_in">CreateNewRoot</span>(LB, K[j+<span class="number">1</span>], LB2);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">           <span class="built_in">InsertInternal</span>(<span class="built_in">Parent</span>(LB), K[j+<span class="number">1</span>], LB2);   </span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="插入过程讲解"><a href="#插入过程讲解" class="headerlink" title="插入过程讲解"></a>插入过程讲解</h5></li>
</ul>
<ol>
<li><p><strong>找到合适的叶节点</strong>：</p>
<ul>
<li>首先，通过B-树的查找过程，找到<code>K</code>应该插入的叶子节点 <code>LB</code>。这和查找操作类似，即从根节点开始，逐步向下寻找正确的叶子节点。</li>
</ul>
</li>
<li><p><strong>检查叶子节点是否有空位</strong>：</p>
<ul>
<li>如果 <code>LB</code> 还没有满，直接将关键字 <code>K</code> 插入 <code>LB</code> 中合适的位置。这个步骤相对简单，因为B-树的节点是有序的，插入时需要保持节点内的关键字顺序。</li>
</ul>
</li>
<li><p><strong>叶子节点满时的分裂</strong>：</p>
<ul>
<li>如果叶子节点 <code>LB</code> 已经满了，则需要进行分裂操作。具体步骤如下：<ul>
<li>将叶子节点 <code>LB</code> 分成两个节点 <code>LB1</code> 和 <code>LB2</code>。</li>
<li>设 <code>j = ⌊(L+1)/2⌋</code>（向下取整），即计算将原叶子节点中的关键字一分为二的位置。分裂后，<code>LB1</code> 保留前 <code>j</code> 个关键字，剩下的关键字放入新节点 <code>LB2</code> 中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理父节点</strong>：</p>
<ul>
<li><p>分裂节点后，需要将中间的关键字（<code>K[j+1]</code>，即分裂过程中跨越两个节点的中间关键字）插入到父节点中，以保持B-树的结构。</p>
</li>
<li><p>如果 <code>LB</code> 没有父节点，说明 <code>LB</code> 原来是根节点，这种情况下需要创建一个新的根节点。新的根节点会包含 <code>K[j+1]</code> 作为它的唯一关键字，并且指向两个子节点 <code>LB1</code> 和 <code>LB2</code>。</p>
</li>
<li><p><strong>注：在叶节点以外，所有的关键字只出现一次</strong></p>
</li>
<li><p>如果 <code>LB</code> 有父节点，则将 <code>K[j+1]</code> 插入到 <code>LB1</code> 的父节点中，并且父节点要处理 <code>LB2</code> 作为新的子节点的情况。这个过程可能导致父节点再次溢出，从而需要递归地进行分裂和插入操作。</p>
</li>
</ul>
</li>
<li><p><strong>递归处理父节点插入</strong>：</p>
<ul>
<li>如果父节点在插入新关键字时再次溢出，那么需要重复上述分裂和插入的过程，直到没有溢出的情况为止。这个过程可能会从叶子节点一直递归到根节点，最终可能会导致整个树的高度增加。</li>
</ul>
</li>
</ol>
<h5 id="插入的核心思想"><a href="#插入的核心思想" class="headerlink" title="插入的核心思想"></a>插入的核心思想</h5><ul>
<li><p><strong>局部调整</strong>：B-树的插入操作优先在叶子节点进行。如果叶子节点有空位，插入操作只会影响该叶子节点，不需要对树做任何调整。</p>
</li>
<li><p><strong>分裂节点</strong>：当节点满时，必须将其分裂为两个节点，并将中间关键字提升到父节点。这种机制确保了B-树的节点不会超过预定的容量上限。</p>
</li>
<li><p><strong>递归调整父节点</strong>：如果父节点也因为插入新关键字而满了，同样需要进行分裂，并将中间关键字继续提升。这个过程可能递归到根节点。如果根节点溢出，则需要创建一个新的根节点，树的高度因此增加<br>注：叶节点与其父节点之间可以存在重复元素，但其他的则不行</p>
<h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><h5 id="B-树删除操作的过程"><a href="#B-树删除操作的过程" class="headerlink" title="B-树删除操作的过程"></a>B-树删除操作的过程</h5></li>
</ul>
<p>B-树的删除主要包括以下步骤：</p>
<ol>
<li><p><strong>找到要删除的关键字所在的节点</strong>：</p>
<ul>
<li>通过类似查找操作的方式，从根节点出发，找到包含要删除关键字 <code>K</code> 的叶子节点或非叶节点。</li>
</ul>
</li>
<li><p><strong>删除的三种情况</strong>： 删除操作根据关键字所在的位置分为三种情况来处理。</p>
<ul>
<li><p><strong>情况1：关键字在叶子节点</strong><br>  如果要删除的关键字 <code>K</code> 在叶子节点，且删除不会导致叶子节点的关键字数目低于最低要求（即至少有 $\lceil m/2 \rceil - 1$ 个关键字，其中 <code>m</code> 是B-树的阶数），那么可以直接删除该关键字，不需要额外调整。</p>
<p>  <strong>例子</strong>：如果叶子节点中有足够的关键字（比如超过最低要求），可以直接删除 <code>K</code> 而不破坏B-树的结构。</p>
</li>
<li><p><strong>情况2：关键字在非叶节点</strong><br>  如果要删除的关键字 <code>K</code> 位于非叶节点，那么有两种方法处理：</p>
<ol>
<li><strong>用前驱替换</strong>：找到 <code>K</code> 在该节点左子树中的最大关键字（即<code>K</code>的<strong>前驱</strong>），将其替换 <code>K</code>，并在前驱所在的叶子节点中删除该前驱。</li>
<li><p><strong>用后继替换</strong>：找到 <code>K</code> 在该节点右子树中的最小关键字（即<code>K</code>的<strong>后继</strong>），将其替换 <code>K</code>，并在后继所在的叶子节点中删除该后继。</p>
<p>删除后递归处理前驱或后继的删除情况。</p>
</li>
</ol>
</li>
<li><p><strong>情况3：关键字在叶子节点中且删除会导致关键字数目不足</strong><br>  如果删除关键字 <code>K</code> 后，叶子节点中的关键字数目低于最低要求，就需要进行<strong>借位</strong>或<strong>合并</strong>操作来恢复B-树的平衡：</p>
<ol>
<li><p><strong>借位</strong>：如果 <code>K</code> 的兄弟节点有多于最低要求的关键字，则可以从兄弟节点中借一个关键字。借位过程通过父节点调整关键字，使得父节点的某个关键字“下移”到当前节点，同时从兄弟节点“上移”一个关键字到父节点。</p>
</li>
<li><p><strong>合并</strong>：如果 <code>K</code> 的兄弟节点也只包含最低数量的关键字，则将当前节点和其兄弟节点<strong>合并</strong>，并将父节点中的一个关键字下移到合并后的节点。合并后，如果父节点关键字数目不足，可能需要对父节点递归进行合并或借位。<br>如图<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241007194010.png><br>删除17，则13，14，18合并，二级节点的17同时被删除，向其兄弟节点借来11，兄弟的子节点中大于11的索引同步过来。</p>
<h2 id="set与map"><a href="#set与map" class="headerlink" title="set与map"></a>set与map</h2><p>由于其内核都为红黑树，故放在此处讨论，各方法详见STL</p>
<h3 id="set的实现与map的实现"><a href="#set的实现与map的实现" class="headerlink" title="set的实现与map的实现"></a>set的实现与map的实现</h3><p>为该进iterator，使用线索树，在iterator中设置一个bool，不同的值对应左子树还是右子树使用线索的表示</p>
<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1></li>
</ol>
</li>
</ul>
</li>
<li>散列是一种用于以常数时间插入，删除和查找的技术。</li>
<li><p>散列通过将数据组使用散列函数得到的值作为索引，以达到类似于数组的效果</p>
</li>
<li><p>散列函数也通常用来加密数据库中的密码，其具有不可逆性，既不能通过散列值得到原本的值</p>
</li>
<li><p>散列是将较大范围的值映射到较小范围内的，这不可避免的会出现带入值不同而散列值一致的情况。</p>
</li>
<li><p>专用于查找与插入为<code>o(1)</code>的情况<br>我们将可存储的空间称为<strong>槽（slot）</strong></p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2></li>
<li><strong>成功的搜索</strong>：找到键为$K_i=K$的记录；<strong>不成功的搜索</strong>：未找到</li>
<li><strong>完全匹配（exact-match query）</strong>：查询的键值和给定键值匹配</li>
<li><strong>范围查询（range query）</strong>：查询的键值完全落在给定的键值中</li>
<li><strong>自组织列表（self-organizing lists）</strong> 使用启发式（heuristic）的策略来决定如何对列表进行重新排序<ol>
<li><strong>count</strong>：存储每条记录的访问次数，并始终按此顺序维护记录</li>
<li><strong>Move-to-front</strong>找到记录后把记录置于列表的前面</li>
<li><strong>transpose</strong>将找到的任何记录与列表中紧接在前面的记录交换<h2 id="为什么不使用数组？"><a href="#为什么不使用数组？" class="headerlink" title="为什么不使用数组？"></a>为什么不使用数组？</h2></li>
</ol>
</li>
</ol>
<ul>
<li><strong>节省空间</strong>：直接分配一个大数组意味着要为每个可能的键值分配内存。比如，如果你的键值范围是 0 到 10亿，分配一个长度为 10亿的数组会占用大量的内存，而实际上你可能只需要存储几百个或几千个键值。散列表通过散列函数将键值映射到一个较小的索引空间，因此更加节省空间。</li>
<li><p><strong>稀疏（spare）</strong></p>
</li>
<li><p><strong>灵活的键类型</strong>：如果键不是简单的整数，而是字符串、对象等复杂类型，直接用这些键作为数组索引是不现实的。散列函数可以将这些复杂键映射为一个整数索引，从而适应更灵活的键类型。</p>
</li>
<li><p><strong>更快的查找速度</strong>：散列表的查找、插入和删除操作在理想情况下可以达到常数时间复杂度 O(1)O(1)O(1)，相比线性查找数组中的元素快得多。散列函数直接计算出索引，不需要遍历数组。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2></li>
</ul>
<ol>
<li>作为散列表                                                                                                                                      </li>
<li>对比验证信息传输的正确性</li>
<li>对比散列值矫正数据错误</li>
<li>数据库索引</li>
<li>cache</li>
<li>密码学</li>
<li><p>用于在RAM上查找数据</p>
<h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><p>通过键值直接访问的一种数据结构</p>
<h3 id="碰撞（collision）"><a href="#碰撞（collision）" class="headerlink" title="碰撞（collision）"></a>碰撞（collision）</h3><p>不同的关键字得到相同的哈希值（hash value）</p>
<h3 id="构造散列函数"><a href="#构造散列函数" class="headerlink" title="构造散列函数"></a>构造散列函数</h3><h4 id="直接定址法（注）"><a href="#直接定址法（注）" class="headerlink" title="直接定址法（注）"></a>直接定址法（注）</h4><p>哈希值为本身的方法，需要关键字连续且范围较小</p>
<h4 id="平分取中法（mid-square）（注）"><a href="#平分取中法（mid-square）（注）" class="headerlink" title="平分取中法（mid-square）（注）"></a>平分取中法（mid-square）（注）</h4><p>将关键字平方后取特定连续位数的一种方法</p>
<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a><em>数字分析法</em></h4><p><em>排除连续关键字中相同的或者具有相同特征的位，取剩余的位合并为一个哈希值</em></p>
<h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a><em>折叠法</em></h4><p><em>将本身较长的关键字分为均匀的几个部分，在将他们自低位对齐后相加得到哈希值</em></p>
<h4 id="随机值"><a href="#随机值" class="headerlink" title="随机值"></a><em>随机值</em></h4><p><em>取关键字的随机函数值作为哈希值</em></p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a><em>除留余数法</em></h4><p><em>对于表长为m的哈希表，取值p&lt;=m，使hash(k)=k%p;p一般取接近m的素数或m本身</em></p>
<h4 id="减去法"><a href="#减去法" class="headerlink" title="减去法"></a><em>减去法</em></h4><p><em>相当于直接定址法，只不过减去了一个固定的值使得索引可以从较小的值开始，如0，1，2…</em></p>
<h4 id="基数转换法"><a href="#基数转换法" class="headerlink" title="基数转换法"></a><em>基数转换法</em></h4><p><em>将十进制的关键字视为与十互素的进制，再转换为十进制</em></p>
<h4 id="字符串数值哈希法"><a href="#字符串数值哈希法" class="headerlink" title="字符串数值哈希法"></a><em>字符串数值哈希法</em></h4><p><em>适用于关键字使字符串的情况</em></p>
<h2 id="处理冲突（碰撞）"><a href="#处理冲突（碰撞）" class="headerlink" title="处理冲突（碰撞）"></a>处理冲突（碰撞）</h2><h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><p>由于大部分散列函数的结果从总体上看是不连续且显著集中分布的，故聚集情况常常出现</p>
<h3 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h3><script type="math/tex; mode=display">Load factor=\frac{n}{k}$$其中，n是哈希表中的条目数，k是哈希表的大小，负载因子越大，n越接近k，哈希表越慢
有访问时间$O（1）+O（\lambda )$。
### 开放定址法（open addressing）
即项目的地址不是由其哈希值决定的。
$$H_i=(H(key)+d_i)\%m,i=1,2,3...</script><p>其中$H（key）$为哈希函数，m为表长，$d_i$为增量序列</p>
</li>
</ol>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>假定关键字%10的结果为散列函数，若插入时空间已经满了，那么则执行以下的方法，使得重新选址</p>
<h5 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h5><p><strong>linear probing</strong><br>增量序列一般固定为1，即$d_i$=1，线性探测倾向于使散列表填满，但这会大大减慢单列表的速度。同时，也会引发<strong>一次聚集</strong>问题，即散列表中的某个区块全部被占用，此时需要的插入的时间就大大延长了</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>散列地址</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>未插入</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>插入89</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>89</td>
</tr>
<tr>
<td>插入18</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>89</td>
</tr>
<tr>
<td>插入49</td>
<td>49</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>89</td>
</tr>
<tr>
<td>插入58</td>
<td>49</td>
<td>58</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>89</td>
</tr>
<tr>
<td>插入69</td>
<td>49</td>
<td>58</td>
<td>69</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>19</td>
</tr>
</tbody>
</table>
</div>
<p>当计算的散列值对应的空间已经满了，那么就在线性探测中使用公式，依次向后移动<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241204101258.png></p>
<h5 id="平方探测（注）"><a href="#平方探测（注）" class="headerlink" title="平方探测（注）"></a>平方探测（注）</h5><p>取增长序列为$d_i=(i\%10)^2$<br>平方探测可以解决线性探测的一次聚集问题。<br>有定理：<strong>如果使用平方探测，表的大小是素数，且表的一半及以上是空的，那么总能成功插入一个素数</strong>。<br>但这也引发了二次聚集问题。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>散列地址</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>未插入</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>插入89</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>89</td>
</tr>
<tr>
<td>插入18</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>89</td>
</tr>
<tr>
<td>插入49</td>
<td>49</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>89</td>
</tr>
<tr>
<td>插入58</td>
<td>49</td>
<td></td>
<td>58</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>89</td>
</tr>
<tr>
<td>插入69</td>
<td>49</td>
<td></td>
<td>58</td>
<td>69</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>18</td>
<td>89</td>
</tr>
</tbody>
</table>
</div>
<h5 id="双重哈希"><a href="#双重哈希" class="headerlink" title="双重哈希"></a><em>双重哈希</em></h5><p><em>使用哈希值的随机函数取得。</em></p>
<h5 id="双散列（注）"><a href="#双散列（注）" class="headerlink" title="双散列（注）"></a>双散列（注）</h5><p>取增长序列为$d_i=i·H2(key)$,有此，哈希函数hash2的结果不能为0。<br>对于此方法，算出H2后，用i遍历插入尝试，i的范围是0到散列表的最大值－1。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><h4 id="链接列表分开存储"><a href="#链接列表分开存储" class="headerlink" title="链接列表分开存储"></a>链接列表分开存储</h4><p>开放定址法是将重复的地址转换为不重复的地址，而此方法将所有重复的地址放在一起。<br>这种方法的基本思想是把所有哈希地址为i的元素构成一个称为同义词链的单链表，并将其头指针存放在哈希表的第i个单元中。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008231802.png style="zoom:67%;" /></p>
<h4 id="列表头单元格分开链接"><a href="#列表头单元格分开链接" class="headerlink" title="列表头单元格分开链接"></a>列表头单元格分开链接</h4><p>将第一条记录放置在单元格内，并设置一个指针以访问下一条同地址的记录。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008232113.png  style="zoom:67%;" /></p>
<h4 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h4><p>可以将存储的信息放置到链表中，每条链表的代表每个同地址的记录，单元格存放链表的头指针。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008232324.png style="zoom:67%;" /></p>
<h3 id="多重哈希法"><a href="#多重哈希法" class="headerlink" title="多重哈希法"></a>多重哈希法</h3><h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a><em>再哈希法</em></h4><p><em><script type="math/tex">hash=H1(H1(key))</script></em><br><em>即当一次哈希函数的计算后发现地址重复，则再次将哈希值带入哈希函数进行计算，直到地址不再重复。此方法可以避免聚集，但计算量大，用时长。</em></p>
<h4 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a><em>建立公共溢出区</em></h4><p><em>即将重复地址的元素放置到溢出区中。</em></p>
<h3 id="再散列（rehashing）"><a href="#再散列（rehashing）" class="headerlink" title="再散列（rehashing）"></a>再散列（rehashing）</h3><p>顾名思义，当我们认为表的大小足够，不得不补充空间时，使用再散列。再散列将散列表的大小扩展为原大小的两倍以上的第一个素数。<br>有三种方法判断是否需要再散列。</p>
<ol>
<li><p>表到一半满（half full）时再散列</p>
</li>
<li><p>插入失败时在散列</p>
</li>
<li><p>增长因子到达一定值时再散列（推荐）（<strong>middle-of-the-road strategy</strong>）</p>
<h2 id="完美散列"><a href="#完美散列" class="headerlink" title="完美散列"></a><em>完美散列</em></h2><p><em>在分离链接法中，我们知道链表的数量越多，查找所需的时间越少。对于链表的个数M以及项数N,当$M＝N^2$时，最小有1/2的概率不会发生冲突，但直接使用这么多的链表不切实际，故使用完美散列，如下图</em><br><em><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008232415.png style="zoom:50%;" /></em></p>
</li>
</ol>
<p><em>每个单元格中的项数平方后的值为此单元格对应的链表数。这样既能保证较小概率冲突，又能减少链表的数量。</em></p>
<h3 id="杜鹃散列"><a href="#杜鹃散列" class="headerlink" title="杜鹃散列"></a><em>杜鹃散列</em></h3><p><em>在杜鹃散列中，我们维护两个散列表，每个都多于半空，再提供两个散列函数，每个函数都能访问到一个散列表。对于要插入的项，两个散列表各有一个对应的位置可供插入。</em></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><em>步骤</em></h4><p><em>两个散列表分别称之为A表和B表</em></p>
<ol>
<li><p><em>项先插入A表</em></p>
</li>
<li><p><em>若A表对应的是空，则插入；反之，依旧插入，但是原位置的项移动到表二的对应位置</em></p>
</li>
<li><p><em>若移入B表的位置也不为空，则依旧放置，原位置的项向A表寻找位置</em><br><em>如下：</em></p>
</li>
<li><em>插入A项</em><br> <em><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093135.png></em></li>
<li><em>插入B项</em><br> <em><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093159.png></em></li>
<li><em>插入CDE三项</em><br> <em><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093347.png></em><br><em>诸如上面</em><br><em><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093556.png></em><br><em>观察发现，六个项中，A表占了3个，B表占了3个，此杜鹃散列最多容纳6个项，若再尝试在（1，2）位置插入G，则会引发循环。</em><br><em>实现及使用时要把装填因子维持在0.5以下</em><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a><em>实现</em></h4><em>留待补充</em></li>
</ol>
<h3 id="跳房子散列"><a href="#跳房子散列" class="headerlink" title="跳房子散列"></a><em>跳房子散列</em></h3><p><em>跳房子散列维护一个散列表，表中有三个元素：<strong>散列值</strong>，<strong>项</strong>，<strong>HOP</strong></em><br><strong>*散列值</strong>：插入一个元素，首先就是要判断其散列值，散列值一致的即可插入<em><br>**</em>项<strong>：插入该单元的项的名称<em>
</em></strong>Hop<em>*： 跳房子散列给出了一个值MAX_DIST，它标志着一个表中的单元可探测的最大范围，即对于散列值重复的项，可以放置的最大个数。</em></p>
<p><em><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009235130.png style="zoom:67%;" /></em><br><em>在上图中，此值为4，故Hop格中有4个值，从左到右以依次表示本格，下一格，+2格，+3格的存放情况，为1，表示对应的单元格中存放了一个相同散列值的项</em><br><em><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009235936.png></em><br><em>现在尝试模拟此过程：</em></p>
<ol>
<li><p><em>插入项H，散列值为9。但9被占据，故尝试在其相邻的3格中寻找空位</em></p>
</li>
<li><p><em>找不到空位，考虑将这三格中的元素移到三格之外</em></p>
</li>
<li><p><em>对于10，存放的不是散列值为10的项，移动会破坏表（因为无法记录），放弃10.</em></p>
</li>
<li><p><em>对于11，存在一个放置在本格的项G，可以将他放置在最大值13处，并将Hop修改为0010</em></p>
</li>
<li><p><em>插入H，9的Hop更新为1010</em></p>
<h2 id="通用散列"><a href="#通用散列" class="headerlink" title="通用散列"></a><em>通用散列</em></h2><p><em>散列表的性质依赖于</em></p>
</li>
<li><em>散列函数必须常数时间可计算</em></li>
<li><em>散列函数必须均匀的分布项</em><h2 id="可扩散列"><a href="#可扩散列" class="headerlink" title="可扩散列"></a><em>可扩散列</em></h2><strong>*可扩散列</strong>（Extendible Hashing）是一种动态哈希表实现方法，特别适用于数据规模变化频繁的场景。它的设计目的是在保持哈希表高效的同时，能够自动扩展或收缩，从而减少重哈希（rehashing）的开销。<em>
</em>维护一个<strong>目录</strong>：存放项的前n值，当只有1项时，延申出两个块存放项；有n项时以$2^n$的二进制形式增加块<em><br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241010145549.png><br>如上，可扩散列还存在一个<em>*深度</em></em>：表示项中被用于区分的位的数目<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1>一台电脑面对许多个用户的访问时，会将这些访问放入队列，先发起访问的先使用计算机资源，但是我们希望他能够优先处理完资源较小的请求，因此，设计优先队列。<br>优先队列会弹出最小的请求，也能对加入的请求排序。<h2 id="二叉堆（Binary-Heaps）"><a href="#二叉堆（Binary-Heaps）" class="headerlink" title="二叉堆（Binary Heaps）"></a>二叉堆（Binary Heaps）</h2>堆是一颗完全填满的树，要实现其完全填满的特性，每次插入都要从左往右填满一行再去考虑下一行，如下图所示：</li>
</ol>
<p>这样实现的二叉堆完全可以实现使用数组表示，而非使用链表。</p>
<h3 id="堆序性质"><a href="#堆序性质" class="headerlink" title="堆序性质"></a>堆序性质</h3><ol>
<li>堆的最小元在根处，节点的值比两个子都要小</li>
<li>堆是完全二叉树<h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable&gt;<span class="comment">//一个可比较的变量模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryHeap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">BinaryHeap</span><span class="params">(<span class="type">int</span> capacity=<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">ecplicit <span class="title">BinaryHeap</span><span class="params">(<span class="type">const</span> vector&lt;Comparable&gt;&amp; items)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">const</span> Comparable&amp; <span class="title">findMin</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Comparable &amp;x)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Comparable &amp;&amp;x)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteMin</span><span class="params">(Comparable &amp; minItem)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> currentSize;<span class="comment">//当前已使用的空间</span></span><br><span class="line">	vector&lt;Comparable&gt; arry;<span class="comment">//存储的数组</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(<span class="type">int</span> hole)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当首索引为1时，有左右子的索引为n*2,n*2+1。。。</span></span><br><span class="line"><span class="comment">//当首索引为0时，有左右子的索引为n*2+1，n*2+2。。。</span></span><br></pre></td></tr></table></figure>
<h3 id="堆的操作-1"><a href="#堆的操作-1" class="headerlink" title="堆的操作"></a>堆的操作</h3><h4 id="插入-上滤-（insert）"><a href="#插入-上滤-（insert）" class="headerlink" title="插入(上滤)（insert）"></a>插入(上滤)（insert）</h4><p>时间 <code>O(log N)</code><br>将一个值插入二叉堆，则从最下一层寻找空位，然后以此空位向上寻找合适的位置，若值比插入的大，则交换，否则插入完成。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011223143.png><br><strong>上滤</strong>：将插入的值写入0位置，再把hole向上移动，最后写回hole的操作<br><strong>时间复杂度</strong>：最优O（1），最坏（logn+1），平均O（logn）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Comparable&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//此处的起始索引为0，但起始的存储索引为1，原本的计算规则不变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(currentSize==array.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">	array.<span class="built_in">resize</span>(array.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> hole=++currentsize;</span><br><span class="line">	Comparable copy=x;</span><br><span class="line">	</span><br><span class="line">	array[<span class="number">0</span>]=std::<span class="built_in">move</span>(copy);<span class="comment">//array[0]是空闲节点，无数据存储</span></span><br><span class="line">	<span class="keyword">for</span>(;x&lt;array[hole/<span class="number">2</span>];hole/=<span class="number">2</span>)<span class="comment">//找到父节点位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		array[hole]=std::<span class="built_in">move</span>(array[hole/<span class="number">2</span>]);<span class="comment">//替换</span></span><br><span class="line">	&#125;</span><br><span class="line">	array[hole]=std::<span class="built_in">move</span>(array[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除最小元（deleteMin）"><a href="#删除最小元（deleteMin）" class="headerlink" title="删除最小元（deleteMin）"></a>删除最小元（deleteMin）</h4><p>时间<code>O（logN）</code><br>将根节点置空，再将最后一个节点提取出来（用来填补被上移的空余）然后向下比对两个子，取最小的上移，直到到达最后一列<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011230657.png><br>这种方法也叫下滤(<strong>percolateDown</strong>),即将一个节点向下比较移动的过程。<br>为了方便记录，我们把删除最小节点和下滤分离<br><strong>删除最小节点</strong>：去除[1]位置的元素，把最后一位移到1的位置，同时currsize—<br><strong>下滤</strong>：根据传入的hole的位置，提取出其中的元素，向下找比他小的节点移动，否则停止，把之前提取出的元素写入现在hole的位置<br><strong>时间复杂度为：O（堆的深度）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteMin</span><span class="params">(Comparable &amp; minItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">isEmpty</span>())</span><br><span class="line">		<span class="keyword">throw</span> UnderflowException;</span><br><span class="line">	</span><br><span class="line">	minItem=std::<span class="built_in">move</span>(array[<span class="number">1</span>]);<span class="comment">//将最小值赋值到minItem上</span></span><br><span class="line">	array[<span class="number">1</span>]=std::<span class="built_in">move</span>(array[currentSize--])；</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">percolateDown</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(<span class="type">int</span> hole)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> child;<span class="comment">//下面的节点</span></span><br><span class="line">	Comparable tmp=std::<span class="built_in">move</span>(arryay[hole]);</span><br><span class="line">	<span class="keyword">for</span>(;hole*<span class="number">2</span>&lt;=currentSize;hole=child)</span><br><span class="line">	&#123;</span><br><span class="line">		child=hole*<span class="number">2</span>;<span class="comment">//左孩子</span></span><br><span class="line">		<span class="keyword">if</span>(child!=currentSize&amp;&amp;array[child+<span class="number">1</span>]&lt;array[child])</span><br><span class="line">		&#123;</span><br><span class="line">			++child;<span class="comment">//右孩子更小</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(array[child]&lt;tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			array[hole]=std::<span class="built_in">move</span>(array[child]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//到头了</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	array[hole]=std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="降低节点值（decreaseKey）"><a href="#降低节点值（decreaseKey）" class="headerlink" title="降低节点值（decreaseKey）"></a>降低节点值（decreaseKey）</h4><p><code>decreaseKey(p,k)</code>，对节点p的关键字降低K的绝对值，并上滤。</p>
<h4 id="增加节点值（increaseKey）"><a href="#增加节点值（increaseKey）" class="headerlink" title="增加节点值（increaseKey）"></a>增加节点值（increaseKey）</h4><p>同上</p>
<h4 id="删除（remove）"><a href="#删除（remove）" class="headerlink" title="删除（remove）"></a>删除（remove）</h4><p><code>remove(p)</code>，要将p删除，需要使用上滤将p（假设提前执行了decrease，节点值无穷小）移到根处，在执行deleteMin。</p>
<h4 id="buildHeap（构建堆）"><a href="#buildHeap（构建堆）" class="headerlink" title="buildHeap（构建堆）"></a>buildHeap（构建堆）</h4><p><strong>下滤</strong>操作从最后一个树叶的父节点递减开始<br>时间<code>平均O(N),最坏O(NlogN)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//假设数据已经填入数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=currentSize/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">percolateDown</span>(i);<span class="comment">//从非叶子节点层层下滤</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先使用完全树直接插入，在使用下滤排序</p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a><em>应用</em></h3><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><em>堆排序</em></h4><h4 id="事件模拟"><a href="#事件模拟" class="headerlink" title="事件模拟"></a><em>事件模拟</em></h4><h2 id="d堆"><a href="#d堆" class="headerlink" title="d堆"></a><em>d堆</em></h2><p><em>所有的节点都有d个儿子，在优先队列太大无法装进主存，就可以使用d堆，相当于b树。</em></p>
<h2 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a><em>左式堆</em></h2><p><em>堆难以实现find和<strong>合并</strong>(merge)，故使用左式堆。左式堆与二叉堆唯一的区别是不平衡，其左树深于右树。</em></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a><em>性质</em></h3><p><em>定义<strong>零路径长npl(X)</strong>,表示从X到一个不含有两个儿子的节点的最短路径长。</em><br><em>单节点的npl＝0；无节点的npl＝－1。</em></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a><em>操作</em></h3><p><em>其他操作与二叉树一致，这里讨论合并。</em><br><em>两个左式堆的合并，首先将A堆的右子树插入B堆（B堆的根节点大于A堆），再作为右子树插入A堆，最后为满足左式堆的性质，可能交换两个子树。</em></p>
<h2 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a><em>斜堆</em></h2><p><em>斜堆与左式堆的差别在于斜堆不对左右子树的深度做要求。</em><br><em>斜堆的主要操作也是合并</em></p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a><em>合并</em></h3><h2 id="二项队列（没讲）"><a href="#二项队列（没讲）" class="headerlink" title="二项队列（没讲）"></a><em>二项队列（没讲）</em></h2><p><em>二项队列的插入花费常数时间，其他操作花费<code>O(logN)</code></em></p>
<h3 id="二项队列的构建"><a href="#二项队列的构建" class="headerlink" title="二项队列的构建"></a><em>二项队列的构建</em></h3><p><em>二项队列由许多个二项树组成，分别由 $B_i$ 表示，其中，i也表示每个树的高度，i从0开始计。这些项数的集合称为<strong>森林</strong>。如下图所示：</em></p>
<p><em>每个二项树的节点数为 $2^i$ ,每个二项树的每个高度的节点数为 $C_{i}^{k},0&lt;=k&lt;=i$ 。</em></p>
<h3 id="二项队列操作"><a href="#二项队列操作" class="headerlink" title="二项队列操作"></a><em>二项队列操作</em></h3><h4 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a><em>插入</em></h4><p><em>二项队列的插入由合成大西瓜构成。先得到 $B_0$ （高度为0），随后插入一值得到 $B_1$ （高度为1）；再插入两个值，现在有两个 $B_1$ ，因此可以合成 $B_2$ ，诸如此类，如下图所示</em></p>
<p><em>其中，大小的比较仍然存在，相同高度的树的合并由下给出</em></p>
<h4 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a><em>合并</em></h4><p> <em>当两个树的高度相同时，二者就可以合并。合并时，取较小的根节点作为新的根节点，另一个树作为子节点插入新的根节点。合并是连锁的，可以（1+1）+2＝3。如下图：</em></p>
<h4 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a><em>删除最小值</em></h4><p><em>先寻找二项队列中最小的根，将对应的二项树从森林中删除，得到新的二项队列 $H’’$ ,然后，将此前的二项树的根节点删除，得到新的二项队列 $H’’$ ，我们对两个二项队列合并即可。</em></p>
<h3 id="二项队列实现"><a href="#二项队列实现" class="headerlink" title="二项队列实现"></a><em>二项队列实现</em></h3><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="排序的特征"><a href="#排序的特征" class="headerlink" title="排序的特征"></a>排序的特征</h2><h3 id="稳定（stability）"><a href="#稳定（stability）" class="headerlink" title="稳定（stability）"></a>稳定（stability）</h3><p>不会破坏相同元素的相对位置关系</p>
<h3 id="就地（in-place）"><a href="#就地（in-place）" class="headerlink" title="就地（in place）"></a>就地（in place）</h3><p>额外空间复杂度：1</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>稳定且就地的</strong><br>维护一个指针，用来遍历排序的数组，指针每移动一次，就把当前位置的数字一次向前比较，直到插入一个合适的位置，此方法保证此前的数据都是有效的。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E，<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;(Comp::<span class="built_in">prior</span>(A[j],A[j<span class="number">-1</span>]));j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(A,j,j<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>运行时间上界$O(N^2)$，下界$O(N)$，平均$O(N^2)$。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>稳定且就地</strong><br>双重循环，每次比较相邻的两值，若最小的循环内未发生交换，则排序成功。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function">voif <span class="title">bubsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Comp::<span class="built_in">prior</span>(A[j],A[j<span class="number">-1</span>]))</span><br><span class="line">			<span class="built_in">swap</span>(A,j,j<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>自下而上的排序，。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>运行时间上界$O(N^2)$，下界$O(N)$（未优化则为$O(N^2)$），平均$O(N^2)$。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>不稳定，就地</strong><br>从左到右遍历序列，找到最小值，放置在队首，再循环的找剩下队列的最小值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,typenmae Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> lowindex=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Comp::<span class="built_in">lt</span>(A[j],A[lowindex]))</span><br><span class="line">			lowindex=j</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(A,i,lowindex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不断开循环比较，最小的值放在前面，然后缩小范围继续。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>运行时间在任何情况下都是$O(N^2)$。</p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241204154507.png></p>
<h2 id="希尔排序（shell）"><a href="#希尔排序（shell）" class="headerlink" title="希尔排序（shell）"></a>希尔排序（shell）</h2><p><strong>不稳定但就地</strong><br>希尔排序使用一个<strong>增量序列（increment sequence）</strong> $h_k$，每次排序增量序列发生改变，保证$a[i]&lt;=a[i+h_k]$，由此逐渐使$h_k$递减，直到完成排序<br>大框架上看，希尔排序需要四个循环，一是遍历增量序列，二是序列下所有的子集，三是遍历子集中所有的起点，四是遍历所有起点往前的节点，其中三和四类似于插入排序</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inssort2</span><span class="params">(E A[],<span class="type">int</span> n,<span class="type">int</span> incr)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//插入排序部分</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=incr;i&lt;n;i+=incr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;(j&gt;=incr)&amp;&amp;(Comp::<span class="built_in">prior</span>(A[j],A[j-incr]));j-=incr)<span class="comment">//从后往前排序，只有能插入时循环</span></span><br><span class="line">		<span class="built_in">swap</span>(A,j,j-incr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">2</span>;i/=<span class="number">2</span>)<span class="comment">//选取增量序列</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)<span class="comment">//防止重复比较，限制范围</span></span><br><span class="line">		<span class="built_in">inssort2</span>&lt;E,Comp&gt;(&amp;A[j],n-j,i);<span class="comment">//&amp;a[j]表示截取数组，同时也代表步进</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">inssort2</span>&lt;E,comp&gt;(A,n,<span class="number">1</span>);<span class="comment">//回归第一个序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的取半的序列为希尔增量序列，事实上可能并不可靠。</p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><strong>运行时间</strong>上界：$O(N^2)$（使用希尔增量）；$O(N^{3/2})$（使用Hibbard增量序列：1，3，7…）；$O(N^{4/3})$（使用sedgewick：1，6，19，41….）<br>平均时间：$O(N^{5/4})$（使用Hibbard增量序列：1，3，7…）；$O(N^{7/6})$（使用sedgewick：1，6，19，41….）</p>
<h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>就地但不稳定</strong><br>对给出的序列构建<strong>MAX堆</strong>（大小选取与二叉堆相反），每次执行deletedMax，并把最大值放置在数组中因为下滤而空出的那一位中。由此得到的是由小到大的已排序的数组。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101144220.png></p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>运行时间上界$O(NlogN)$，平均$O(NlogN)$。</p>
<h2 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h2><p><strong>稳定但不就地</strong><br>归并排序递归的将序列分为前后一半，排序好后合并两个子序列，直到递归到最大的序列。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><h4 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h4><p><strong>对主函数Mergesort</strong>，递归的分解为小数组，在全部递归的组合<br><strong>对合并函数merge</strong>，先合并能合并的，未合并的也一定是已排序好的，直接写入（需要一个辅助数组帮助合并）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Mergesort</span>(A[],T[],<span class="type">int</span> left,<span class="type">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)<span class="comment">//递归</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Mergesort</span>(A,T,left,mid);</span><br><span class="line">		<span class="built_in">Mergesort</span>(A,T,mid+<span class="number">1</span>,right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Merge</span>(A,T,left,mid+<span class="number">1</span>,rigth);<span class="comment">//合并，左开始指针，右开始指针，右结束指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">( vector&lt;Comparable&gt; &amp; a, vector&lt;Comparable&gt; &amp; tmpArray,<span class="type">int</span> leftPos,<span class="type">int</span> rightPos,<span class="type">int</span> rightEnd)</span><span class="comment">//a为待排序的数组，tmpArray为临时数组，leftpos表示a的左侧起始位，rightpos表示a的右侧起始位，rightend表示右侧结束位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> leftEnd =rightPos <span class="number">-1</span>;<span class="comment">//左侧结束位</span></span><br><span class="line">	<span class="type">int</span> tmpPos =leftPos;<span class="comment">//填入临时数组的指针</span></span><br><span class="line">	<span class="type">int</span> numElements = rightEnd - leftPos + <span class="number">1</span>;<span class="comment">//写入临时数组的位数</span></span><br><span class="line">	<span class="comment">// Main loop</span></span><br><span class="line">	<span class="keyword">while</span>( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[ leftPos ]&lt;= a[ rightPos ])</span><br><span class="line">			tmpArray[ tmpPos++ ]=std::<span class="built_in">move</span>( a[ leftPos++ ]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmpArray[ tmpPos++ ]= std::<span class="built_in">move</span>( a[ rightPos++ ]);</span><br><span class="line">	&#125;<span class="comment">//取最小的放左边</span></span><br><span class="line">	<span class="keyword">while</span>( leftPos &lt;=leftEnd)<span class="comment">// copy rest of first half</span></span><br><span class="line">		tmpArray[ tmpPos++]=std::<span class="built_in">move</span>( a[ leftPos++ ]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>( rightPos &lt;=rightEnd)<span class="comment">// Copy rest of right half</span></span><br><span class="line">		tmpArray[ tmpPos++]=std::<span class="built_in">move</span>( a[ rightPos++ ]);</span><br><span class="line">		<span class="comment">//由于递归的限制，此后的数据是已经排序的，故直接填入</span></span><br><span class="line">	<span class="comment">// Copy tmpArray back</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>;i&lt;numElements; ++i,--rightEnd )</span><br><span class="line">		a[ rightEnd ]=std::<span class="built_in">move</span>( tmpArray[ rightEnd ]);</span><br><span class="line">		<span class="comment">//发挥临时数组的作用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h4><p>使用了小数组进行插入排序的方法，合并的最小单位增大，最后进行合并时使用一个数组的两端合并<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(E A[], E temp[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((right-left)&lt;=THRESHOLD)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">insertionsort</span>&lt;E,Comp&gt;(&amp;A[left], right-left+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="comment">//小数组使用插入排序，&amp;传入部分数组和对应长度</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">//开始合并</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i, j, k, mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(left== right)<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//老套路</span></span><br><span class="line">	<span class="built_in">mergesort</span>&lt;E, Comp&gt;(A, temp, left, mid);</span><br><span class="line">	<span class="built_in">mergesort</span>&lt;E, Comp&gt;(A, temp, mid+<span class="number">1</span>, right);<span class="comment">//Do the merge operation. First copy two halves to temp</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//两个部分最终插入排序</span></span><br><span class="line">	<span class="keyword">for</span> (i=mid; i&gt;=left; i--)</span><br><span class="line">	temp[i]= A[i];</span><br><span class="line">	<span class="comment">//一个数组暂时存储左边部分，方便合并</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=right-mid; j++)temp[right-j+<span class="number">1</span>]=A[j+mid];<span class="comment">//Merge sublists back to A</span></span><br><span class="line">	<span class="comment">//再倒叙存储右边部分</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=left, j=right, k=left;k&lt;=right; k++)</span><br><span class="line">	<span class="keyword">if</span> (Comp::<span class="built_in">prior</span>(temp[i],temp[j])) </span><br><span class="line">	A[k]= temp[i++];</span><br><span class="line">	<span class="keyword">else</span> A[k]= temp[j--];</span><br><span class="line">	<span class="comment">//j使用倒序，防止之后插入到原数组时i领先j</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>运行时间上界$O(NlogN)$。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>就地但不稳定</strong><br>包含4步：</p>
<ol>
<li>若S中的元素个数为0或1，则直接返回</li>
<li>取S中的任意元素v，称之为枢纽元</li>
<li>将S中小于等于v的和大于等于v的分为两个子集</li>
<li>返回对这两个子集的快速排序。<br>整体上看，我们只在分集合时进行了排序，且排序由小到大，每次得到枢纽元，以便于合并序列<h3 id="选取枢纽元（pivot）"><a href="#选取枢纽元（pivot）" class="headerlink" title="选取枢纽元（pivot）"></a>选取枢纽元（pivot）</h3><h4 id="三数中值"><a href="#三数中值" class="headerlink" title="三数中值"></a>三数中值</h4>取序列首，尾，中（向下取整）三个值的中间大小值作为枢纽元<h4 id="分割策略"><a href="#分割策略" class="headerlink" title="分割策略"></a>分割策略</h4>我们取出枢纽元后，将其与序列最后一位元素交换，随后，我们维护两个指针：i与j</li>
<li>i从序列左侧第一位出发，j从序列倒数第二位出发。i先向右比较，若比枢纽元大则停止；若比枢纽元小则向右走一位，直到停止。</li>
<li>当i停止时，j项向左走，遇到比枢纽元大的则继续向左走，直到停止；否则停止</li>
<li>当i与j都停止时，交换i与j对应的元素</li>
<li>当i与j交错，即i&gt;j时，分割完成，将i对应的元素与序列最后一个元素交换，即用枢纽元分割了整个序列。</li>
<li>此外，若i与j遇到了与枢纽元相等的元素，则停止<br>过程如下图：8 1 4 9 6 3 7 5 2 0，选取枢纽元后交换得8 1 4 9 0 3 5 2 7 6<br>假设输入序列为<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101144703.png><h4 id="小数组"><a href="#小数组" class="headerlink" title="小数组"></a>小数组</h4>当数组的大小较小时（一般n&lt;10左右）使用插入排序，此时用时比递归的快排更少。<h4 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h4>即查找序列中第k个最小元的问题<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5></li>
<li>输入数组s，若s的大小n＝1，则将其直接返回</li>
<li>选取一个枢纽元</li>
<li>将序列分为两部分，若前一个部分数组s1的大小n1&gt;=k，那么在s1中寻找第k个最小值</li>
<li>若k＝1+n1，则枢纽元恰好是第k个最小值</li>
<li>否则，在后一个部分数组s2中寻找第k个最小元</li>
</ol>
<h5 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(E A[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(j&lt;=i)<span class="keyword">return</span>;<span class="comment">//List with o or 1 element</span></span><br><span class="line">	<span class="type">int</span> pivotindex= <span class="built_in">findpivot</span>(A, i, j);<span class="comment">//get pivot</span></span><br><span class="line">	<span class="built_in">swap</span>(A, pivotindex, j); <span class="comment">//Put pivot at end</span></span><br><span class="line">	<span class="comment">//k will be the 1st position on right side</span></span><br><span class="line">	<span class="type">int</span> k= <span class="built_in">partition</span>&lt;E,Comp&gt;(A, i, j<span class="number">-1</span>, A[j]);<span class="comment">//给出i的值</span></span><br><span class="line">	<span class="built_in">swap</span>(A, k,j);<span class="comment">// Put pivot in place</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">quickSort</span>&lt;E,Comp&gt;(A, i, k<span class="number">-1</span>);<span class="comment">//Recursively</span></span><br><span class="line">	<span class="built_in">quickSort</span>&lt;E,Comp&gt;(A, k+<span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(E A[], <span class="type">int</span> l, <span class="type">int</span> r, E&amp; pivot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//Move the bounds inward until they meet</span></span><br><span class="line">		<span class="comment">//Move l right and r left</span></span><br><span class="line">		<span class="keyword">while</span> (Comp::<span class="built_in">prior</span>(A[++l], pivot));</span><br><span class="line">		<span class="keyword">while</span> ((l&lt;r)&amp;&amp; Comp::<span class="built_in">prior</span>(A[--r],pivot));</span><br><span class="line">		<span class="comment">//Swap out-of-place values</span></span><br><span class="line">		<span class="built_in">swap</span>(A, l, r);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;r);<span class="comment">// Stop when they cross</span></span><br><span class="line">	<span class="keyword">return</span> l;<span class="comment">//Return 1st position in right part</span></span><br></pre></td></tr></table></figure>
<p>最坏情况：$O(N^2)$，平均情况：$O(NlogN)$</p>
<h2 id="排序算法的一般下界-amp-选择问题的决策树下界"><a href="#排序算法的一般下界-amp-选择问题的决策树下界" class="headerlink" title="排序算法的一般下界&amp;选择问题的决策树下界"></a>排序算法的一般下界&amp;选择问题的决策树下界</h2><p>此节用决策树证明了只用排序的算法的下界是需要Ω(N log N)次比较。</p>
<h2 id="对手下界"><a href="#对手下界" class="headerlink" title="对手下界"></a>对手下界</h2><p>任何基于比较的查找最小元的算法都必然至少使用N－1次比较。<br>任何同时查找最小项和最大项的基于比较的算法，必然至少使用（3N/2）(取上界)-2次比较</p>
<h2 id="桶式排序和基数排序"><a href="#桶式排序和基数排序" class="headerlink" title="桶式排序和基数排序"></a>桶式排序和基数排序</h2><h3 id="桶式排序-Bucket-Sort"><a href="#桶式排序-Bucket-Sort" class="headerlink" title="桶式排序(Bucket Sort)"></a>桶式排序(Bucket Sort)</h3><p>使用一个大小至少比序列中最大值大的数组，每次读取序列中的值，就使<code>arry[list[i]]+1</code>，之后读取数组，按值的大小读取即可。</p>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">class</span> getKey&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nucketsort</span><span class="params">(E a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;E&gt; B[MaxKeyValue];</span><br><span class="line">	E item;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		B[getKey::<span class="built_in">key</span>(A[i])].<span class="built_in">append</span>(getKey::<span class="built_in">key</span>(A[i]));</span><br><span class="line">	&#125;<span class="comment">//排序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxKeyValue;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(B[i].<span class="built_in">setStart</span>();B[i].<span class="built_in">grtValue</span>(item);B[i].<span class="built_in">next</span>())</span><br><span class="line">		<span class="built_in">output</span>(item);</span><br><span class="line">	&#125;<span class="comment">//用于输出排序结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(N)</code></p>
<h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p>当序列的最大数过大，而使用数组太浪费空间时，可以使用基数排序，其也是桶式排序的一部分。一般用于对字符串的比较。<br>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241024160907.png><br>从个位数开始比较，最大值不超过9，根据位数使用对应次数的桶排序即可。<br>但当字符串的长度过长时，基数排序的优先度就不高了</p>
<h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><p>步骤：先按长度排序，在字符串从前到后，字符位数从后往前的排序，每次排序过后重新写入原数组<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(std::vector&lt;std::string&gt; &amp;arr, <span class="type">int</span> maxLen)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUCKETS = <span class="number">256</span>;<span class="comment">//桶大小</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="built_in">wordsByLength</span>(maxLen +<span class="number">1</span>);     </span><br><span class="line">    <span class="comment">//初始按长度先排序</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="built_in">buckets</span>(BUCKETS);</span><br><span class="line">    <span class="comment">//桶排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (std::string &amp;s : arr)</span><br><span class="line">        wordsByLength[s.<span class="built_in">length</span>()].<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">        <span class="comment">//按长度塞入数组</span></span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;wordList : wordsByLength)</span><br><span class="line">        <span class="keyword">for</span> (std::string &amp;s : wordList)</span><br><span class="line">            arr[idx++] = std::<span class="built_in">move</span>(s);</span><br><span class="line">            <span class="comment">//再写回原数组</span></span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> startingIndex = arr.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pos = maxLen - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; --pos) &#123;</span><br><span class="line">        startingIndex -= wordsByLength[pos + <span class="number">1</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//表示从对应长度区间的字符串开始排序</span></span><br><span class="line">        <span class="comment">//pos表示访问字符串的哪一位，字典序的判断应是自后到前的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startingIndex; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            buckets[arr[i][pos]].<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(arr[i]));</span><br><span class="line">            <span class="comment">//按pos指向的位进行桶排序</span></span><br><span class="line">		</span><br><span class="line">        </span><br><span class="line">        idx = startingIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thisBucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (std::string &amp;s : thisBucket)</span><br><span class="line">                arr[idx++] = std::<span class="built_in">move</span>(s);<span class="comment">//写回原数组</span></span><br><span class="line"></span><br><span class="line">            thisBucket.<span class="built_in">clear</span>();<span class="comment">//清空，准备下次桶排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此算法可以理解为，先对字符串按长度从小到大排序，再从最后一位向第一位以桶排序进行，若有位数小的，用空格补齐。<br>时间复杂度：<code>Ω(Nlog N)</code></p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>磁带等辅助存储设备无法直接寻址，此前的排序算法都是基于元素可直接访问的基础而设计的，故需要额外的外部排序算法对磁盘中的数据进行排序</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>在此算法中，我们使用归并排序的合并算法。<br>假设我们有四个磁带，$T_{a1},T_{a2},T_{b1},T_{b2}$，可分别表示输出或输入磁带，设数据最先存储在$T_{a1}$中，则：</p>
<ol>
<li>假设内存一次最多容纳和排序M个元素，我们每次从$T_{a1}$中取出M个元素，排序好后交替的放在$T_{b1},T_{b2}$中，如下图<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101144855.png></li>
<li>现在所有的元素都已经排序好了，于是进行合并，我们每次从$T_{b1},T_{b2}$中取出一组<strong>顺串（已排序的序列组）</strong>，合并且交替记录在$T_{a1},T_{a2}$中，直到$T_{b1},T_{b2}$中没有元素，如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101144940.png></li>
<li>再将$T_{a1},T_{a2}$中的一组顺串合并，交替的记录在$T_{b1},T_{b2}$中，如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101145000.png></li>
<li>最后一次合并，记录在$T_{a1}$中，如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101145013.png><br>在此算法中，合并是找两个数据的最小值，然后直接写入磁带，同时对应的输入磁带向前前进一位。</li>
</ol>
<p>平均时间：$log_2^{需要排序的趟数}$</p>
<h3 id="替换选择算法（replacement-selection-algorithm）"><a href="#替换选择算法（replacement-selection-algorithm）" class="headerlink" title="替换选择算法（replacement selection algorithm）"></a>替换选择算法（replacement selection algorithm）</h3><p>一次能排序的对的长度为内存的两倍<br>应用在初始排序，有数据成员LAST，表示队列最后一个已经排序的索引<br>步骤：</p>
<ol>
<li>弹出队列根的元素，产生空格</li>
<li>若插入的元素大于弹出的元素，就把插入的元素写入空格；反之把LAST的元素写入空格，把插入的元素写入LAST，LAST—；</li>
<li>对根节点下滤<h3 id="多路合并"><a href="#多路合并" class="headerlink" title="多路合并"></a>多路合并</h3>在简单算法中，我们受限于磁盘的数量，一次只在2个磁盘中交互的合并（2路合并），这会增加外部排序的时间，假设我们有多个磁盘用于排序，则引入<strong>k路合并</strong>。<br>我们使用优先队列来对磁盘指针指向的元素排序，每次使用<code>deleteMin</code>排出最小元素，写入输入磁盘后对应的输入磁盘前进。<br>假设我们现在使用<strong>3路合并</strong>：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101145041.png><br>平均时间：$log_k^{需要排序的趟数}$<h3 id="多相合并"><a href="#多相合并" class="headerlink" title="多相合并"></a>多相合并</h3>我们考虑使用更少的磁盘数，完成相同的工作，考虑使用三个磁带完成2路合并：<br>假设我们在磁盘$T_1$上存储34个输入顺串，使用斐波那契数列的倒叙方法，不平均的把34个顺串分配21个到$T_2$上，分配13个到$T_3$上，再合并到$T_1$上；每次合并保证有两个盘没空，彼此合并后得差，再合并，直到消为1。</li>
</ol>
<h1 id="不相交集类"><a href="#不相交集类" class="headerlink" title="不相交集类"></a>不相交集类</h1><p>本节研究将一个集合通过等价关系划分为交集为空集的几个子集间的各种快捷操作。这些子集称为<strong>等价类</strong>。对于集合中的元素，我们使用<code>find</code>寻找其类名（或是能唯一表示此等价类的属性），使用<code>union</code>将两个不在一个等价类中的元素合并到一个类中。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisjSets</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DisjSets</span><span class="params">( <span class="type">int</span> numElements )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">( <span class="type">int</span> x )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">( <span class="type">int</span> x )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">( <span class="type">int</span> root1, <span class="type">int</span> root2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">DisjSets::<span class="built_in">DisjSets</span>( <span class="type">int</span> numElements ) : s&#123; numElements, - <span class="number">1</span> &#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h2><p>自反的，对称的，可传递的<br>等价关系把集合划分为数个不同的子集。考虑关系a与b为同性，把人群划分为男女两个子集。</p>
<h2 id="联机（dynamic）-脱机"><a href="#联机（dynamic）-脱机" class="headerlink" title="联机（dynamic）/脱机"></a>联机（dynamic）/脱机</h2><p>联机表示<code>find</code>操作必须当场给出<br>脱机表示<code>find</code>操作在考虑全部的<code>union</code>操作后才能给出</p>
<h2 id="普通求并实现"><a href="#普通求并实现" class="headerlink" title="普通求并实现"></a>普通求并实现</h2><p>在这种实现中，我们使用<strong>森林</strong>的概念，每个元素起初都是一个单独的树。此外，我们维护一个数组，来存放每个元素的树的根。<br>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101145130.png></p>
<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>我们把一个元素的树的根作为子树加到另一个元素下，同时跟新数组中记录根信息的内容。<br>实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjSets::unionSets</span><span class="params">( <span class="type">int</span> root1, <span class="type">int</span> root2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[ root2 ] = root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h3><p>我们通过数组直接寻找其根信息，直到找到-1的节点，说明此元素可以直接表示一个等价类<br>实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjSets::find</span><span class="params">( <span class="type">int</span> x )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( s[ x ] &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>( s[ x ] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="灵巧求并算法"><a href="#灵巧求并算法" class="headerlink" title="灵巧求并算法"></a>灵巧求并算法</h2><h3 id="按大小求并"><a href="#按大小求并" class="headerlink" title="按大小求并"></a>按大小求并</h3><p>我们使用<strong>按大小求并</strong>的思想，合并时寻找两个树中大小较小的那个作为较大的树的子树。<br>大小表示数中节点的数目<br>如下图所示的合并操作：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101145153.png><br>维护的数组为：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101145354.png><br>其中，正数表示根，负数表示节点数</p>
<h3 id="按高度求并"><a href="#按高度求并" class="headerlink" title="按高度求并"></a>按高度求并</h3><p>我们使用<strong>按高度求并</strong>的思想，追踪每个树的高度而非大小，合并会使高度小的树成为高度大的子树。<br>例子结果与按大小求并一致，但数组不同：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101145548.png><br>负数为高度-1</p>
<h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><p>一般实现按高度求并的部分：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjSets::unionSets</span><span class="params">( <span class="type">int</span> root1, <span class="type">int</span> root2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( s[ root2 ] &lt; s[ root1 ] ) <span class="comment">// root2更深</span></span><br><span class="line">        s[ root1 ] = root2; <span class="comment">// root2为新根</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( s[ root1 ] == s[ root2 ] <span class="comment">//</span></span><br><span class="line">        --s[ root1 ];</span><br><span class="line">        s[ root2 ] = root1; <span class="comment">// 无论小于还是等于，root1为新根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>此前我们使用<code>find</code>时，都是递归的获取根的信息，但使用路径压缩后，我们将find的结果直接赋值到每次递归查找根节点的数组中，这样，可以使用原本的元素直接按数组查找到根值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjSets::find</span><span class="params">( <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( s[ x ] &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s[ x ] = <span class="built_in">find</span>( s[ x ] );<span class="comment">//使用=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以课本构建迷宫为例，每个单元表示集合的一个元素，随机的选取边拆除以连接两个元素对应的等价类，直到起点与终点对应的等价类被合并。<br>此外，若墙未拆除且两元素在一个等价类中，那么就不拆除此墙<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241103120616.png><br>考试中此类型的题离不开两点：</p>
<ol>
<li>集合的合并，能够将题目中的元素抽出以表示集合的概念</li>
<li>集合的连通，是合并之后联通，有此概念的一般使用并查集解决</li>
</ol>
<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol>
<li>一个图$G=(V,E)$由<strong>顶点（node/vertices）</strong> 集V 和 <strong>边(edge/arcs)集E</strong>构成，一对点对构成了一条边，有时也称为 <strong>弧</strong>。</li>
<li>边有方向的图称为<strong>有向图</strong>。</li>
<li>有的图的边会附带数值，称之为<strong>权(weight)</strong>。</li>
<li><strong>路径(path)</strong> 为图中的首尾相联的点序列，其 <strong>长</strong> 为路径上的边数，若有直接回到自身的路径${v,v}$，则称为<strong>环(loop)</strong>，简单路径指路径中无相同节点，除了首尾。</li>
<li>有向图中若有路径长度至少为1，且首尾节点一致的路径，则称为<strong>圈(circul)</strong>，若此路径是简单路径，则此圈也称为简单圈。若一个有向图无圈，则称为<strong>无圈的（DAG）</strong>。</li>
<li>在无向图中，圈要求路径互异，且长度至少为一。</li>
<li>有向图中，若每两个节点都有一条路径，则称此有向图是强联通的，若此有向图的无向图的每对节点都有路径，则称此无向图是弱连通的。</li>
<li>无向图中，若每对节点都有路径，则称为连通的</li>
<li>在有向图中每个顶点都有<strong>入度(deg-)</strong>（指向该点的边的对应边的数目）和<strong>出度(deg+)</strong>（此点指向其他点的边数目）。<br>注：弧指两个顶点之间的连线，路径则不局限于此<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><h4 id="邻接矩阵-adjacency-matrix"><a href="#邻接矩阵-adjacency-matrix" class="headerlink" title="邻接矩阵(adjacency matrix)"></a>邻接矩阵(adjacency matrix)</h4>对一个有n个节点的图，我们创建一个$n\times n$的矩阵，若两点之间有边，则其置为1，反之为0<br>对有向图来说，若有从a指向b的边，则在（a，b）中将值置为1。<br>有时也可以用其权值替代1。<br>若图是<strong>稠密的</strong>，则使用邻接矩阵更好</li>
</ol>
<h4 id="邻接表-adjacency-list"><a href="#邻接表-adjacency-list" class="headerlink" title="邻接表(adjacency list)"></a>邻接表(adjacency list)</h4><p>对图中的每个节点a，若有一条边使其与另一个顶点b相联，则将其放入表中a的邻接边中。<br>若在<strong>有向图</strong>中，由节点a指向其他节点的边加入a的邻接表</p>
<p>若图是<strong>稀疏的</strong>，则使用邻接表更合适。</p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>假设节点标签2byte，指针4byte，权值2byte<br>则：</p>
<ol>
<li>邻接矩阵需要$2V^2byte$</li>
<li>邻接表需要$4V+8Ebyte$（有向图），$4V+8*2E$byte（无向图）</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>一般使用first()获取对应节点的首个邻接元素，next(v’)获得节点v的邻接节点v’后的第一个节点</p>
<h5 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h5><h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><p>先是定义edge，包括了节点表示和边的权值，指针由模板类list实现；而后定义邻接表类，包括edge的二级指针，节点数，边数和访问状态数组<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class Edge </span><br><span class="line">&#123;</span><br><span class="line">	  <span class="type">int</span> vert;</span><br><span class="line">	  <span class="comment">//节点</span></span><br><span class="line">	  <span class="type">int</span> wt;  </span><br><span class="line">	  <span class="comment">//权值</span></span><br><span class="line">	</span><br><span class="line">Public:</span><br><span class="line">	  <span class="built_in">Edge</span>() &#123; vert = <span class="number">-1</span>; wt = <span class="number">-1</span>;  &#125;</span><br><span class="line">	  <span class="built_in">Edge</span>(<span class="type">int</span> v, <span class="type">int</span> w) &#123;vert = v, wt = w; &#125;</span><br><span class="line">	  </span><br><span class="line">	  <span class="function"><span class="type">int</span> <span class="title">vertex</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> vert; &#125;</span><br><span class="line">	  <span class="function"><span class="type">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> wt; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphl</span>: <span class="keyword">public</span> Graph</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	  List&lt;Edge&gt;** vertex; </span><br><span class="line">	  <span class="comment">//开二维指针</span></span><br><span class="line">	  <span class="type">int</span> numVertex, numEdge;</span><br><span class="line">	  <span class="comment">//表示节点和边的数量</span></span><br><span class="line">	  <span class="type">int</span> *mark;</span><br><span class="line">	  <span class="comment">//标志数组，表示此节点是否访问过</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    <span class="type">int</span> i;</span><br><span class="line">	    numVertex = n;  </span><br><span class="line">	    numEdge = <span class="number">0</span>;</span><br><span class="line">	    </span><br><span class="line">	    mark = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numVertex; i++) </span><br><span class="line">	    mark[i] = UNVISITED;</span><br><span class="line">	       </span><br><span class="line">	    vertex = (List&lt;Edge&gt;**) <span class="keyword">new</span> List&lt;Edge&gt;*[numVertex];</span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numVertex; i++)</span><br><span class="line">		vertex[i] = <span class="keyword">new</span> <span class="built_in">Llist</span>&lt;Edge&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">first</span><span class="params">(<span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">if</span> (vertex[v]-&gt;<span class="built_in">length</span>() == <span class="number">0</span>) <span class="comment">//return V’s Llist size</span></span><br><span class="line">	     <span class="keyword">return</span> numVertex;</span><br><span class="line">	     <span class="comment">//表示无此节点</span></span><br><span class="line">	     </span><br><span class="line">		vertex[v]-&gt;<span class="built_in">moveToStart</span>();</span><br><span class="line">		<span class="comment">//list的方法</span></span><br><span class="line">		Edge it = vertex[v]-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">		<span class="keyword">return</span> it.<span class="built_in">vertex</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="comment">//get v’s next neighbor after w</span></span><br><span class="line">		Edge it;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isEdge</span>(v, w))</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">if</span> ((vertex[v]-&gt;<span class="built_in">currPos</span>()+<span class="number">1</span>) &lt; vertex[v]-&gt;<span class="built_in">length</span>()) </span><br><span class="line">		    &#123;</span><br><span class="line">				vertex[v]-&gt;<span class="built_in">next</span>();</span><br><span class="line">		        it = vertex[v]-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">			    <span class="keyword">return</span> it.<span class="built_in">vertex</span>();</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">n</span>();  <span class="comment">//no neighbor</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	<span class="comment">//判断节点V1是否存在节点v2</span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">	  <span class="keyword">for</span>(vertex[v1]-&gt;<span class="built_in">moveToStart</span>(); vertex[v1]-&gt; <span class="built_in">currPos</span>() &lt; vertex[v1]-&gt;<span class="built_in">length</span>(); vertex[v1]-&gt;<span class="built_in">next</span>())</span><br><span class="line">	  &#123; </span><br><span class="line">        Edge it;</span><br><span class="line">        it = vertex[v1]-&gt;<span class="built_in">getValue</span>(); </span><br><span class="line">		<span class="keyword">if</span>(it.<span class="built_in">GetVertex</span>() == v2)    </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>同理，只有数组改变存储形态<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graphm</span>: <span class="keyword">public</span> Graph </span><br><span class="line">&#123;</span><br><span class="line">Private:</span><br><span class="line">	<span class="type">int</span> numVertex, numEdge; <span class="comment">//#vertices &amp; #edges</span></span><br><span class="line">	<span class="type">int</span> **matrix; 		<span class="comment">//Pointer to adjacency matrix</span></span><br><span class="line">	<span class="type">int</span> *mark;    		<span class="comment">//Pointer to mark array</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="comment">//Initialize the graph</span></span><br><span class="line">	    <span class="type">int</span> i;</span><br><span class="line">	    numVertex = n; </span><br><span class="line">	    numEdge = <span class="number">0</span>;</span><br><span class="line">	    mark = <span class="keyword">new</span> <span class="type">int</span>[n];	<span class="comment">//Initialize mark array</span></span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numVertex; i++) </span><br><span class="line">		  mark[i] = UNVISITED;</span><br><span class="line">    	</span><br><span class="line">	    matrix = (<span class="type">int</span>**) <span class="keyword">new</span> <span class="type">int</span>*[numVertex]; <span class="comment">//create</span></span><br><span class="line">		</span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numVertex; i++)</span><br><span class="line">        matrix[i] = <span class="keyword">new</span> <span class="type">int</span>[numVertex];</span><br><span class="line">		</span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numVertex; i++) <span class="comment">//Initial to 0 weights</span></span><br><span class="line">	      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;numVertex; j++)</span><br><span class="line">	        matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numVertex; &#125;	<span class="comment">//#vertices</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">e</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numEdge; &#125;	<span class="comment">//#edges</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">first</span><span class="params">(<span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;  <span class="comment">//return first neighbor of v</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numVertex; i++) </span><br><span class="line">			<span class="keyword">if</span> (matrix[v][i] != <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> numVertex; 	<span class="comment">// Not found</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> i=w+<span class="number">1</span>; i&lt;numVertex; i++)</span><br><span class="line">		<span class="keyword">if</span> (matrix[v][i] != <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">	  <span class="keyword">return</span> numVertex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>对<strong>有向无圈图</strong>，有<strong>拓扑排序</strong>：若一个点先于另一个点，则在图中我们把此点放置在前段。<br>如图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111230853.png><br>拓扑排序不唯一</p>
<h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><p>以queue为基础的实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(Graph* G, Queue&lt;<span class="type">int</span>&gt;* Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> InDgree[G-&gt;<span class="built_in">n</span>()];  </span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++) InDgree[v] = <span class="number">0</span>; <span class="comment">//初始化入度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++) </span><br><span class="line">         <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))<span class="comment">//邻接</span></span><br><span class="line">             InDgree [w]++;   <span class="comment">// 有一个入度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++) </span><br><span class="line">         <span class="keyword">if</span> (InDgree[v] == <span class="number">0</span>) </span><br><span class="line">              Q-&gt;<span class="built_in">enqueue</span>(v);<span class="comment">//入队</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (Q-&gt;<span class="built_in">length</span>() != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">         v = Q-&gt;<span class="built_in">dequeue</span>();<span class="comment">//出队</span></span><br><span class="line">         <span class="built_in">printout</span>(v);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w)) &#123;</span><br><span class="line">             InDgree[w]--; <span class="comment">//删除对应边</span></span><br><span class="line">             <span class="keyword">if</span> (InDgree[w] == <span class="number">0</span>) </span><br><span class="line">                 Q-&gt;<span class="built_in">enqueue</span>(w);<span class="comment">//入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用DFS思想的实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(Graph* G)</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) <span class="comment">// Initialize Mark</span></span><br><span class="line">        G-&gt;<span class="built_in">setMark</span>(i, UNVISITED);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) <span class="comment">// Process vertices</span></span><br><span class="line">        <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(i) == UNVISITED)</span><br><span class="line">            <span class="built_in">tophelp</span>(G, i);       <span class="comment">// Call helper</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tophelp</span><span class="params">(Graph* G, <span class="type">int</span> v)</span> </span>&#123; <span class="comment">// Process v</span></span><br><span class="line">    G-&gt;<span class="built_in">setMark</span>(v, VISITED);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">            <span class="built_in">tophelp</span>(G, w);</span><br><span class="line">  <span class="built_in">printout</span>(v);    <span class="comment">// output v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>打印出的即为拓扑排序的反序</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>保证每个节点不能走超过两次<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">graphTraverse</span><span class="params">(Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  <span class="type">int</span> v;</span><br><span class="line">	  <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++)</span><br><span class="line">	  &#123;</span><br><span class="line">	    G-&gt;<span class="built_in">setMark</span>(v, UNVISITED);</span><br><span class="line">	  &#125; <span class="comment">// Initialize </span></span><br><span class="line">	</span><br><span class="line">	  <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++)</span><br><span class="line">    <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(v) == UNVISITED)</span><br><span class="line">      <span class="built_in">doTraverse</span>(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="深度优先（DFS）"><a href="#深度优先（DFS）" class="headerlink" title="深度优先（DFS）"></a>深度优先（DFS）</h3><p>使用堆栈实现，从最深处向最浅处递归<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Main </span><br><span class="line">&#123;</span><br><span class="line">	i : integer <span class="comment">//int i</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span> M[i] := <span class="number">0</span>;  <span class="comment">//连接分量数组M，连接分量一致表示两个节点可以相联</span></span><br><span class="line">	label := <span class="number">1</span>;赋值</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> M[i] = <span class="number">0</span> then <span class="built_in">DFS</span>(G,M,i,label); <span class="comment">//若无记号，则去搜索</span></span><br><span class="line">  label := label + <span class="number">1</span>;                            <span class="comment">//寻找下一个节点群</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DFS</span>(G[]: node ptr array, M[]: <span class="type">int</span> array, i,label: <span class="type">int</span>) </span><br><span class="line">&#123;</span><br><span class="line">	  v : node pointer; <span class="comment">//节点指针</span></span><br><span class="line">	  M[i] := label;<span class="comment">//标记</span></span><br><span class="line">	  v := G[i];  <span class="comment">// i的第一个邻居</span></span><br><span class="line">	  <span class="keyword">while</span> v ！= null <span class="keyword">do</span>  <span class="comment">// 直到无i的未标记邻居</span></span><br><span class="line">    <span class="keyword">if</span> M[v.index] = <span class="number">0</span> then <span class="built_in">DFS</span>(G,M,v.index,label);<span class="comment">//递归</span></span><br><span class="line">    v := v.next;  <span class="comment">// 下一个邻居</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>假如此图有n个节点，m个边，则DFS的时间复杂度为<code>O(n+m)</code></p>
<h3 id="广度优先（BFS）"><a href="#广度优先（BFS）" class="headerlink" title="广度优先（BFS）"></a>广度优先（BFS）</h3><p>使用队列实现，从最浅处向最深处探索<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph* G, <span class="type">int</span> start, Queue&lt;<span class="type">int</span>&gt;*Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  <span class="type">int</span> v, w;</span><br><span class="line">	  Q-&gt;<span class="built_in">enqueue</span>(start);<span class="comment">//初始节点入栈</span></span><br><span class="line">	  G-&gt;<span class="built_in">setMark</span>(start, VISITED);<span class="comment">//标记</span></span><br><span class="line">	</span><br><span class="line">	  <span class="keyword">while</span> (Q-&gt;<span class="built_in">length</span>() != <span class="number">0</span>)<span class="comment">//无节点可以加入时</span></span><br><span class="line">	&#123;</span><br><span class="line">	    v = Q-&gt;<span class="built_in">dequeue</span>();<span class="comment">//出队列</span></span><br><span class="line">	    <span class="built_in">PreVisit</span>(G, v);<span class="comment">//留白</span></span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">for</span>(w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))<span class="comment">//依次找邻居</span></span><br><span class="line">	      <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">	    &#123;</span><br><span class="line">	        G-&gt;<span class="built_in">setMark</span>(w, VISITED);<span class="comment">//标记</span></span><br><span class="line">	        Q-&gt;<span class="built_in">enqueue</span>(w);<span class="comment">//入队</span></span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="无权最短路径"><a href="#无权最短路径" class="headerlink" title="无权最短路径"></a>无权最短路径</h3><p>此中情况中我们只需要研究如何找到边数最少的路径，显然我们可以给边赋权值1。<br>如下图所示:<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241112132008.png></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::unweighted</span><span class="params">(Vertexs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue&lt;Vertex&gt;q;<span class="comment">//队列</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> each Vertex v</span><br><span class="line">	v.dist= INFINITY;<span class="comment">//设置确定状态</span></span><br><span class="line">	</span><br><span class="line">	s.dist=<span class="number">0</span>;q.<span class="built_in">enqueue</span>( s);<span class="comment">//起点s入队</span></span><br><span class="line">	<span class="keyword">while</span>( !q.<span class="built_in">isEmpty</span>())<span class="comment">//直到没有办法加入顶点</span></span><br><span class="line">	&#123;</span><br><span class="line">		Vertexv=q.<span class="built_in">dequeue</span>();<span class="comment">//依次出队</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> each Vertex w adjacent to v<span class="comment">//邻接表</span></span><br><span class="line">		<span class="keyword">if</span>( w.dist==INFINITY)<span class="comment">//若此顶点没有确定过</span></span><br><span class="line">		&#123;</span><br><span class="line">			w.dist=v.dist+<span class="number">1</span>;<span class="comment">//从顶点开始按照距离每次+1</span></span><br><span class="line">			w.path =v;<span class="comment">//给出路径</span></span><br><span class="line">			q.<span class="built_in">enqueue</span>( w);<span class="comment">//邻接顶点w入队</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有权最短路径（无负值）（Dijkstra算法）"><a href="#有权最短路径（无负值）（Dijkstra算法）" class="headerlink" title="有权最短路径（无负值）（Dijkstra算法）"></a>有权最短路径（无负值）（Dijkstra算法）</h3><p>我们使用优先队列找到权值和最小的那个节点作为下一个确定的点，再为每个节点设置是否确定为最小路径的变量，其余的思路不变<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241112132113.png></p>
<p>实现一，复杂度$O(n^2)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(Graph* G, <span class="type">int</span>* D, <span class="type">int</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, v, w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++)</span><br><span class="line">	D[i] = INFINITY;<span class="comment">//距离无穷大</span></span><br><span class="line">	</span><br><span class="line">	D[s] = <span class="number">0</span>;<span class="comment">//起点</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) </span><br><span class="line">	&#123; </span><br><span class="line">	    v = <span class="built_in">minVertex</span>(G, D); <span class="comment">//寻找未标记的最短距离顶点</span></span><br><span class="line">	    <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>; <span class="comment">//但此点不与起点相连</span></span><br><span class="line">		</span><br><span class="line">		G-&gt;<span class="built_in">setMark</span>(v, VISITED);<span class="comment">//标记</span></span><br><span class="line">	    <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w = G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">	        <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">			 	<span class="keyword">if</span> (D[w] &gt; (D[v] + G-&gt;<span class="built_in">weight</span>(v, w)))</span><br><span class="line">	        		D[w] = D[v] + G-&gt;<span class="built_in">weight</span>(v, w);<span class="comment">//更新路径长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minVertex</span><span class="params">(Graph* G, <span class="type">int</span>* D)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, v = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(i) == UNVISITED)</span><br><span class="line">    &#123; </span><br><span class="line">        v = i; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125;<span class="comment">//找到一个对比对象即可</span></span><br><span class="line">    <span class="keyword">for</span> (i++; i&lt;G-&gt;<span class="built_in">n</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> ((G-&gt;<span class="built_in">getMark</span>(i) == UNVISITED) &amp;&amp; (D[i] &lt; D[v]))<span class="comment">//在未标记的节点中找距离比v小的</span></span><br><span class="line">	      v = i;<span class="comment">//替换</span></span><br><span class="line">      </span><br><span class="line">	<span class="keyword">return</span> v;</span><br></pre></td></tr></table></figure></p>
<p>实现二：使用最小堆找出最小元素，复杂度$O((|V|+|E|)log|E|)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class DijkElem</span><br><span class="line">&#123;</span><br><span class="line">	Public:</span><br><span class="line">		<span class="type">int</span> vertex, distance;</span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">DijkElem</span>() &#123;vertex = <span class="number">-1</span>; distance = <span class="number">-1</span>;&#125;</span><br><span class="line">	<span class="built_in">DijkElem</span>(<span class="type">int</span> v, <span class="type">int</span> d) &#123;vertex = v; distance = d&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(Graph* G, <span class="type">int</span>* D, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, v, w;</span><br><span class="line">    DijkElem temp;  </span><br><span class="line">    DijkElem E[G-&gt;<span class="built_in">e</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++)</span><br><span class="line">       D[i] = INFINITY;<span class="comment">//距离无穷大</span></span><br><span class="line">    D[s] = <span class="number">0</span>;<span class="comment">//起始节点</span></span><br><span class="line">    </span><br><span class="line">    temp.distance = <span class="number">0</span>; </span><br><span class="line">    temp.vertex = s; </span><br><span class="line">    E[<span class="number">0</span>] = temp;     </span><br><span class="line">    <span class="function">heap&lt;DijkElem, DDComp&gt; <span class="title">H</span><span class="params">(E, <span class="number">1</span>, G-&gt;e())</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span>(H.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 为空</span></span><br><span class="line">            temp = H.<span class="built_in">removefirst</span>(); <span class="comment">//deletemin</span></span><br><span class="line">		    v = temp.vertex;</span><br><span class="line">        &#125; <span class="keyword">while</span> (G-&gt;<span class="built_in">getMark</span>(v) == VISITED);<span class="comment">//找到值最小的未标记顶点</span></span><br><span class="line"></span><br><span class="line">        G-&gt;<span class="built_in">setMark</span>(v, VISITED);  <span class="comment">//标记</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>; <span class="comment">//不相连顶点</span></span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">            <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)<span class="comment">//未标记的邻接</span></span><br><span class="line">               <span class="keyword">if</span> (D[w] &gt; (D[v] + G-&gt;<span class="built_in">weight</span>(v, w))) &#123;    </span><br><span class="line">                  D[w] = D[v] + G-&gt;<span class="built_in">weight</span>(v, w);</span><br><span class="line">                  temp.distance = D[w]; temp.vertex = w;</span><br><span class="line">                 <span class="comment">// Insert new distance in heap</span></span><br><span class="line">                  H.<span class="built_in">insert</span>(temp); </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//此循环用于更新邻接顶点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="具有负值的图"><a href="#具有负值的图" class="headerlink" title="具有负值的图"></a>具有负值的图</h3><p>若图的权值可为负，则以上的两种算法不再适用，我们结合前两种算法得出新解：<br>不标记节点的记录状态，循环将一直继续<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::weightedNegative</span><span class="params">( Vertexs</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	Queue&lt;Vertex&gt; q;</span></span></span><br><span class="line"><span class="params"><span class="function">	</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">for</span> each Vertex v</span></span></span><br><span class="line"><span class="params"><span class="function">		v.dist =INFINITY;</span></span></span><br><span class="line"><span class="params"><span class="function">	s.dist =<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	q.enqueue(s);</span></span></span><br><span class="line"><span class="params"><span class="function">	</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">while</span>( !q.isEmpty())</span></span></span><br><span class="line"><span class="params"><span class="function">	&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		Vertexv=q.dequeue();</span></span></span><br><span class="line"><span class="params"><span class="function">		</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> each Vertex w adjacent to y</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">if</span>( v.dist + cvw&lt;w.dist )</span></span></span><br><span class="line"><span class="params"><span class="function">		&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			w.dist=v.dist+cvw;</span></span></span><br><span class="line"><span class="params"><span class="function">			w.path=v;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">if</span>( wis <span class="keyword">not</span> already in g)q.enqueue( w);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="无圈图-貌似不考"><a href="#无圈图-貌似不考" class="headerlink" title="无圈图(貌似不考)"></a>无圈图(貌似不考)</h3><p>若已知图是无圈的，则可以再改进Dijkstra算法，无圈图一般应用再方向唯一的情景中，如滑雪只能向下，自发的化学反应只能释放能量</p>
<h4 id="关键路径分析法"><a href="#关键路径分析法" class="headerlink" title="关键路径分析法"></a>关键路径分析法</h4><p>我们将事件与其需要的时间排列为一张图，此图必须是无圈（因为后置任务不能提前完成）。</p>
<h4 id="时间节点图"><a href="#时间节点图" class="headerlink" title="时间节点图"></a>时间节点图</h4><p>我们对关键路径分析中得到的图转化为时间节点图，此图可用来规划并行任务的执行时间等（规定若两个事件没有直接或间接相联就可以并行）</p>
<h5 id="最早完成时间"><a href="#最早完成时间" class="headerlink" title="最早完成时间"></a>最早完成时间</h5><p>我们计算每个任务完成（包括此任务的先决任务）的最短时间，即每个任务间没有缓冲时间</p>
<h5 id="最晚完成时间"><a href="#最晚完成时间" class="headerlink" title="最晚完成时间"></a>最晚完成时间</h5><p>我们计算不影响最早完成时间下的每个事件都能完成的情况，即我们对每个节点尽可能的留出缓冲时间</p>
<h5 id="缓冲时间"><a href="#缓冲时间" class="headerlink" title="缓冲时间"></a>缓冲时间</h5><p>我们计算为了最短时间完成任务，每个任务可以留出的缓冲时间</p>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>需要削减图的边数或增加边数，使得原无向图有边数=节点数-1</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>使用在无向图上，类似于<strong>最短路径</strong>的算法，只在画边上有不同，边长度不再累加，二而是直接取边权。<br>需要考虑第一个节点的选择是否是随机的，最后的结果唯一（若无权值相同的边）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(Graph* G, <span class="type">int</span>* D, <span class="type">int</span> s)</span> <span class="comment">//s是起始点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="type">int</span> V[G-&gt;<span class="built_in">n</span>()];  <span class="comment">// store lowest cost vertex</span></span><br><span class="line">	 <span class="type">int</span> i, w;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) <span class="comment">// Initialize</span></span><br><span class="line">	    D[i] = INFINITY; <span class="comment">// cost</span></span><br><span class="line">	 D[s] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	 <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) &#123; </span><br><span class="line">	    <span class="type">int</span> v = <span class="built_in">minVertex</span>(G, D);</span><br><span class="line">	    G-&gt;<span class="built_in">setMark</span>(v, VISITED);</span><br><span class="line">		</span><br><span class="line">	    <span class="keyword">if</span> (v != s) </span><br><span class="line">	      <span class="built_in">AddEdgetoMST</span>(V[v], v); <span class="comment">//把前置节点和当前节点的边接入MST</span></span><br><span class="line">	    <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>; <span class="comment">//unreachable vertices</span></span><br><span class="line">	  </span><br><span class="line">	    <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">	     <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">	      <span class="keyword">if</span> (D[w] &gt; G-&gt;<span class="built_in">weight</span>(v,w)) &#123;</span><br><span class="line">	         D[w] = G-&gt;<span class="built_in">weight</span>(v,w); <span class="comment">//Update cost</span></span><br><span class="line">	         V[w] = v; <span class="comment">// 更新前置节点</span></span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>使用并查集的方法，枚举每个最小的边，在不出现圈的情况下加入此边，否则放弃且不在考虑<br>除非有权值相同的边，否则结果唯一<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">kruskal</span><span class="params">( vector&lt;Edge&gt; edges, <span class="type">int</span> numVertices )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisjSets ds&#123; numVertices &#125;;</span><br><span class="line">    priority_queue pq&#123; edges &#125;;<span class="comment">//优先队列</span></span><br><span class="line">    vector&lt;Edge&gt; mst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( mst.<span class="built_in">size</span>( ) != numVertices - <span class="number">1</span> )<span class="comment">//树的边数总比其节点数少1</span></span><br><span class="line">    &#123;</span><br><span class="line">        Edge e = pq.<span class="built_in">pop</span>( ); <span class="comment">// Edge e = (u, v)</span></span><br><span class="line">        SetType uset = ds.<span class="built_in">find</span>( e.<span class="built_in">getu</span>( ) );</span><br><span class="line">        SetType vset = ds.<span class="built_in">find</span>( e.<span class="built_in">getv</span>( ) );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( uset != vset )两集合不相等</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Accept the edge</span></span><br><span class="line">            mst.<span class="built_in">push_back</span>( e );</span><br><span class="line">            ds.<span class="built_in">union</span>( uset, vset );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.lafael.top">surtr lafael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lafael.top/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://www.lafael.top/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lafael.top" target="_blank">Hephaestus</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E5%86%85%E5%9F%BA%E7%A1%80/">课内基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/78170818.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><img class="cover" src="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/43cb6326cebfed66.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机组成原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><img class="cover" src="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/43cb6326cebfed66.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-03</div><div class="title">计算机组成原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">surtr lafael</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lafaeier"><i class="fab fa-github"></i><span>今四,50,喜奔。</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lafaeier" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hamiltonlafael@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">(阴暗的爬行)陆地,太过干燥,无鳞,离群的同胞,我呼唤你,带你归巢(嘶吼)。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">前情提要</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">算数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">证明方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%80%E8%AE%BA"><span class="toc-number">1.3.</span> <span class="toc-text">递归简论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c"><span class="toc-number">1.4.</span> <span class="toc-text">c++</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%85%AC%E5%BC%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">部分公式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">表，栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88ADT%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">抽象数据类型（ADT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">表（List）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">List的数组实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">List的链表实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.</span> <span class="toc-text">vector的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88ADT"><span class="toc-number">3.6.</span> <span class="toc-text">栈ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">栈的链表实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88-stack-%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.2.</span> <span class="toc-text">栈(stack)的数组实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A0%88%EF%BC%89"><span class="toc-number">3.6.3.</span> <span class="toc-text">中序遍历的实现（栈）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97-queue"><span class="toc-number">3.7.</span> <span class="toc-text">队列(queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-loop-circule-%EF%BC%89"><span class="toc-number">3.7.1.</span> <span class="toc-text">队列的数组实现（循环队列(loop circule)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">3.7.2.</span> <span class="toc-text">队列的链表实现（非循环队列）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">树的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.</span> <span class="toc-text">树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-preorder-%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">先序遍历(preorder)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-inorder-%EF%BC%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">中序遍历(inorder)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86-postorder-%EF%BC%9A"><span class="toc-number">4.2.3.</span> <span class="toc-text">后续遍历(postorder)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.4.</span> <span class="toc-text">遍历实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-tree"><span class="toc-number">4.3.</span> <span class="toc-text">二叉树(Binary tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.3.1.</span> <span class="toc-text">二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">表达式树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-1"><span class="toc-number">4.4.</span> <span class="toc-text">二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">AVL（注）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">4.5.1.</span> <span class="toc-text">旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%97%8B"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">单旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%97%8B"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">双旋</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6"><span class="toc-number">4.5.2.</span> <span class="toc-text">高度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">4.5.3.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1"><span class="toc-number">4.5.4.</span> <span class="toc-text">平衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">4.5.5.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%B8%E5%B1%95%E6%A0%91-spread-tree"><span class="toc-number">4.6.</span> <span class="toc-text">伸展树(spread tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-number">4.6.1.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E5%BC%80"><span class="toc-number">4.6.2.</span> <span class="toc-text">展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-number">4.6.3.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-number">4.6.4.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">4.7.</span> <span class="toc-text">B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.7.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">4.7.2.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-number">4.7.3.</span> <span class="toc-text">B-树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B%E8%AE%B2%E8%A7%A3%EF%BC%9A"><span class="toc-number">4.7.3.1.1.</span> <span class="toc-text">查找过程讲解：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">4.7.3.1.2.</span> <span class="toc-text">B-树查找的核心思想</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B%E8%AE%B2%E8%A7%A3"><span class="toc-number">4.7.3.2.1.</span> <span class="toc-text">插入过程讲解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">4.7.3.2.2.</span> <span class="toc-text">插入的核心思想</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-number">4.7.3.3.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.7.3.3.1.</span> <span class="toc-text">B-树删除操作的过程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E4%B8%8Emap"><span class="toc-number">4.8.</span> <span class="toc-text">set与map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8Emap%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.1.</span> <span class="toc-text">set的实现与map的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%A3%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">散列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">5.1.</span> <span class="toc-text">搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">为什么不使用数组？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">散列表（哈希表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%EF%BC%88collision%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">碰撞（collision）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.2.</span> <span class="toc-text">构造散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">直接定址法（注）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E5%88%86%E5%8F%96%E4%B8%AD%E6%B3%95%EF%BC%88mid-square%EF%BC%89%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">平分取中法（mid-square）（注）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">数字分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8F%A0%E6%B3%95"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">折叠法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%80%BC"><span class="toc-number">5.4.2.5.</span> <span class="toc-text">随机值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">5.4.2.6.</span> <span class="toc-text">除留余数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%8E%BB%E6%B3%95"><span class="toc-number">5.4.2.7.</span> <span class="toc-text">减去法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%B3%95"><span class="toc-number">5.4.2.8.</span> <span class="toc-text">基数转换法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%80%BC%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">5.4.2.9.</span> <span class="toc-text">字符串数值哈希法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%EF%BC%88%E7%A2%B0%E6%92%9E%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">处理冲突（碰撞）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86"><span class="toc-number">5.5.1.</span> <span class="toc-text">聚集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90"><span class="toc-number">5.5.2.</span> <span class="toc-text">装填因子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="toc-number">5.5.2.1.1.</span> <span class="toc-text">线性探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">5.5.2.1.2.</span> <span class="toc-text">平方探测（注）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E5%93%88%E5%B8%8C"><span class="toc-number">5.5.2.1.3.</span> <span class="toc-text">双重哈希</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E6%95%A3%E5%88%97%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">5.5.2.1.4.</span> <span class="toc-text">双散列（注）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">5.5.3.</span> <span class="toc-text">链地址法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="toc-number">5.5.3.1.</span> <span class="toc-text">链接列表分开存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%A4%B4%E5%8D%95%E5%85%83%E6%A0%BC%E5%88%86%E5%BC%80%E9%93%BE%E6%8E%A5"><span class="toc-number">5.5.3.2.</span> <span class="toc-text">列表头单元格分开链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">5.5.3.3.</span> <span class="toc-text">分离链接法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">5.5.4.</span> <span class="toc-text">多重哈希法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">再哈希法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="toc-number">5.5.4.2.</span> <span class="toc-text">建立公共溢出区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%95%A3%E5%88%97%EF%BC%88rehashing%EF%BC%89"><span class="toc-number">5.5.5.</span> <span class="toc-text">再散列（rehashing）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97"><span class="toc-number">5.6.</span> <span class="toc-text">完美散列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%9C%E9%B9%83%E6%95%A3%E5%88%97"><span class="toc-number">5.6.1.</span> <span class="toc-text">杜鹃散列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E6%88%BF%E5%AD%90%E6%95%A3%E5%88%97"><span class="toc-number">5.6.2.</span> <span class="toc-text">跳房子散列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%95%A3%E5%88%97"><span class="toc-number">5.7.</span> <span class="toc-text">通用散列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E6%95%A3%E5%88%97"><span class="toc-number">5.8.</span> <span class="toc-text">可扩散列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86%EF%BC%88Binary-Heaps%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">二叉堆（Binary Heaps）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%BA%8F%E6%80%A7%E8%B4%A8"><span class="toc-number">6.1.1.</span> <span class="toc-text">堆序性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.1.2.</span> <span class="toc-text">堆的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C-1"><span class="toc-number">6.1.3.</span> <span class="toc-text">堆的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-%E4%B8%8A%E6%BB%A4-%EF%BC%88insert%EF%BC%89"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">插入(上滤)（insert）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%85%83%EF%BC%88deleteMin%EF%BC%89"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">删除最小元（deleteMin）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E8%8A%82%E7%82%B9%E5%80%BC%EF%BC%88decreaseKey%EF%BC%89"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">降低节点值（decreaseKey）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9%E5%80%BC%EF%BC%88increaseKey%EF%BC%89"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">增加节点值（increaseKey）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%EF%BC%88remove%EF%BC%89"><span class="toc-number">6.1.3.5.</span> <span class="toc-text">删除（remove）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buildHeap%EF%BC%88%E6%9E%84%E5%BB%BA%E5%A0%86%EF%BC%89"><span class="toc-number">6.1.3.6.</span> <span class="toc-text">buildHeap（构建堆）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">6.1.4.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">事件模拟</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d%E5%A0%86"><span class="toc-number">6.2.</span> <span class="toc-text">d堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%BC%8F%E5%A0%86"><span class="toc-number">6.3.</span> <span class="toc-text">左式堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.2.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%9C%E5%A0%86"><span class="toc-number">6.4.</span> <span class="toc-text">斜堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-number">6.4.1.</span> <span class="toc-text">合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97%EF%BC%88%E6%B2%A1%E8%AE%B2%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">二项队列（没讲）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">6.5.1.</span> <span class="toc-text">二项队列的构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.2.</span> <span class="toc-text">二项队列操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-3"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6-1"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">删除最小值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.5.3.</span> <span class="toc-text">二项队列实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">7.1.</span> <span class="toc-text">排序的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%EF%BC%88stability%EF%BC%89"><span class="toc-number">7.1.1.</span> <span class="toc-text">稳定（stability）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%B1%E5%9C%B0%EF%BC%88in-place%EF%BC%89"><span class="toc-number">7.1.2.</span> <span class="toc-text">就地（in place）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">7.2.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">7.2.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">7.3.1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">7.4.1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88shell%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">希尔排序（shell）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">7.5.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-3"><span class="toc-number">7.5.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-1"><span class="toc-number">7.6.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-4"><span class="toc-number">7.6.1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88merge-sort%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">归并排序（merge sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">7.7.1.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80"><span class="toc-number">7.7.1.1.</span> <span class="toc-text">实现一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%8C"><span class="toc-number">7.7.1.2.</span> <span class="toc-text">实现二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-5"><span class="toc-number">7.7.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.8.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E5%8F%96%E6%9E%A2%E7%BA%BD%E5%85%83%EF%BC%88pivot%EF%BC%89"><span class="toc-number">7.8.1.</span> <span class="toc-text">选取枢纽元（pivot）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B8%AD%E5%80%BC"><span class="toc-number">7.8.1.1.</span> <span class="toc-text">三数中值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%96%E7%95%A5"><span class="toc-number">7.8.1.2.</span> <span class="toc-text">分割策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E7%BB%84"><span class="toc-number">7.8.1.3.</span> <span class="toc-text">小数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-number">7.8.1.4.</span> <span class="toc-text">快速选择</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">7.8.1.4.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">7.8.1.4.2.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E4%B8%8B%E7%95%8C-amp-%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8B%E7%95%8C"><span class="toc-number">7.9.</span> <span class="toc-text">排序算法的一般下界&amp;选择问题的决策树下界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%89%8B%E4%B8%8B%E7%95%8C"><span class="toc-number">7.10.</span> <span class="toc-text">对手下界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E5%BC%8F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">7.11.</span> <span class="toc-text">桶式排序和基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%B6%E5%BC%8F%E6%8E%92%E5%BA%8F-Bucket-Sort"><span class="toc-number">7.11.1.</span> <span class="toc-text">桶式排序(Bucket Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">7.11.1.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89"><span class="toc-number">7.11.2.</span> <span class="toc-text">基数排序（Radix Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">7.11.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">7.12.</span> <span class="toc-text">外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95"><span class="toc-number">7.12.1.</span> <span class="toc-text">简单算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%EF%BC%88replacement-selection-algorithm%EF%BC%89"><span class="toc-number">7.12.2.</span> <span class="toc-text">替换选择算法（replacement selection algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%90%88%E5%B9%B6"><span class="toc-number">7.12.3.</span> <span class="toc-text">多路合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%9B%B8%E5%90%88%E5%B9%B6"><span class="toc-number">7.12.4.</span> <span class="toc-text">多相合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">不相交集类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.</span> <span class="toc-text">等价关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E6%9C%BA%EF%BC%88dynamic%EF%BC%89-%E8%84%B1%E6%9C%BA"><span class="toc-number">8.2.</span> <span class="toc-text">联机（dynamic）&#x2F;脱机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%B1%82%E5%B9%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">普通求并实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#union"><span class="toc-number">8.3.1.</span> <span class="toc-text">union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">find</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B5%E5%B7%A7%E6%B1%82%E5%B9%B6%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">灵巧求并算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%A4%A7%E5%B0%8F%E6%B1%82%E5%B9%B6"><span class="toc-number">8.4.1.</span> <span class="toc-text">按大小求并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%AB%98%E5%BA%A6%E6%B1%82%E5%B9%B6"><span class="toc-number">8.4.2.</span> <span class="toc-text">按高度求并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">8.4.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">8.5.</span> <span class="toc-text">路径压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">8.6.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">图论算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">9.1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">9.1.1.</span> <span class="toc-text">图的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-adjacency-matrix"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">邻接矩阵(adjacency matrix)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-adjacency-list"><span class="toc-number">9.1.1.2.</span> <span class="toc-text">邻接表(adjacency list)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">9.1.1.3.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.1.4.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">9.1.1.4.1.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">9.1.1.4.1.1.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">9.1.1.4.1.2.</span> <span class="toc-text">邻接矩阵</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-10"><span class="toc-number">9.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">9.3.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E6%8F%90"><span class="toc-number">9.3.1.</span> <span class="toc-text">前提</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%88DFS%EF%BC%89"><span class="toc-number">9.3.2.</span> <span class="toc-text">深度优先（DFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%88BFS%EF%BC%89"><span class="toc-number">9.3.3.</span> <span class="toc-text">广度优先（BFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">9.4.1.</span> <span class="toc-text">无权最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E6%97%A0%E8%B4%9F%E5%80%BC%EF%BC%89%EF%BC%88Dijkstra%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">9.4.2.</span> <span class="toc-text">有权最短路径（无负值）（Dijkstra算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E8%B4%9F%E5%80%BC%E7%9A%84%E5%9B%BE"><span class="toc-number">9.4.3.</span> <span class="toc-text">具有负值的图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%9C%88%E5%9B%BE-%E8%B2%8C%E4%BC%BC%E4%B8%8D%E8%80%83"><span class="toc-number">9.4.4.</span> <span class="toc-text">无圈图(貌似不考)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">9.4.4.1.</span> <span class="toc-text">关键路径分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%8A%82%E7%82%B9%E5%9B%BE"><span class="toc-number">9.4.4.2.</span> <span class="toc-text">时间节点图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E6%97%A9%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4"><span class="toc-number">9.4.4.2.1.</span> <span class="toc-text">最早完成时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E6%99%9A%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4"><span class="toc-number">9.4.4.2.2.</span> <span class="toc-text">最晚完成时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%97%B6%E9%97%B4"><span class="toc-number">9.4.4.2.3.</span> <span class="toc-text">缓冲时间</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">9.5.</span> <span class="toc-text">生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">9.6.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">9.6.1.</span> <span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">9.6.2.</span> <span class="toc-text">Kruskal算法</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By surtr lafael</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Ding Zhen and his animal friends are watching you</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/sakura.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>