<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机组成原理 | Hephaestus</title><meta name="author" content="surtr lafael"><meta name="copyright" content="surtr lafael"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机的基本结构计算机的类型嵌入式计算机（embedded computer）：专门为单个功能设计的计算机，集成于各种家电，交通工具等，集成（integrated） 个人计算机（Pc）：以个人为单位的计算机，支持使用各种软件，主要用于个人用途。在此之下还有台式计算机（desktop computer）和工作站计算机（workstation computer），后者专为工程而生，具有强大的计算和图">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="https://www.lafael.top/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hephaestus">
<meta property="og:description" content="计算机的基本结构计算机的类型嵌入式计算机（embedded computer）：专门为单个功能设计的计算机，集成于各种家电，交通工具等，集成（integrated） 个人计算机（Pc）：以个人为单位的计算机，支持使用各种软件，主要用于个人用途。在此之下还有台式计算机（desktop computer）和工作站计算机（workstation computer），后者专为工程而生，具有强大的计算和图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/43cb6326cebfed66.jpg">
<meta property="article:published_time" content="2024-11-02T16:24:08.000Z">
<meta property="article:modified_time" content="2024-12-20T14:12:08.800Z">
<meta property="article:author" content="surtr lafael">
<meta property="article:tag" content="课内基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/43cb6326cebfed66.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/微信图片_20240324121443.jpg"><link rel="canonical" href="https://www.lafael.top/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: surtr lafael","link":"链接: ","source":"来源: Hephaestus","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机组成原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-20 22:12:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/43cb6326cebfed66.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hephaestus"><span class="site-name">Hephaestus</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机组成原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-02T16:24:08.000Z" title="发表于 2024-11-03 00:24:08">2024-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-20T14:12:08.800Z" title="更新于 2024-12-20 22:12:08">2024-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机组成原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241220-215421.png></p>
<h1 id="计算机的基本结构"><a href="#计算机的基本结构" class="headerlink" title="计算机的基本结构"></a>计算机的基本结构</h1><h2 id="计算机的类型"><a href="#计算机的类型" class="headerlink" title="计算机的类型"></a>计算机的类型</h2><p>嵌入式计算机（embedded computer）：专门为单个功能设计的计算机，集成于各种家电，交通工具等，集成（<strong>integrated</strong>）</p>
<p>个人计算机（Pc）：以个人为单位的计算机，支持使用各种软件，主要用于个人用途。在此之下还有台式计算机（desktop computer）和工作站计算机（workstation computer），后者专为工程而生，具有强大的计算和图像显示能力。</p>
<p>服务器（server）和企业系统（enterprise system）由许多用户共用的计算机，通过网络连接</p>
<p>超级计算机（super computer）和网格计算机（grid computer）：后者是组合了PC和工作站计算机的网格式计算机</p>
<p>云电脑（cloud ocmputer）</p>
<h2 id="功能部件（注－填空）"><a href="#功能部件（注－填空）" class="headerlink" title="功能部件（注－填空）"></a>功能部件（注－填空）</h2><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006170629.png" alt=""></p>
<p>五大元件：输入设备，输出设备，存储器，ALU，控制器（合成处理器）</p>
<h3 id="存储器（memory）："><a href="#存储器（memory）：" class="headerlink" title="存储器（memory）："></a>存储器（memory）：</h3><p>分为主存（main memory）和辅助存储器（secondary storage）。</p>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>主存为RAM，更快的RAM被称为高速缓存，与处理器紧密联系，用于存储指令以及提高指令运行速度。</p>
<p>主存由大量半导体存储单元组成</p>
<h4 id="辅助存储器（secondary-storage）"><a href="#辅助存储器（secondary-storage）" class="headerlink" title="辅助存储器（secondary storage）"></a>辅助存储器（secondary storage）</h4><p>包括磁盘，光盘和闪存设施，</p>
<h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>包含ALU和寄存器</p>
<p>寄存器的速度大于高速缓存</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006170708.png" alt=""></p>
<p>主存一般存储程序，当需要执行程序时，<strong>程序计数器（PC） 指向下一个执行的程序的地址</strong>，并将此程序发向存储器，以读信号读出寻找的程序，读出后装入寄存器 <strong>指令寄存器（IR）</strong>， 以便直接解释以及执行。</p>
<p>pc指向下一个指令-&gt;读取存储器中的指令-&gt;存储到IR-&gt;加载到ALU计算-&gt;运算结果存取在寄存器中-&gt;写入存储器。</p>
<p>补充：处理器中存在MDR与MAR，分别起传递数据（data）和地址的作用。故又有流程：pc指向下一个程序—-将此指令发送至MAR（pc指向的指令地址）———MAR将指令发送到主存——-主存按指令提取到pc指向的指令——传送到MDR（将指令转化为二进制数据）——-数据传递到IR——-IR转化为可执行的指令（以load为例，即加载数据到指定位置）———指令传递到MAR———-到主存拿到数据———-传递到MDR———传递到处理器寄存器中。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>用于暂停程序的运行，处理器执行中断服务程序（interrupt-servicr routine）并将处理器的状态信息存储到存储器，恢复时载入。中断只能在IR当前执行的指令完成后进行。</p>
<h3 id="浮点数：小数点的位置会根据数值而变化"><a href="#浮点数：小数点的位置会根据数值而变化" class="headerlink" title="浮点数：小数点的位置会根据数值而变化"></a>浮点数：小数点的位置会根据数值而变化</h3><p>电气电子工程师学会IEEE</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>指令级并行：在执行指令的同时加载指令</p>
<p>多核（core）处理器：在一个芯片上放置多个处理单元</p>
<p>多处理器：存在多个处理器，每个处理器又包含多个核。</p>
<h2 id="历史（注－选择）"><a href="#历史（注－选择）" class="headerlink" title="历史（注－选择）"></a>历史（注－选择）</h2><h3 id="第一代"><a href="#第一代" class="headerlink" title="第一代"></a>第一代</h3><p>1945-1955<br>真空管（Vacuum tubes），磁芯存储器（magnetic core），磁鼓存储器（magnetic drum），汇编语言</p>
<h3 id="第二代"><a href="#第二代" class="headerlink" title="第二代"></a>第二代</h3><p>晶体管（transistors），磁盘（magnetic disk），高级语言</p>
<h3 id="第三代"><a href="#第三代" class="headerlink" title="第三代"></a>第三代</h3><p>集成电路（integrated circuits），</p>
<h3 id="第四代"><a href="#第四代" class="headerlink" title="第四代"></a>第四代</h3><p>VISL，LSI等超大规模集成电路</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1 . Which of the following is an example of bothinput and output device?<br>A. Touchpad B. Display C. Printer D. Keyboard</p>
<p><em>A</em><br>2 . List the names of five functional units of a computer.<br><em>运算器，控制器，输入，输出，存储器</em></p>
<p>3 . Which technology marked the start of the first/second/third generation of electronic digital computers?<br>A. integrated-circuit<br>B. VLSI<br>C. transistor<br>D. vacuum tube</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要考点：计算机的五大功能部件，计算机的发展史</p>
<h1 id="算数运算-Arithmetic"><a href="#算数运算-Arithmetic" class="headerlink" title="算数运算(Arithmetic)"></a>算数运算(Arithmetic)</h1><p>三种大题三选一</p>
<h2 id="数的表示及算数运算"><a href="#数的表示及算数运算" class="headerlink" title="数的表示及算数运算"></a>数的表示及算数运算</h2><p>原码：数的绝对值表示<br><strong>带符号原码(signed-Magnitude representation)</strong>：仅拓展了符号位<br><strong>反码(one’s complement)</strong>：原码所有位取反得到<br><strong>补码(two’s complement)</strong>：反码末位加1得到<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241206213224.png></p>
<p>正数在加法运算中不需要改为补码，在减法运算中作为减数需要变为补码。负数在减法运算中作为被减数需要变为1次补码，减数则需要两次，即变为对应的正数。</p>
<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>同号补码相加符号相反表示结果溢出，单纯的符号位进位不一定是溢出<br><strong>最高位（MSB）</strong></p>
<p>当计算结果出现颠倒，例如-6-7得到正数，此时我们称为溢出；若符号位1+1进位，但结果与预期一致，则不是溢出</p>
<h3 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h3><p>假若x-y中y=7，那么-y的补码表示为：y的无符号原码取反加1；<br>若x-y中y=-7，那么-y的补码表示为：y的原补码表示取反加1；</p>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p>（数的表示部分）</p>
<ol>
<li><strong>Question 1</strong>: Which representation is the most efficient method for performing addition and subtraction operations?<ul>
<li><strong>Options</strong>: </li>
<li>A. Signed-Magnitude Representation; </li>
<li>B. Signed 1’s Complement Representation; </li>
<li>C. Signed 2’s Complement Representation; </li>
<li>D. None of the above.</li>
<li><strong>Answer</strong>: C. </li>
</ul>
</li>
<li><strong>Question 2</strong>: What is the range of an 8 -bit signed 2’s complement integer?<ul>
<li><strong>Options</strong>: A. [-256, +256]; B. [-256, +255]; C. [-128, +128]; D. [-128, +127].</li>
<li><strong>Answer</strong>: D. According to the range of n -bit Two’s-complement integer mentioned in the document, which is $-2^{n - 1}$ to $2^{n - 1}-1$. For 8 bits, it is $-2^7$ to $2^7 - 1$, that is [-128, +127].</li>
</ul>
</li>
<li><strong>Question 3</strong>: Given the 8 -bit binary number 10011101, what decimal number does this represent if the computer uses signed-magnitude representation?<ul>
<li><strong>Options</strong>: A. +29; B. -29; C. +99; D. -99.</li>
<li><strong>Answer</strong>: D. 原码表示，直接取绝对值</li>
</ul>
</li>
<li><strong>Question 4</strong>: Given the 8 -bit binary number 10011101, what decimal number does this represent if the computer uses signed two’s complement representation?<ul>
<li><strong>Options</strong>: A. +29; B. -29; C. +99; D. -99.</li>
<li><strong>Answer</strong>: D. 补码表示，取反加1，<strong>再看原符号位</strong></li>
</ul>
</li>
</ol>
<hr>
<p>（计算部分）<br>1 . Assume that X and Y are two 8-bit signed two’s complement numbers 01011110 and 11001010. What is the result of <strong>X+Y</strong>?<br>A. 00101000<br>B. 10010100<br>C. 01000100<br>D. 00011100<br><em>A，直接计算即可</em><br>2 . Assume that X and Y are two 8-bit signed two’s complement numbers 01011110 and 11001010. What is the result of X-Y?<br>A. 00101000<br>B. 10010100<br>C. 01000100<br>D. overflow<br><em>D，Y取反加1后计算，发现两个符号位为0的数得到符号位为1的结果，溢出</em><br>3 . True or False? Subtracting a negative integer from another negative integer in 2’s-complement binary arithmetic can cause an overflow.<br><em>错，符号位都不相同，不满足溢出的前提条件</em></p>
<h2 id="有符号数加减法"><a href="#有符号数加减法" class="headerlink" title="有符号数加减法"></a>有符号数加减法</h2><p><strong>全加器（full adder FA）</strong></p>
<h3 id="行波进位加法器（ripple-carry-adder）"><a href="#行波进位加法器（ripple-carry-adder）" class="headerlink" title="行波进位加法器（ripple-carry adder）"></a>行波进位加法器（ripple-carry adder）</h3><h4 id="最低有效位（LSB）"><a href="#最低有效位（LSB）" class="headerlink" title="最低有效位（LSB）"></a>最低有效位（LSB）</h4><p>用于反码加1得到补码</p>
<h4 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006170757.png" alt=""></p>
<p>全加器如图，有进位输入及进位输出，输入两位以得到加法结果。<br>求和结果为三值的异或，进位输出的结果为$c_{i+1}=yc_i+xc_i+xy$</p>
<h4 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006170819.png" alt=""></p>
<p>由此得到了k个n为加法器的级联，即行波进位加法器。</p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006170840.png" alt=""></p>
<p>其中，每个全加器都可控制加法与剑法输入。</p>
<h4 id="溢出检测"><a href="#溢出检测" class="headerlink" title="溢出检测"></a>溢出检测</h4><p>对有n位的两个数，$overflow=c_n\oplus c_{n-1}$<br>若为1，则两个数的求和溢出<br>  $Overflow =x_{n-1} y_{n-1} \overline{S}_{n-1}+\overline{x}_{n-1} \overline{y}_{n-1} s_{n-1}$此公式也可以判断（由最小项结合真值表推出）</p>
<h4 id="延迟分析"><a href="#延迟分析" class="headerlink" title="延迟分析"></a>延迟分析</h4><p>求和结果比进位结果提前一个周期得到<br>由此得到，对n位的数据求和，和结果在2n-1时出现，进位结果在2n时出现</p>
<h4 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h4><p>1 . In a 1-bit full adder, which expression is $s_{i} ?$<br> $A. x_{i}+y_{i}$<br> $B. x_{i} \oplus y_{i}$<br> $C. x_{i} y_{i}$<br> $D. x_{i} \oplus y_{i} \oplus c_{i}$<br> <em>D</em><br> 2 . In a 1-bit full adder, which expression is c $C_{i+1} ?$<br> $A. x_{i}+y_{i}+c_{i}$<br> $B. x_{i} y_{i} c_{i}$<br> $C. x_{i} y_{i}+x_{i} c_{i}+y_{i} c_{i}$<br> $D. x_{i} \oplus y_{i} \oplus c_{i}$<br> <em>c</em><br> 3 . If we want to construct a 64-bit adder, how many adders do we need if we have some 4 -bit ripple carry adders?<br> A. 32 B. 16 C. 8 D. 4<br><em>B</em></p>
<h2 id="快速加法器设计"><a href="#快速加法器设计" class="headerlink" title="快速加法器设计"></a>快速加法器设计</h2><h3 id="超前进位加法-Carry-Lookahead-addition"><a href="#超前进位加法-Carry-Lookahead-addition" class="headerlink" title="超前进位加法(Carry-Lookahead addition)"></a>超前进位加法(Carry-Lookahead addition)</h3><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006170920.png" alt=""></p>
<p>此公式推出得到进位的公式，可由前一个进位和G_i和P_i得到，两者分别称为生成函数和传播函数。依次带入C_i，可得到</p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171006.png" alt=""></p>
<p>于是，每一位的进位输出和输入都能够快速完成了</p>
<h4 id="单位-1"><a href="#单位-1" class="headerlink" title="单位"></a>单位</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171050.png" alt=""></p>
<p>其基本单位如上：</p>
<p>每个单位的G与P都可同步算出，记为一次门延迟；带入计算进位输出的式子，可得所有进位在三个门延迟内完成；结果需要进位信息，因此需要4个门延迟后得到；</p>
<h4 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171114.png" alt=""></p>
<p>如上图，扩展得到4位超前进位加法器</p>
<h4 id="扇入限制-Fan-In"><a href="#扇入限制-Fan-In" class="headerlink" title="扇入限制(Fan-In)"></a>扇入限制(Fan-In)</h4><ol>
<li>扇入(Fan-in)：元件的输入数量</li>
<li>扇出(Fan-out)：元件的输出数量<br>较大的扇入会增加信号传输的延迟，从而影响电路的整体性能，超前进位对扇入的要求比较严苛<h4 id="级联-1"><a href="#级联-1" class="headerlink" title="级联"></a>级联</h4></li>
</ol>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171156.png" alt=""></p>
<p>8个4位超前进位加法器级联得到32位超前进位加法器。该加法器的G与P也是同步计算的，故得到所有的进位信息需要3+（8-1）*2=17个门延迟，而和需要17+1=18个门延迟。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171231.png" alt=""></p>
<p>以相同的方式组装得到16位超前进位加法器</p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171309.png" alt=""></p>
<p>由此公式得到，生成$P^<code>,G^</code>$需要两个和三个门延迟，子元件的$P^<code>,G^</code>$构成了大元件的P,G，故得到所有的进位需要5个门延迟。在第5个周期时，所有的块得到进位输入以及输出；在第七个周期时，所有的块内部的单元得到进位输入以及输出；在第八个周期时所有的单元得到和</p>
<p>故需要5个门延迟得到进位和8个门延迟得到和</p>
<h3 id="行波进位加法器与超前进位的比较"><a href="#行波进位加法器与超前进位的比较" class="headerlink" title="行波进位加法器与超前进位的比较"></a>行波进位加法器与超前进位的比较</h3><p>行波进位加法器需要的空间少，电路不复杂，成本低，但速度慢<br>超前进位需要的空间大，电路复杂，对元器件的要求高，成本高，速度快</p>
<h4 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h4><p>1 .  A 16-bit ripple-carry adder is used to add two numbers X(x15x14…x1x0) and Y(y15y14…y1y0) to generate a 16-bit sum S(s15s14…s1s0). How many gate delays are required to compute s13 after all the inputs have been applied?<br>A. 8 B. 25 C. 27 D. 31<br><em>B，计算第13位，带入公式，求和需要25个周期，进位需要26个周期</em></p>
<p> 2 .  The advantage of carry-lookahead adder is__.<br> A. Optimize the structure of the adder<br> B. Save hardware parts<br> C. Augment the structure of the adder<br> D. Accelerate the generation of the carries<br> <em>B</em></p>
<p>3 . In carry-lookahead adder, which expression is called the propagate function Pi for stage i?<br>A. $xi+yi$<br>B. $xi⊕yi$<br>C. $xiyi$<br> $D. x_{i} \oplus y_{i} \oplus c_{i}$<br> <em>C</em></p>
<p>4 . In carry-lookahead adder, which expression is called the generate function Gi for stage i?<br>A. xi+yi B. xi⊕yi C. xiyi D. xi⊕yi⊕ci<br><em>A</em></p>
<p>5 . Ture or False?<br>In a 4-bit carry-lookahead adder, all carries can be obtained 3 gate delays after the input signal X, Y and c0 are applied.<br><em>True</em></p>
<h2 id="无符号数乘法-multipication-of-unsigned-numbers"><a href="#无符号数乘法-multipication-of-unsigned-numbers" class="headerlink" title="无符号数乘法(multipication of unsigned numbers)"></a>无符号数乘法(multipication of unsigned numbers)</h2><h3 id="陈列"><a href="#陈列" class="headerlink" title="陈列"></a>陈列</h3><h3 id="阵列乘法器（了解即可）"><a href="#阵列乘法器（了解即可）" class="headerlink" title="阵列乘法器（了解即可）"></a>阵列乘法器（了解即可）</h3><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171427.png" alt=""></p>
<p>乘法原理：根据1/0得到加数，再进位进行加法。</p>
<h4 id="单位-2"><a href="#单位-2" class="headerlink" title="单位"></a>单位</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171504.png" alt=""></p>
<p>使用全加器（FA），q_i为乘数，m_j为被乘数，二者不变而在阵列中传递。进位输入输出是ldx了，向下传递最高位的进位输出</p>
<h4 id="整体-1"><a href="#整体-1" class="headerlink" title="整体"></a>整体</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171536.png" alt=""></p>
<p>斜向传递的是被乘数，横向贯穿的是乘数。</p>
<p>从横向上：每个单元交流进位；</p>
<p>纵向上：每个单位将最高有效位的进位传递到下一组加法，将每次进位产生的单独一位传下</p>
<h3 id="顺序电路乘法器-sequence-Multiplication-（注－大题）"><a href="#顺序电路乘法器-sequence-Multiplication-（注－大题）" class="headerlink" title="顺序电路乘法器(sequence Multiplication)（注－大题）"></a>顺序电路乘法器(sequence Multiplication)（注－大题）</h3><h4 id="整体-2"><a href="#整体-2" class="headerlink" title="整体"></a>整体</h4><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171631.png" alt=""></p>
<p>C储存最高有效位的进位，寄存器A记载每次加法的和，<strong>乘数Q记载乘数(Multoplier)</strong>，<strong>M记载被乘数(Multiplicand)</strong>。这三个元件一体，每次向右移位。控制序列发生器检测Q中的第一个元素，为一则进行加法，得到各个数据然后移位；为0则不进行加法，但是仍要移位。进行n次后就得到了乘法结果。<br><strong>记住公式$M*Q=A+c$</strong></p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171701.png" alt=""></p>
<p>由上图可知：</p>
<p>检测为1，加法启动，然后移位，最高有效位未产生进位，c为0；</p>
<p>检测为1，加法启动，c进为1，然后移位；</p>
<p>检测为0，不加，移位；</p>
<p>检测为1，加法启动，移位。</p>
<p>完成；</p>
<h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><p>Multiply A and B (unsigned numbers) using sequential multiplication. Assume that A is the multiplicand and B is the multiplier.<br>A= 00101 and B=10101<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241207-120335.png><br>注意： </p>
<ol>
<li>取和是将A和M的内容相加</li>
<li>不需要补充位数</li>
</ol>
<h2 id="有符号数乘法-Multiplication-of-signed-Numbers-（注－）"><a href="#有符号数乘法-Multiplication-of-signed-Numbers-（注－）" class="headerlink" title="有符号数乘法(Multiplication of signed Numbers)（注－）"></a>有符号数乘法(Multiplication of signed Numbers)（注－）</h2><h3 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h3><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171729.png" alt=""></p>
<p><strong>此图简单的理解方式是从右向左扫描，遇到1就记为-1，若左侧是0，则把0记为+1，反之记为0；</strong><br>将乘数转化为booth格式，遇到-1即将被乘数转化为补码，遇到+1则保持不变。乘数右侧补零，中间值按符号扩位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>_0_</th>
</tr>
</thead>
<tbody>
<tr>
<td>+1</td>
<td>0</td>
<td>-1</td>
<td>+1</td>
<td>0</td>
<td>0</td>
<td>-1</td>
</tr>
</tbody>
</table>
</div>
<h3 id="流程表示"><a href="#流程表示" class="headerlink" title="流程表示"></a>流程表示</h3><p>当$Q_1$和$Q_{-1}$为上述的组合时，执行对应的操作<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241207134639.png><br>结果为AQ</p>
<h3 id="手算表示"><a href="#手算表示" class="headerlink" title="手算表示"></a>手算表示</h3><p>设被乘数为0110011，则</p>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+1</td>
<td>0</td>
<td>-1</td>
<td>+1</td>
<td>0</td>
<td>0</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>符号位</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>忽略最高有效位的进位。<br>得到的符号位是0，故不需要求补，反之需要求补码<br>算术右移，保留符号位（？）</p>
<h4 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h4><p>1 . In the hardware circuit of implementing Booth algorithm, the multiplier is placed in the Q register. And a 1-bit register $Q_{-1}$ is placed logically to the right of the least significant bit $(Q_{0})$ of the Q register. The results of the multiplication will appear in the A and Q registers. At the end of each cycle of computing the product, A, Q, $Q_{-1}$ are <strong>__</strong> one bit position.<br>A. shifted left B. shifted right<br>C. arithmetically shifted left D. arithmetically shifted right<br><em>D，算术右移，保持符号不变</em></p>
<p>2 . About Booth algorithm, which of the following is not true?<br>A. It can handle both positive and negative multipliers uniformly<br>B. It achieves some efficiency in the number of additions required when the multiplier has a few large blocks of 1s<br>C. Its speed of doing multiplication is always faster than the normal algorithm D. The multiplier 111100110 will generate three partial products<br><em>C，Booth只能化简大块聚集的1，01010101的效率可能更差</em></p>
<p>3 . What are the main advantages of the Booth algorithm?<br><em>– Directly handle the multiplication with the signed numbers</em><br><em>– Fewer partial products generated for groups of consecutive 0’s and 1’s</em></p>
<p>4 . Multiply A and B (2’s-complement numbers) using the Booth algorithm. Assume that A is the multiplicand and B is the multiplier.<br> $A=110011 and B=101100$</p>
<p> <img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241207-141341.png><br> <strong>注意：乘数中的-1表示对被乘数取反加1（一般会使符号相反），符号以取反加1的结果为主</strong><br> <img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241207-141350.png></p>
<p><strong>注意：结果为A和Q中的内容，减法为A-M而不是M-A</strong></p>
<h2 id="快速乘法"><a href="#快速乘法" class="headerlink" title="快速乘法"></a>快速乘法</h2><h3 id="乘数位偶重编码-Multiplier-Digit-Even-Weighted-Encoding-（注-）"><a href="#乘数位偶重编码-Multiplier-Digit-Even-Weighted-Encoding-（注-）" class="headerlink" title="乘数位偶重编码(Multiplier Digit Even-Weighted Encoding)（注-）"></a>乘数位偶重编码(Multiplier Digit Even-Weighted Encoding)（注-）</h3><p>对booth格式的乘数进行重编码</p>
<p>要求乘数是4的倍数，转换规则如下</p>
<ol>
<li><p>先转换为booth</p>
</li>
<li><p>再使用下表再次进行缩少一半的转换</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>booth（i+1）</th>
<th>booth（i）</th>
<th>乘数位偶重编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>0</td>
<td>+1</td>
<td>+1</td>
</tr>
<tr>
<td>-1</td>
<td>0</td>
<td>-2</td>
</tr>
<tr>
<td>+1</td>
<td>0</td>
<td>+2</td>
</tr>
<tr>
<td>-1</td>
<td>+1</td>
<td>-1</td>
</tr>
<tr>
<td>+1</td>
<td>-1</td>
<td>+1</td>
</tr>
</tbody>
</table>
</div>
<p>给出例子，每次乘法向前进两位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td>-1</td>
<td></td>
<td>-2</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="求和项的进位保留加法"><a href="#求和项的进位保留加法" class="headerlink" title="求和项的进位保留加法"></a>求和项的进位保留加法</h3><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171913.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006171932.png" alt=""></p>
<p>可通过模拟手动求和来推断行波进位阵列</p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006172038.png" alt=""></p>
<p>将同时求和位数加到了3而已</p>
<h3 id="使用3-2简化器的求和项加法树"><a href="#使用3-2简化器的求和项加法树" class="headerlink" title="使用3-2简化器的求和项加法树"></a>使用3-2简化器的求和项加法树</h3><p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006172111.png" alt=""></p>
<p>即将$6*6$位的乘法每项求和，简化为对每三项求和（直接相加，不再计算）与进位，再组合得到答案。大部分步骤可以同时进行</p>
<p><img src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006172207.png" alt=""></p>
<h3 id="使用4-2简化器的求和项加法树"><a href="#使用4-2简化器的求和项加法树" class="headerlink" title="使用4-2简化器的求和项加法树"></a>使用4-2简化器的求和项加法树</h3><h2 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h2><p>整体上使用<strong>逻辑左移</strong>的思想</p>
<h3 id="恢复除法-restoring-division-（注－）"><a href="#恢复除法-restoring-division-（注－）" class="headerlink" title="恢复除法(restoring division)（注－）"></a>恢复除法(restoring division)（注－）</h3><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006172236.png style="zoom:67%;" /></p>
<p>恢复除法的核心思想是若进行计算，则再进行一次运算以得到原数。</p>
<p><strong>增加一位表示符号</strong></p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006172621.png alt="image-20240918163725017" style="zoom:67%;" /><br>把除法试想为减法，若被减数大于减数，则取一进行减法，反之得到原数之后取零。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>A，Q左移一位</p>
</li>
<li><p>A减去M，结果放回A</p>
</li>
<li><p>若A的符号为1（A&lt;M），上商取0，将M加回到A以得到A；否则商取为1，不再恢复。</p>
</li>
</ol>
<h3 id="不恢复除法-Non-Restoring-（注－大题）"><a href="#不恢复除法-Non-Restoring-（注－大题）" class="headerlink" title="不恢复除法(Non-Restoring)（注－大题）"></a>不恢复除法(Non-Restoring)（注－大题）</h3><p>M，A增加一位表示符号</p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006172832.png></p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>若A的符号为0，则左移后A-M；反之左移后A+M</p>
</li>
<li><p>得到新的A的值后，若A的符号为0，商取为1；反之为0</p>
</li>
</ol>
<h3 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h3><p>• Using non-restoring division algorithm, perform the operation A÷B on the 4-bit unsigned numbers A= 0111 and B= 0011.<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241207-151731.png><br>值得注意的是：</p>
<ol>
<li>恢复除法中商和余数已经自动算出</li>
<li>不恢复除法中，余数需要判断：<ol>
<li>若结果中A的符号位是0，则就是余数</li>
<li>否则，加上除数来恢复到余数</li>
</ol>
</li>
</ol>
<h2 id="浮点数-FP-及其运算（注－大题，填空）"><a href="#浮点数-FP-及其运算（注－大题，填空）" class="headerlink" title="浮点数(FP)及其运算（注－大题，填空）"></a>浮点数(FP)及其运算（注－大题，填空）</h2><h3 id="定点数-Fixed-point"><a href="#定点数-Fixed-point" class="headerlink" title="定点数(Fixed-point)"></a>定点数(Fixed-point)</h3><p>根据小数点位置，有不同的表示范围，例如纯小数(pure-fraction)的范围为：$-1到1-2^{-n}$</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>主要考察表示（包括正规IEEE规定和题目规定），少部分考察计算（加减）</p>
<p>分为单精度和双精度</p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006172929.png><br>一个计算机必须至少提供单精度的数值表示<br><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006173007.png></p>
<p>均有三部分：</p>
<h3 id="符号位S"><a href="#符号位S" class="headerlink" title="符号位S"></a>符号位S</h3><p>为1时表示正值，反之为负值</p>
<h3 id="余数E‘-exponent"><a href="#余数E‘-exponent" class="headerlink" title="余数E‘(exponent)"></a>余数E‘(exponent)</h3><p>$E^<code>=E+(2^&#123;n-1&#125;-1)，E^</code>$为无符号数，+127是为了方便区分正负数的大小，注：对n位的余数部分，+的值为$2^{n-1}-1$。</p>
<p>$E^`$的范围是$0到2^n-1$，两个端点值是特殊值，E的范围是$-2^{n-1}+1到2^{n-1}$，两个端点值同样是特殊值，一般不会取该值</p>
<h3 id="尾数M-mantissa"><a href="#尾数M-mantissa" class="headerlink" title="尾数M(mantissa)"></a>尾数M(mantissa)</h3><p>一般情况下值为1.M</p>
<p>表示范围是$1.0000…到2-2^{-23}$</p>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p>$E^<code>=0$表示尾数上没有隐含的1，即**非规格数（Denormal number)**；相反为**规格数（normal）**
当$E^</code>=0,M=0$时表示值为0</p>
<p>当$E^`=0,M!=0$时表示$±0.M \cdot 2^{-126}$，比最小值0还小，表示<strong>下溢(underflow)或非规格数(Denormal number)</strong></p>
<p>当$E^`=255,M=0$时表示<strong>无穷(infinity)</strong></p>
<p>当$E^`=255,M！=0$时比无穷还大，表示<strong>上溢(overflow)或无法表示(NaN)</strong></p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241207164140.png></p>
<h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p>主要考察加减<br><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006173231.png></p>
<h3 id="保护位-guard-bits-与截取-truncation"><a href="#保护位-guard-bits-与截取-truncation" class="headerlink" title="保护位(guard bits)与截取(truncation)"></a>保护位(guard bits)与截取(truncation)</h3><p>在计算过程中，会扩展计算位数，称为保护位<br>一个有效的截取方法应是<strong>无偏的(unbiased)</strong></p>
<h4 id="截断-truncation"><a href="#截断-truncation" class="headerlink" title="截断(truncation)"></a>截断(truncation)</h4><p>保护位的值全部抛弃，不产生影响</p>
<h4 id="冯诺依曼舍入-Von-Neumann-Rounding"><a href="#冯诺依曼舍入-Von-Neumann-Rounding" class="headerlink" title="冯诺依曼舍入(Von Neumann Rounding)"></a>冯诺依曼舍入(Von Neumann Rounding)</h4><p>若保护位中有1，则结果的最小有效位取1</p>
<h4 id="舍入-Rounding"><a href="#舍入-Rounding" class="headerlink" title="舍入(Rounding)"></a>舍入(Rounding)</h4><p>保护位的最高有效位为1，则</p>
<pre><code>1. 保留位的LSB为0，直接截取
2. 保留位的LSB为1，则给此LSB+1
</code></pre><p>反之不操作，直接截取</p>
<h3 id="溢出-1"><a href="#溢出-1" class="headerlink" title="溢出"></a>溢出</h3><h4 id="指数上溢"><a href="#指数上溢" class="headerlink" title="指数上溢"></a>指数上溢</h4><p>比如大于127</p>
<h4 id="指数下溢"><a href="#指数下溢" class="headerlink" title="指数下溢"></a>指数下溢</h4><p>不如小于-126</p>
<h4 id="尾数溢出"><a href="#尾数溢出" class="headerlink" title="尾数溢出"></a>尾数溢出</h4><p>需要左移小数点，指数+1</p>
<h4 id="尾数下溢"><a href="#尾数下溢" class="headerlink" title="尾数下溢"></a>尾数下溢</h4><p>保护位的缺陷使得值没有得到保存</p>
<h3 id="加减操作的实现（了解）"><a href="#加减操作的实现（了解）" class="headerlink" title="加减操作的实现（了解）"></a>加减操作的实现（了解）</h3><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006173856.png></p>
<h3 id="定点数和浮点数的比较"><a href="#定点数和浮点数的比较" class="headerlink" title="定点数和浮点数的比较"></a>定点数和浮点数的比较</h3><p>定点数：过大的整数无法被表示，非常小的分数也无法表示<br>浮点数：表示灵活，范围广</p>
<h3 id="习题-7"><a href="#习题-7" class="headerlink" title="习题"></a>习题</h3><p>（浮点数的表示）<br>1 . In IEEE754 standard for representing floating-point numbers of 32 bits, the sign of the number is given 1 bit, the exponent of the scale factor is allocated 8 bits, and the mantissa is assigned 23 bits. What is the maximum normalized positive number that 32-bit representation can represent?<br> $A. +\left(2-2^{-23}\right) × 2^{+127}$<br> $B. +\left(1-2^{-23}\right) × 2^{+127}$<br> $C. +\left(2-2^{-23}\right) × 2^{+255}$<br> $D. 2^{+127-2^{-23}}$<br> <em>A，最大的正单精度浮点数符号必为0,尾数部分取23个1,故为1.111…1, 指数部分取E=254,实际的指数 $e=127$ ,</em><br> <em>$所以是 1.111 … 1 × 2^{+127}=+\left(2-2^{-23}\right) × 2^{+127}$</em></p>
<p>2 . In single-precision format of IEEE 754 floating point number standard, instead of the signed exponent E, what is the value actually stored in the exponent field?<br> $A. E=e+255$<br> $B. E=e+127$<br> $C. E=e+256$<br> $D. E=e+128$<br> <em>B，IEEE 754标准规定单精度浮点数的指数部分占8位, $E=e+(2^{8-1}-1)$</em></p>
<p>3 . In double-precision format of IEEE 754 floating point number standard, instead of the signed exponent e, what is the value E actually stored in the exponent field?<br> $A. E=e+2047$<br> $B. E=e+1023$<br> $C. E=e+2048$<br> $D. E=e+1024$<br> <em>A，IEEE 754标准规定双精度浮点数的指数部分占11位, $E=e+(2^{11-1}-1)$</em></p>
<p>4 . True or False? A computer must provide at least single-precision representation to conform to the IEEE standard.<br><em>True</em></p>
<p>5 . Using 32-bit IEEE 754 single precision floating point format, show the representation of -0.6875.<br> <em>$0.6875=0.1011 × 2^{0}=1.011 × 2^{-1}$</em><br> <em>$M=0110000000000000000000$</em><br> <em>$E=e+127=-1+127=+126, 表示为: 01111110$</em><br> <em>所以-0.6875表示为: 1 01111110 01100000000000000000000</em></p>
<hr>
<p>（浮点数的计算）</p>
<p>1 . True or False? An overflow of the mantissa field of a floatingpoint number means a real case of overflow.<br><em>浮点数的尾数部分溢出并不是真正的溢出,可以通过移位来解决; 而指数部分溢出才是真正的溢出｡</em></p>
<p>2 . Consider a reduced 8-bit IEEE floating-point format, with 1 bit for the sign, 3 bits of the exponent and 4 bits for the mantissa. Note that the mantissa is normalized with an implied 1 to the left of the binary point.<br>(1) Express $A=2.38$ and $B=1.6$ in this floating-point format.<br>(2) Write the computation process of A-B and give the result in normalized form. Use <strong>Rounding</strong> method as needed.<br>Solution:<br> $(1) +2.38=+10.0110000=+1.0011 × 2^{1} 0100011 1010$<br> 0 100 0011<br> $+1.6=+1.1001100=+1.1010\times 2^{0}$<br> 0 011 1010<br> 此处就已经使用了舍入的思想<br> (2)<br> ①Shift the mantissa of B to the right by one bit position, giving 0.11010 ②Set the exponent of the result to 100.<br> ③Subtract the mantissa of B from the mantissa of A, giving<br> $\frac{-1.0011 \underline{0}}{0.0110 \underline{0}}$ and set the sign of the result to 0. ④Shift the mantissa to the left by two bit positions. We obtain a result mantissa of 1.1000. So the exponent of the result is 010. The answer is 0 010 1000</p>
<p><strong>注意：各个地方都可能需要舍入，注意操作步骤，指数的结果可以直接加减</strong></p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241207-213704.png></p>
<h1 id="存储器系统（注意各元件与方法之间的比较）"><a href="#存储器系统（注意各元件与方法之间的比较）" class="headerlink" title="存储器系统（注意各元件与方法之间的比较）"></a>存储器系统（注意各元件与方法之间的比较）</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol>
<li>存储器分为内部存储与外部存储，内存包含主存，快速缓存，寄存；外存包括磁盘等</li>
</ol>
<h3 id="主存组织架构-main-mempry-organization"><a href="#主存组织架构-main-mempry-organization" class="headerlink" title="主存组织架构(main mempry organization)"></a>主存组织架构(main mempry organization)</h3><p>主存由许多个承载位（bit）的单元构成，多个bit（通常数目是固定的）构成了<strong>字(word)</strong></p>
<p><strong>字长(wordLength)</strong>：字中包含的bit数目</p>
<p>为得到具体数据，引入地址。地址反映了字的物理地点</p>
<h3 id="主存访问顺序（注－选择可能）"><a href="#主存访问顺序（注－选择可能）" class="headerlink" title="主存访问顺序（注－选择可能）"></a>主存访问顺序（注－选择可能）</h3><h4 id="大字节分配-Big-endian-Assignment"><a href="#大字节分配-Big-endian-Assignment" class="headerlink" title="大字节分配(Big-endian Assignment)"></a>大字节分配(Big-endian Assignment)</h4><p><strong>从左到右，从小到大，即MSB在左侧</strong></p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174010.png></p>
<h4 id="小字节分配-little-endian-assignment"><a href="#小字节分配-little-endian-assignment" class="headerlink" title="小字节分配(little-endian assignment)"></a>小字节分配(little-endian assignment)</h4><p><strong>从右到左，从小到大，即MSB在右侧</strong><br><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174023.png></p>
<h3 id="主存交互（了解）"><a href="#主存交互（了解）" class="headerlink" title="主存交互（了解）"></a>主存交互（了解）</h3><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174047.png></p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174106.png></p>
<p>结合第一章的MAR,MDR理解</p>
<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>将特定内存的信息副本加载到CPU</p>
<ol>
<li><p>CPU将所需信息的地址加载到MAR并将R/ \overline{W}置为1.</p>
</li>
<li><p>内存将地址中的信息通过data线发送给CPU，并发送MFC信号</p>
</li>
<li><p>当CPU检测到MFC时，将data中的数据加载到MDR</p>
</li>
</ol>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>将CPU给出的信息以覆写的形式写入内存</p>
<ol>
<li><p>将地址加载到MAR，将数据加载到MDR，将R/ \overline{W}置为0</p>
</li>
<li><p>当重写完成，内存发送MFC信号</p>
</li>
</ol>
<p>$R/ \overline{W}$：为1时R为1，W为0；为0时R为0，W为1 ；1/0代表是否启用</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="物理特征-physical-types"><a href="#物理特征-physical-types" class="headerlink" title="物理特征(physical types)"></a>物理特征(physical types)</h4><p><strong>半导体(semiconductor)</strong>：主存</p>
<p><strong>磁(magnetic)</strong>：磁盘，磁带</p>
<p><strong>光盘(CD)</strong>：CD,CD-R,CD-RW,DVD</p>
<h4 id="存储-capacity"><a href="#存储-capacity" class="headerlink" title="存储(capacity)"></a>存储(capacity)</h4><p>字长(word size)：一个字所用bit的数量</p>
<p>字量：所使用的字的数量</p>
<h4 id="传输-transfer"><a href="#传输-transfer" class="headerlink" title="传输(transfer)"></a>传输(transfer)</h4><p>内存：一次读写的数据量常常与字长相等</p>
<p>外存：一般以字块(blocks)的形式传输</p>
<h4 id="访问方式-access-methods"><a href="#访问方式-access-methods" class="headerlink" title="访问方式(access methods)"></a>访问方式(access methods)</h4><h5 id="顺序访问-sequential-access"><a href="#顺序访问-sequential-access" class="headerlink" title="顺序访问(sequential access)"></a>顺序访问(sequential access)</h5><p>信息以顺序排列在存储器中，访问时需要一个个访问以找到对应的字</p>
<p>例如：磁带</p>
<h5 id="随机访问-random-access"><a href="#随机访问-random-access" class="headerlink" title="随机访问(random access)"></a>随机访问(random access)</h5><p>任意内存块可以被随机且直接的访问，访问时间与内存排布无关</p>
<p>例如：RAM</p>
<h5 id="直接访问-direct-access"><a href="#直接访问-direct-access" class="headerlink" title="直接访问(direct access)"></a>直接访问(direct access)</h5><p>通过地址直接访问的信息所在的块，然后以顺序访问找到信息</p>
<p>例如：磁盘</p>
<h3 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h3><h4 id="访问时长-memory-access-time"><a href="#访问时长-memory-access-time" class="headerlink" title="访问时长(memory access time)"></a>访问时长(memory access time)</h4><p>CPU提供地址并得到数据的时间</p>
<p>对RAM：一次读或写操作的时长</p>
<p>对非RAM：将读写器移动到指定位置的时间</p>
<h4 id="周期时长-memory-cycle-time"><a href="#周期时长-memory-cycle-time" class="headerlink" title="周期时长(memory cycle time)"></a>周期时长(memory cycle time)</h4><p>只用于RAM，表示两个连续的存储器操作开始时刻之间的最小的时间延迟（例如DRAM的重写时长）</p>
<h4 id="传输速率-transfer-rate"><a href="#传输速率-transfer-rate" class="headerlink" title="传输速率(transfer rate)"></a>传输速率(transfer rate)</h4><p>数据传入或传出存储单元的速度</p>
<h3 id="易失-不易失（Volatile-Nonvolatile）"><a href="#易失-不易失（Volatile-Nonvolatile）" class="headerlink" title="易失/不易失（Volatile/Nonvolatile）"></a>易失/不易失（Volatile/Nonvolatile）</h3><p>易失：断电时，信息会逐渐丢失</p>
<p>不易失：信息一旦记录，就不会变质，直到故意改变。不需要电力来保持</p>
<h3 id="可擦写-不可擦写（Erasable-Non-erasable）"><a href="#可擦写-不可擦写（Erasable-Non-erasable）" class="headerlink" title="可擦写/不可擦写（Erasable/Non-erasable）"></a>可擦写/不可擦写（Erasable/Non-erasable）</h3><p>可擦写：存储的信息可以修改</p>
<p>不可擦写：存储的信息不可修改</p>
<h3 id="习题-8"><a href="#习题-8" class="headerlink" title="习题"></a>习题</h3><p>1 . The memory is organized so that a group of n bits can be stored or retrieved in a single, basic operation. n is called the —-<br>A. word B. word length C. address D. cell<br><em>B</em></p>
<p>2 . The 32-bit value 0x30A79847 is stored to the location 0x1000. If the system is little endian, the value of the byte —- is stored in address 0x1002.<br>A. 0x30 B. 0xA7 C. 0x98 D. 0x47<br><em>B，MSB在右侧</em></p>
<p>3 . In a main memory, its word size is 16, the number of word is 8K, what is the capacity of this main memory?<br>A. 16K×16 B. 16K×8 C. 8K×16 D. 8K×8<br><em>C</em></p>
<p>4 . For random access memory, the time it takes to perform a read or write operation is called —-<br>A. memory cycle time B. memory hit time C. memory recovery time D. memory access time<br><em>A</em></p>
<p>6 . If you turn off the power to the computer, items stored on —- device will be lost.<br>A. RAM B. disk C. DVD D. CD-ROM<br><em>A</em></p>
<p>7 . True or False? For internal memory, data are often transferred in much larger units than a word, and these are referred to as blocks.<br><em>False</em></p>
<p>8 . True or False? Memory access time is longer than memory cycle time.<br><em>False</em></p>
<p>9 . What is memory access time? What is memory cycle time? Explain the relationship between them.<br><em>Solution: Memory access time is time between presenting the address and getting the valid data. Memory cycle time is time from a memory access to the next memory access. Their relationship is Memory Cycle Time = Memory Access Time + Recovery Time.</em></p>
<h2 id="RAM-半导体随机存储器"><a href="#RAM-半导体随机存储器" class="headerlink" title="RAM(半导体随机存储器)"></a>RAM(半导体随机存储器)</h2><h3 id="SRAM（静态存储器）"><a href="#SRAM（静态存储器）" class="headerlink" title="SRAM（静态存储器）"></a>SRAM（静态存储器）</h3><p>信息存储在锁存器中</p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174219.png style="zoom:67%;" /></p>
<p>图示的T_1为1，且T_2为0时表示存储的信息为1.（两端自然反号）</p>
<h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><ol>
<li><p>将字线置为1，使通道打开</p>
</li>
<li><p>通过位线b ,b’读取对应的信息</p>
</li>
</ol>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><ol>
<li><p>将字线置为1，打开通道</p>
</li>
<li><p>将b置为1，b‘相反——写入1（位线上的信号由S/W产生）</p>
</li>
</ol>
<h4 id="CMOS的实现"><a href="#CMOS的实现" class="headerlink" title="CMOS的实现"></a>CMOS的实现</h4><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174301.png style="zoom:67%;" /></p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174333.png style="zoom:67%;" /></p>
<p>视为两个单位的组合，得到了两个反相器</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>如果电源中断然后恢复，锁存器将进入稳定状态，但不一定是同一个状态</p>
<p>CMOS SRAM 的功耗非常低</p>
<p>SRAM的访问速度极快</p>
<h4 id="SRAM内部组织"><a href="#SRAM内部组织" class="headerlink" title="SRAM内部组织"></a>SRAM内部组织</h4><h5 id="一维排列"><a href="#一维排列" class="headerlink" title="一维排列"></a>一维排列</h5><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174408.png style="zoom:80%;" /></p>
<p>15个字按行排序，每个的8位按列排序</p>
<h6 id="读-1"><a href="#读-1" class="headerlink" title="读"></a>读</h6><p><strong>字线(word line)</strong> 选择地址后将对应的信息通过S/W，即<strong>位线(bit line)</strong>输出</p>
<h6 id="写-1"><a href="#写-1" class="headerlink" title="写"></a>写</h6><p>将输入的信息按地址写入</p>
<h5 id="元件"><a href="#元件" class="headerlink" title="元件"></a>元件</h5><h6 id="地址线"><a href="#地址线" class="headerlink" title="地址线"></a>地址线</h6><h6 id="输入-输出线"><a href="#输入-输出线" class="headerlink" title="输入/输出线"></a>输入/输出线</h6><h6 id="R-W"><a href="#R-W" class="headerlink" title="R/W"></a>R/W</h6><h6 id="CS（引脚）"><a href="#CS（引脚）" class="headerlink" title="CS（引脚）"></a>CS（引脚）</h6><p>用于在集成芯片存储系统中选择给定的存储器芯片，被激活时，对应的芯片接受R/W信号，反之不响应</p>
<h6 id="地线"><a href="#地线" class="headerlink" title="地线"></a>地线</h6><h6 id="供电线"><a href="#供电线" class="headerlink" title="供电线"></a>供电线</h6><h5 id="二维排列"><a href="#二维排列" class="headerlink" title="二维排列"></a>二维排列</h5><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174450.png style="zoom:67%;" /></p>
<p>图示为1K × 1的存储器芯片，即10条字线和一条位线。字线分为一半，分别用来选择字和位。</p>
<p>加上地线，供电线，R/W，CS则共有15条线</p>
<h4 id="SRAM的优缺点"><a href="#SRAM的优缺点" class="headerlink" title="SRAM的优缺点"></a>SRAM的优缺点</h4><p>快，但密度低，成本高</p>
<h4 id="习题-9"><a href="#习题-9" class="headerlink" title="习题"></a>习题</h4><p>1 .  Assume that the capacity of a kind of SRAM chip is 8K×16, so the address lines and data lines of this chip are —- respectively.<br>A. 8,16 B. 13,16 C. 13,4 D. 8,4<br><em>B</em></p>
<p>2 . Assume that the capacity of a kind of SRAM chip is 32K×32, so the sum of address lines and data lines of this chip is —-<br><em>15+32=47</em></p>
<p>3 . What are the advantage and disadvantage of SRAM?<br><em>Advantage: Fast</em><br><em>Disadvantage: Low density, High cost</em></p>
<h3 id="DRAM（动态随机存储器）"><a href="#DRAM（动态随机存储器）" class="headerlink" title="DRAM（动态随机存储器）"></a>DRAM（动态随机存储器）</h3><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174519.png style="zoom:50%;" /></p>
<p>信息被存储在了电容C中，但会逐渐泄露，每次读操作会重写内容，且等到其电荷降低到某个阈值时才能读取内容。</p>
<h4 id="读-2"><a href="#读-2" class="headerlink" title="读"></a>读</h4><ol>
<li><p>字线置为1，晶体管打开</p>
</li>
<li><p>传感放大器检测电荷是否高于某个阈值，若高，则传感器将<strong>位线</strong>的电压提升至满电压以置为1，于是电容被充满，对应于1；反之位线置为0，电容放电</p>
</li>
</ol>
<h4 id="写-2"><a href="#写-2" class="headerlink" title="写"></a>写</h4><ol>
<li><p>字线置为1</p>
</li>
<li><p>位线置为1时表示高电位，置为0时表示低电位</p>
</li>
</ol>
<p>字线为0时通道关闭，状态短暂维持，需要定期刷新</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>高密度，低成本</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>访问时间长，需要定期刷新，信息容易泄露</p>
<h4 id="异步动态随机存储器-asynchronous-DRAM"><a href="#异步动态随机存储器-asynchronous-DRAM" class="headerlink" title="异步动态随机存储器(asynchronous DRAM)"></a>异步动态随机存储器(asynchronous DRAM)</h4><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174549.png></p>
<p><strong>RAS(Row Adress strobe)</strong>，<strong>CAS(column Address strobr)</strong></p>
<p>如上图，对于一个32M x 8的动态存储器芯片，首先计算地址线的数量$2^{25}=32M$，故需要25个地址接口，对于行数h与列数d，有h+d=25</p>
<p>如图所示，分配14位用于列地址，分配11位用于行地址。</p>
<p>注：先RAS启用，地址被加载到行地址寄存器，随后CAS被启用，列被加载到列地址加载器</p>
<p>由于上述操作的实现是由<strong>RAS和CAS信号控制</strong>的，称之为异步动态随机存储器</p>
<h4 id="快速页模式"><a href="#快速页模式" class="headerlink" title="快速页模式"></a>快速页模式</h4><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174656.png></p>
<p>以此图为例，当读取行地址操作结束时，存储在行中的数据被其元件的放大器提取出来，我们将这些放大器用作寄存器，读取的行地址数据被放入寄存器中，可以支持连续的列操作读取，如上图的R/W circuits&amp;latchs</p>
<h4 id="同步随机存储器（SDRAM）-synchronous-DRAM"><a href="#同步随机存储器（SDRAM）-synchronous-DRAM" class="headerlink" title="同步随机存储器（SDRAM）(synchronous DRAM)"></a>同步随机存储器（SDRAM）(synchronous DRAM)</h4><p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174713.png style="zoom: 67%;" /></p>
<p>所有操作和时钟同步（时序产生了RAS，CAS信号）</p>
<ol>
<li><p>通过模式寄存器写入控制信息选择模式</p>
</li>
<li><p>使用缓冲寄存器（R/W锁存器）保存一行的信息，可用来读取连续的行位置，如图中的列地址计数器，在每个时钟上升沿响应，并将递增的列地址对应的数据放到缓冲寄存器上</p>
</li>
<li><p>刷新计数器，同样响应时钟上升沿，用来以读操作连续的刷新位信息</p>
</li>
</ol>
<h5 id="突发传输-burst-opration"><a href="#突发传输-burst-opration" class="headerlink" title="突发传输(burst opration)"></a>突发传输(burst opration)</h5><p>内存可以<strong>连续</strong>快速地传输多个数据单元，而不需要为每个单元单独发送地址和控制信号，从而提高数据传输效率，<strong>使用块传输</strong><br>SDRAM使用<strong>模式寄存器(mode register)</strong>，存储相关信息解决</p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174740.png></p>
<p>如时序图</p>
<p>时钟连续两次上升沿之间的时间作为一个周期时间</p>
<p>首先RAS花费一个周期锁存行地址，再使用两个周期激活对应的行。</p>
<p>接下来CAS花费一个周期锁存列地址，再花费一个周期将数据放到数据线上，并以时钟上升沿为准，地址递增从而使连续的信息传送到数据线上。<strong>脉冲长度(pulse length)</strong> 表示一次操作的最大自增传输次数。因此，一旦一次操作的连续读或写次数超过脉冲长度，就需要重新寻址。</p>
<h4 id="延迟-latency"><a href="#延迟-latency" class="headerlink" title="延迟(latency)"></a>延迟(latency)</h4><p>对内存而言，是指请求数据传输到实际开始数据传输的时间间隔</p>
<p>对块传输中，延迟指传输块的第一个字所用的时间，是评估存储器传输性能的开销时间，在上述例子中，这个时间是5个周期</p>
<h4 id="带宽-bandwidth"><a href="#带宽-bandwidth" class="headerlink" title="带宽(bandwidth)"></a>带宽(bandwidth)</h4><p>每秒传输的字节或位的数量，可以理解为<strong>总线的传输速度与其宽度的乘积</strong>。与延迟共同决定了存储器的性能</p>
<h4 id="DDR-SDRAM"><a href="#DDR-SDRAM" class="headerlink" title="DDR SDRAM"></a>DDR SDRAM</h4><p>即双倍数据速率SDRAM，在时钟的上下沿都传输数据。对于常突发传输，其带宽基本翻倍</p>
<h4 id="DRAM的优劣"><a href="#DRAM的优劣" class="headerlink" title="DRAM的优劣"></a>DRAM的优劣</h4><p>优点：高密度(density)，低的成本<br>缺点：存储器访问时间长，易泄露，需要定时刷新</p>
<h4 id="习题-10"><a href="#习题-10" class="headerlink" title="习题"></a>习题</h4><p>1 . Comparing to SRAM, the main advantage of DRAM is<br>A. high speed B. non-volatile stored data C. high density D. easily controlled<br><em>C，此处选项可以仔细看看</em></p>
<p>2 . What are advantages and disadvantages of DRAM?<br><em>Advantages: High density, low cost</em><br><em>Disadvantages:Longer memory access time;Leaky, needs to be refreshed.</em></p>
<p>3 . 某一动态RAM芯片,容量为64K×1,除电源线､接地线和刷新线外,该芯片 的最少引脚数目应为多少?<br><em>64K=216,由于地址线引脚只引出一半,因此地址线引脚数为8｡数据线引脚数为1 (有的芯 片数据输入线与数据输出线是分开的,则数据线引脚数就为2)｡它有R/W信号,而没有CS 信号｡它有行地址选通信号RAS和列地址选通信号CAS｡综上所述,除电源线､接地线和 刷新线外,该芯片的最少引脚数目应为12｡</em><br><em>这道题bug很多，比如是否需要考虑时序及其引脚</em></p>
<h3 id="大容量存储器结构（注－大题）"><a href="#大容量存储器结构（注－大题）" class="headerlink" title="大容量存储器结构（注－大题）"></a>大容量存储器结构（注－大题）</h3><h4 id="静态存储器系统"><a href="#静态存储器系统" class="headerlink" title="静态存储器系统"></a>静态存储器系统</h4><p>速度快，成本高，位密度低</p>
<h5 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h5><p>当芯片的每个存储单元的位数小于存储区字长时，横向扩展</p>
<p>如用 1 M × 1 位存储芯片组成 1 M × 8 位的存储器</p>
<p>需要8块1M x1位的芯片，横向放置，每片输出一位，合起来就是8位</p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174804.png></p>
<p>8块芯片共用一个地址线，一次输出8位</p>
<h5 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法"></a>字扩展法</h5><p>芯片的容量小于存储器容量，纵向扩展</p>
<p>如用 256 K × 8 位芯片组成 1 M × 8 的存储器</p>
<p>首先得到地址线，再得到选片线，选片信号一般需要经过译码器来指向不同的芯片，而地址线则作用于被选中的芯片</p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174825.png><br><strong>注意总线的画法</strong><br>图示为横向的扩展，但其实现无关紧要，稍后给出既需要字扩展又需要位扩展的默认排列</p>
<h5 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h5><p>如用 512K × 8 位的存储器芯片组成 2M × 32 位的存储器</p>
<p><img src=https://raw.githubusercontent.com/lafaeier/PicBed/image/img/20241006174844.png></p>
<p>图示为应试步骤，注意$\frac{2\times 1024}{32}\times \frac{32}{8}=4\times 4=16$的格式<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241208114824.png><br><strong>注意输入/输出总线的箭头是双向的，注意地址总线和片选线要连接到每个元件上，注意要给出单个元件的图例，注意信号从0开始排列</strong></p>
<h5 id="按字节与按字编址"><a href="#按字节与按字编址" class="headerlink" title="按字节与按字编址"></a>按字节与按字编址</h5><p>唯一的不同在于容量的计算以及输出总线的接口数。</p>
<p>按字节的意思是一条地址数据对应着8bit=1Byte的数据量</p>
<p>而按字的意思是一条地址数据对应着其他的位的数据量，一般取决于题目</p>
<h4 id="动态存储器系统（了解）"><a href="#动态存储器系统（了解）" class="headerlink" title="动态存储器系统（了解）"></a>动态存储器系统（了解）</h4><p>位密度高，成本低，用电少，集成方式与静态几乎一致</p>
<h5 id="SIMM单列直插存储器模块"><a href="#SIMM单列直插存储器模块" class="headerlink" title="SIMM单列直插存储器模块"></a>SIMM单列直插存储器模块</h5><p>基于DRAM，适用于老系统<br>SIMM可以是单面的，也可以是双面的</p>
<h5 id="DIMM双列直插存储器模块"><a href="#DIMM双列直插存储器模块" class="headerlink" title="DIMM双列直插存储器模块"></a>DIMM双列直插存储器模块</h5><p>目前DIMM是内存分装的标准模式</p>
<h4 id="存储控制器"><a href="#存储控制器" class="headerlink" title="存储控制器"></a>存储控制器</h4><p>为异步DRAM提供周期刷新的指令，或为其他交互提供指令操作</p>
<h4 id="刷新开销-refresh-overhead"><a href="#刷新开销-refresh-overhead" class="headerlink" title="刷新开销(refresh overhead)"></a>刷新开销(refresh overhead)</h4><p>当内部正在刷新时，动态随机存储器不会响应读写的请求<br>静态存储器（SRAM）常用来构成cache或寄存器等，而动态随机存储器（DRAM）常用来构成内存（主存）。</p>
<h3 id="习题-11"><a href="#习题-11" class="headerlink" title="习题"></a>习题</h3><p>1 . CPU的地址总线<strong>16根</strong> (A15~A0,A0为低位),双向数据总线<strong>8根</strong> (D7 ~ D0),控制总线中与主存有关的信号有MREQ (允许访存,低电平有效), $R / \overline{W}$ 高电平为读命令,低电平为写命令) 主存地址空间分配如下: $0000_{H} ~ 3 FFF_{H}$ 为系统程序区,由只读存储芯片组成;4000H~ $4 FFF_{H}$ 为系统程序工作区,由SRAM组成; $6000_{H} ~ 9 FFF_{H}$ 为用户程序区,也由SRAM组成｡ 按字节编址｡现有如下存储器芯片:<br>– EPROM:8K×8位 (控制端仅有 CS) SRAM:16K×1位,2K×8位,4K×8位,8K×8位 请从上述芯片中选择适当芯片设计该计算机主存储器,画出主存储器逻辑框图,注意画出选 片逻辑(可选用门电路及3:8译码器74LS138)与CPU的连接,说明选哪些存储器芯片及选多少片｡<br><em>如下图所示，题目要求输出只能为8位，不够的需要自己平凑；还要求了总线数量，我们需要对地址空间分组，如下图：</em><br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241209113901.png></p>
<p><em>由此，前三位用来产生片选信号，而对于4000到4FFF区域的片选信号，由于会与001代表的3起头的地址空间重合，如使用其不需要的地址线A14平凑出一个新的片选信号</em><br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241209113918.png></p>
<p>2 . Consider a 16M×128 memory built by using 512K×16 memory chips. How many rows of memory chips are needed?<br>A. 8 B. 16 C. 32 D. 64<br> <em>C，16 M / 512 K=32</em></p>
<p>3 . Consider a 64M×16 memory built by using 512K×8 memory chips. How many memory chips are needed?<br>A. 32 B. 64 C. 128 D. 256<br><em>C</em><br> $\left(64 M^{<em>} 16\right) /\left(512 K^{</em>} 8\right)=256$</p>
<p>4 . Consider a memory can be accessed with 20-bit address. Its word length is 64-bit and it is word-addressable. Assume that we use 256K×8bit SRAM chip to constitute this memory.<br>（1）How many bytes can this memory store?<br> $2^{20} <em> 64 / 8 B=1 M </em> 8 B=8 MB$<br> （2）How many SRAM chips do we need?<br> $8 MB /\left(256 K^{<em>} 8 / 8 B\right)=8 MB / 256 KB=32 片$
 </em>注：先对齐输出位<em><br>（3）How many address pins do we need for chip select? Why? 因为每片芯片</em>内部有18位地址 (对应于256K个存储单元),所以,20位的地址中,低18位地 址直接接芯片的18位地址端,高2位地址通过2:4译码器作芯片选择｡<em><br>5 .  Assume that there are two types of static memory chips: 128K×8 bit (total 4 chips) and 512K×4 bit (total 2 chips). Please use these memory chips to implement a 512K×16 bit memory. Draw the figure of the memory organization.<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241209-113432.png><br><em>*注意：CPU的接口数为横向看去的最大容量对应的二进制值，不同块的片选则需要看各个分区纵向看去的块数对应的二进制值</em></em></p>
<h2 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h2><p>存储空间很更大，速度更慢，价格更低。<br>相比起上文提及的两个随机存储器，只读存储器是非易失的。由于其只读的限制，写入操作需要特殊的实现。</p>
<h3 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h3><h3 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h3><p>只能在生产时写入数据的存储器称为只读存储器（或ROM），如下图所示。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009172000.png><br>ROM在生产时根据一个决定存入信息模式的掩码决定存储单元接地与否。晶体管在被字线激活时，若是接地，则位线为置为0，反之为1。<br>由于未设置电容，读取后没有后续操作，且接地与否无法通过电路信号改变。</p>
<h3 id="PROM（可编程只读存储器）"><a href="#PROM（可编程只读存储器）" class="headerlink" title="PROM（可编程只读存储器）"></a>PROM（可编程只读存储器）</h3><p>不同于ROM，PROM将唯一一次的写入交给用户，用户通过高电流脉冲将存储单元中的熔丝熔断，使其置为1，其他未操作的单元保持原值0。综上，PROM支持一次用户的编程行为。</p>
<h3 id="EPROM（可擦除可编程只读存储器）"><a href="#EPROM（可擦除可编程只读存储器）" class="headerlink" title="EPROM（可擦除可编程只读存储器）"></a>EPROM（可擦除可编程只读存储器）</h3><p>其结构相似于ROM，但是p点的电路替换为特殊的晶体管，向内注入电荷以形成通路，反之将其暴露在紫外线下以擦除数据。这意味着必须通过物理手段擦除数据，且擦除范围极大，没有办法对单存储单元生效，暴露在紫外线时，全部的信息都会被擦除。</p>
<h3 id="EEPROM（电可擦除可编程只读存储器）"><a href="#EEPROM（电可擦除可编程只读存储器）" class="headerlink" title="EEPROM（电可擦除可编程只读存储器）"></a>EEPROM（电可擦除可编程只读存储器）</h3><p>需要不同的电压来实现擦除，写入，读取，其他的都是有优点，可以对点式的擦除数据。</p>
<h3 id="闪存"><a href="#闪存" class="headerlink" title="闪存"></a>闪存</h3><p>密度更高，只需要单一的电压就能实现擦除，读，写。功耗更低</p>
<h4 id="闪存卡"><a href="#闪存卡" class="headerlink" title="闪存卡"></a>闪存卡</h4><h4 id="闪存驱动器"><a href="#闪存驱动器" class="headerlink" title="闪存驱动器"></a>闪存驱动器</h4><p>相比于硬盘存储驱动器，容量较小，且成本高，但访问速度快，响应时间短，</p>
<h2 id="直接存储访问（DMA）"><a href="#直接存储访问（DMA）" class="headerlink" title="直接存储访问（DMA）"></a>直接存储访问（DMA）</h2><p>由于在CPU控制下的主存与I/O之间的信息交互需要大量开销，故提供一个专门的部件管理传输过程，称为直接存储器访问（DMA），此部件称为DMA控制器。<br>CPU将控制信息传递给DMA后就撒手不管了，直到DMA发送完成信号。详细见下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009172623.png style="zoom:67%;" /><br>当一块数据从主存传送到另一个磁盘时，CPU访问DMA中的寄存器，将地址和字数信息写入对应的区块，此后DMA将独立执行指定的操作。当传输完毕后，DMA将Done线记录和传输信息。</p>
<h2 id="存储器层次结构-Memory-Hierarchy-（注－）"><a href="#存储器层次结构-Memory-Hierarchy-（注－）" class="headerlink" title="存储器层次结构(Memory Hierarchy)（注－）"></a>存储器层次结构(Memory Hierarchy)（注－）</h2><p>由于一个存储器无法做到内存又大，访问速度又快，价格又便宜，密度又大，耗电又低，故尝试把所有的存储器视为一个集合的存储器，称之为存储器层次结构，让他有快速而大的特性，他具有多个存储级别，并确保大部分数据处理器需求保持在 FAST（er） 级别<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009183809.png><br>主高速缓存放置在CPU内核内部，称之为一级（L1）高速缓存，一个更大的速度稍慢的辅助高速缓存放置在L1和其他存储器之间（一般在CPU内核外部），称之为二级（L2）高速缓存，也放置在CPU内部。<br>每一级存储器的数据都可来自于上一级。<br><strong>其核心就是缓冲区</strong></p>
<h3 id="buffer（缓冲区）"><a href="#buffer（缓冲区）" class="headerlink" title="buffer（缓冲区）"></a>buffer（缓冲区）</h3><ol>
<li><p>作为一个更大更慢的存储器的子集存储器</p>
</li>
<li><p>对于每一级K，都可作为上一级K+1的缓冲区</p>
</li>
<li><p>所有的数据最终都存储在最后一级的存储设备内</p>
</li>
<li><p>数据在相邻的两级之间交换</p>
</li>
</ol>
<h3 id="习题-12"><a href="#习题-12" class="headerlink" title="习题"></a>习题</h3><p>1 . A memory hierarchy —-<br>A. limits programs’ size but allows them to execute more quickly<br>B. is a way of structuring memory allocation decisions<br>C. takes advantage of the speed of SRAM and the capacity of disk<br>D. makes programs execute more slowly but allows them to be bigger<br><em>C</em></p>
<h2 id="高速缓存-cache-（注－大题）"><a href="#高速缓存-cache-（注－大题）" class="headerlink" title="高速缓存(cache)（注－大题）"></a>高速缓存(cache)（注－大题）</h2><p>由层次结构，cache是一个速度极快但大小极小的存储器，他位于CPU及主存之间。术语上有<strong>高速缓存块（cache block）</strong> 以及高速缓存行（cache line/entries）<br>处理器发送读指令时，存储器中的信息加入cache，随后的交互都从cache中获得。当cache存满时，要求必须在cache中腾出一块空间以加入新增的信息。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009205717.png><br>在缓存中，数据以<strong>列(line)</strong> 的形式存储，一般一列存储一个块</p>
<h3 id="局部性-locality-of-refence"><a href="#局部性-locality-of-refence" class="headerlink" title="局部性(locality of refence)"></a>局部性(locality of refence)</h3><h4 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h4><p>最经执行的指令可能再次执行，加入cache；</p>
<h4 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h4><p>最近执行的指令附近的指令也可能再次被执行，加入cache；</p>
<h3 id="映射-mapping"><a href="#映射-mapping" class="headerlink" title="映射(mapping)"></a>映射(mapping)</h3><p><strong>映射关系</strong>：</p>
<ol>
<li>决定块被放置到cache的哪里</li>
<li>将指向主存的地址，转而指向cache，而不是直接以此访问cache<h4 id="直接映射-direct-mapping"><a href="#直接映射-direct-mapping" class="headerlink" title="直接映射(direct mapping)"></a>直接映射(direct mapping)</h4>主存块的编码模128后得到的值作为cache的地址，但128，256等的块会发生冲突，即使此时cache未满。</li>
</ol>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009214434.png style="zoom:50%;" /></p>
<p>cache中，一行就是一块。<br>在此中，作为访问主存中某个字的地址（共16位），分为三个部分：<strong>标志</strong>，<strong>块</strong>，<strong>字</strong>。<br><strong>标志（Tag,t）</strong>：用来写入高速缓存中，且用来决定是哪个能取模到此高速缓存地址的主存块被使用（一般共有32个），还用来比较需要的字是否在此处的cache中<br><strong>块（Block.r）</strong>：用来决定使用高速缓存的哪个部位（取模操作）<br><strong>字（Word,w）</strong>：从16位的块中选择一个CPU需要的字<br>综上，块中的二进制转十进制后取模（取模的数取决于cache能存储多少块），标志决定是哪个同模的块被取，字决定取哪个字。<br><strong>0.9以上的高速缓存命中率对高性能计算机至关重要</strong><br>可以依靠下图理解<br>t中存储的是商，r中存储的是模</p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011115600.png></p>
<p>下面给出例子<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：考虑一个由 128 行组成的缓存，每行16个词。主存储器有 64K 字。假设</span><br><span class="line">1.主存储器可通过 16 位地址寻址。</span><br><span class="line">总主内存块数=64K/16=4K=4096</span><br><span class="line">故有s=12;</span><br><span class="line">每块有16个字，故需要4位寻字，即为w</span><br><span class="line">128行表示s中留出7位在cache中寻块，即为r</span><br><span class="line">12-7=5，即为t</span><br></pre></td></tr></table></figure></p>
<h5 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h5><p>优势:简单，易于实施，便宜<br>缺点:块的位置固定，如果程序访问映射到同一行的 2 个块反复出现，缓存未命中率非常高</p>
<h4 id="相联映射-Associative-Mapping"><a href="#相联映射-Associative-Mapping" class="headerlink" title="相联映射(Associative Mapping)"></a>相联映射(Associative Mapping)</h4><p>从CPU接收到地址后，到cache中检索，cache中每个块维护一个12位的标志位（是上述的16位地址去除4位字后的结果），若检索到一样的标志，那么代表找到对应的块，再对应到字。<br>若未找到，则扔掉某个块（<strong>替换算法</strong>）（在cache已满时），再将12位的信息写入标志位中，再将块写入。<br>可以避免一个个检索带来的长时间消耗，使用并行检索（<strong>相联检索</strong>）。<br>是有两个组分：<strong>t和w</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009221831.png style="zoom:50%;" /></h2><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/1588438107c380c51efa9fe50d05bbf.png></p>
<p>如同上一个例子，12位的s填入t，w用来寻字</p>
<h5 id="评判"><a href="#评判" class="headerlink" title="评判"></a>评判</h5><p>优势:它为选择缓存提供了完全的自由，放置内存块的位置。<br>缺点:检查所有标签所需的复杂电路。</p>
<h4 id="组相联映射-set-associative-mapping"><a href="#组相联映射-set-associative-mapping" class="headerlink" title="组相联映射(set associative mapping)"></a>组相联映射(set associative mapping)</h4><p>是直接映射和相联映射的结合，cache被分为大小相同的组（d），每组存放一定数量的块（k），一个主存的块被映射到特定组（直接映射）的任意行（相联映射）。</p>
<p>由此，我们对主存的块数j取模于组数v。</p>
<p>二进制的k转十进制后取模（取模的数取决于cache能存储多少块）<strong>得到s</strong>，标志决定是哪个同模的块被取，字决定取哪个字。也就是说，主存中的块的编码决定了要求的字所在的块被存放到cache的哪里，额外的字线会决定取块中的哪个字；而s包含<strong>组数（d）</strong>，以及标志位<strong>s-d</strong>。之后，放入组的块进行相联映射，比较的是标志位。<br>如下图所示<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011192235.png><br>一般的，当k取2时，称之为<strong>2路组相联高速缓存</strong>。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对直接映射的例子而言，我们分配了12作为s的值，选取组相联高速缓存，则有组数d＝64，s－d＝6；</span><br></pre></td></tr></table></figure></p>
<h5 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h5><p>优势:解决了直接映射重复弹出cache与加入cache的问题，开销比相联映射低<br>弊:仍然需要并行比较，比较成本较高。硬件成本比直接映射高，比相联低</p>
<h4 id="过时-out-data-数据"><a href="#过时-out-data-数据" class="headerlink" title="过时(out data)数据"></a>过时(out data)数据</h4><p>cache还维护一个<strong>有效位(vaild bit)</strong>，防止过时的数据被利用。当该位为0时，表示此值无效，访问在此发生时，表示miss；反之有效。<br>当cache从断电恢复时，其中的所有有效位为0，当一个块被装入cache中时，其有效位置为1。如果需要修改的块在cache中，则其有效位为0。只有当有效位为1时，才能从中提取数据，防止提取到未修改的落时的数据。</p>
<h5 id="高速缓存一致性"><a href="#高速缓存一致性" class="headerlink" title="高速缓存一致性"></a>高速缓存一致性</h5><p>当主存中的数据需要传回磁盘中的时候，需要将cache中的新的数据写回主存中。在使用写回的系统中，需要如此的方法来保持主存与磁盘数据的有效性与一致性。</p>
<h3 id="替换算法-replacement-algorithm"><a href="#替换算法-replacement-algorithm" class="headerlink" title="替换算法(replacement algorithm)"></a>替换算法(replacement algorithm)</h3><p>即将块弹出cache中的选择算法。替换算法对直接映射没有意义，因为直接映射必须替换唯一的位置</p>
<h4 id="LRU（最近最少）"><a href="#LRU（最近最少）" class="headerlink" title="LRU（最近最少）"></a>LRU（最近最少）</h4><p>覆盖的块中最少被访问次数的块将被移除。cache为每个块添加一个2位的技术区域，每次访问发生时，被访问的块的技术区域置为0，反之+1。当存在一个值为3的块时，就将其移除。</p>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>先进先出</p>
<h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><p>依靠随机数排除块，有时比LRU有效</p>
<h4 id="（注）例子"><a href="#（注）例子" class="headerlink" title="（注）例子"></a>（注）例子</h4><p>现在我们假设要执行一个算法，这个算法需要主存，cache的参与：</p>
<script type="math/tex; mode=display">
A(0,i)=\frac{A(0,i)}{(\sum_{j=0}^{9}{A(0.j)}/10}</script><p>我们将这个算法拆开来<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SUM:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span> to <span class="number">9</span> <span class="keyword">do</span></span><br><span class="line">	SUM:=SUM+<span class="built_in">A</span>(<span class="number">0</span>,j)</span><br><span class="line">end</span><br><span class="line">AVG:=SUM/<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">9</span> down <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">A</span>(o,i):=<span class="built_in">A</span>(<span class="number">0</span>,i)/AVG</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>现在来看一眼主存配置和cache配置<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011192132.png><br>我们假设主存中每个块只存储了一个字（你可以理解为按块寻址）（<strong>因为我们的算法只需要一个字的参与，为了方便模拟块的进入与弹出，块中只存放一个字</strong>），块的阵列为4 $\times$ 10，如<strong>右侧内容</strong>所示，但此处排开了，依顺序为00，10，20，30，01，11，21，31，02，，，。cache有8块，同样每个块放置一个字。</p>
<h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p>因为cache有8块，故留出3位以取模<br>如下图所示(原图太大，此表格中一列表示循环步数+2)<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011193538.png><br>根据伪代码给出的步骤，要将值加入SUM，则访问字所在的块A(0,0)，此块加入cache，地址为000（二进制换算为0）；再访问A(0,1)，地址为100（二进制换算为4）；再访问A(0,2),地址为000，且标识符与A(0,0)不同，故弹出A(0,0)，加入A(0,2)，，，此后可自由推断，<strong>若标识符合，则不弹出，反之弹出</strong>。</p>
<h5 id="相联映射"><a href="#相联映射" class="headerlink" title="相联映射"></a>相联映射</h5><p>地址全取<br>如下图<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011194204.png><br>按相联映射的规则，取前图的标识码，依次取。当加入A(0,8)时，由于cache已满，弹出cache中<strong>最久未使用</strong>且最近的A(0,0)弹出，并将A(0,8)加入，到i=1时，由于A(0,9)是最久未被使用的，故替换，此后同理。此处cache的计数位应为三位。</p>
<h5 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h5><p>如下图，假设使用4路组相联高速缓存，故cache中只有2组，留最后一位为组别，前15位为标识位。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011195242.png><br>由于0打头的块的地址的最后一位都是0，故使用不了第二组了</p>
<h4 id="习题-13"><a href="#习题-13" class="headerlink" title="习题"></a>习题</h4><p>1 . By —- mapping technique, a main memory block can be placed into any cache block position.<br>A. direct B. associative C. set associative D. sequential<br><em>B</em></p>
<p>2 .  If a cache has a capacity of 16KB and a line length of 128 bytes, how many sets does the cache have if it is 2-way, 4-way, or 8-way set associative?<br><em>A</em></p>
<p>3 . A set-associative cache consists of a total of 64 blocks divided into 4-block sets. The main memory contains 4096 blocks, each consisting of 128 words. How many bits are there in a main memory address?<br>A. 21 B. 24 C. 19 D. 32<br><em>C</em></p>
<p>4 . A set-associative cache consists of a total of 64 blocks divided into 4-block sets. The main memory contains 4096 blocks, each consisting of 128 words. How many bits are there in each of the TAG, SET, and WORD fields?<br>A. 2,5,12 B. 12,2,5 C. 4,8,7 D. 8,4,7<br><em>D</em></p>
<p>5 . What are advantages and disadvantages of direct mapping?<br><em>Its advantages are: (1) Simple, easy to implement (2) Inexpensive</em><br><em>Its disadvantage is: fixed location for given block</em></p>
<p>6 . What are advantage and disadvantage of associative mapping?<br><em>Its advantage is that it gives complete freedom in choosing the cache location in which to place the memory blocks.</em><br><em>Its disadvantage is that it requires complex circuitry to examine the tags of all cache blocks in parallel.</em></p>
<h3 id="高速缓存命中-Hit"><a href="#高速缓存命中-Hit" class="headerlink" title="高速缓存命中(Hit)"></a>高速缓存命中(Hit)</h3><p>CPU本身不知道cache的存在，他只会发送信号，而cache拿取到信号后则会进行判断</p>
<h4 id="读或写命中（read-or-write-hit）"><a href="#读或写命中（read-or-write-hit）" class="headerlink" title="读或写命中（read or write hit）"></a>读或写命中（read or write hit）</h4><p>当读写操作的对象块存储在cache中时，直接在cache中读写，这称之为读或写命中。</p>
<h5 id="读操作-1"><a href="#读操作-1" class="headerlink" title="读操作"></a>读操作</h5><p>上文提到，读的字的块在cache中时，直接在cache中读取。</p>
<h5 id="写操作-1"><a href="#写操作-1" class="headerlink" title="写操作"></a>写操作</h5><p>若块不在cache中，则将块加入cache。</p>
<h6 id="直接写-write-through"><a href="#直接写-write-through" class="headerlink" title="直接写(write through)"></a>直接写(write through)</h6><p>写操作同步于cache和主存之间。</p>
<h6 id="写回-write-back"><a href="#写回-write-back" class="headerlink" title="写回(write back)"></a>写回(write back)</h6><p>写操作只在cache中进行，并使用特殊的位表示信息是已更新且可用的，如<strong>修改位(dirty)</strong>。当这个块移出cache中时，再对主存修改。</p>
<h5 id="直接写和写回的比较"><a href="#直接写和写回的比较" class="headerlink" title="直接写和写回的比较"></a>直接写和写回的比较</h5><p>直接写：</p>
<ol>
<li>优点<ol>
<li>使得数据在缓存和主存间始终保持一致，无论何时都能在两处读取到同样正确的信息</li>
</ol>
</li>
<li>缺点<ol>
<li>所有的写操作都要访问主存</li>
<li>拖延CPU处理其他信息<br>写回：</li>
</ol>
</li>
<li>优点<ol>
<li>快于直接写，时间花费更少</li>
<li>多次对缓存中的数据修改，但只需要最后一次修改主存的数据</li>
</ol>
</li>
<li>缺点<ol>
<li>主存中对应的数据是过时的，不可使用</li>
<li>需要在缓存中添加一位dirty，表示是否是修改的<h4 id="读或写失效-Miss"><a href="#读或写失效-Miss" class="headerlink" title="读或写失效(Miss)"></a>读或写失效(Miss)</h4><h5 id="读操作-2"><a href="#读操作-2" class="headerlink" title="读操作"></a>读操作</h5>对一个不在cache中字进行读操作，会造成一次读失效，然后包含字的块从主存拷贝到高速缓存中，再把字传入CPU。<br><strong>直接装入（早重启）(load through/realy restart)</strong>：字从主存中取出后直接送往CPU再装入缓存。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009210438.png style="zoom:67%;" /><h5 id="写操作-2"><a href="#写操作-2" class="headerlink" title="写操作"></a>写操作</h5><h6 id="不写分配-No-Write-Allocate"><a href="#不写分配-No-Write-Allocate" class="headerlink" title="不写分配(No-Write Allocate)"></a>不写分配(No-Write Allocate)</h6>直接在主存中修改数据<h6 id="写分配-write-Allocate"><a href="#写分配-write-Allocate" class="headerlink" title="写分配(write Allocate)"></a>写分配(write Allocate)</h6>块先加入缓存，再在缓存中修改数据<h3 id="命中率-hit-rate-和失效开效-miss-penalty"><a href="#命中率-hit-rate-和失效开效-miss-penalty" class="headerlink" title="命中率(hit rate)和失效开效(miss penalty)"></a>命中率(hit rate)和失效开效(miss penalty)</h3>cache提高性能的程度依赖于所请求的指令和数据在cache中找到的频繁程度。<br>由于CPU不知道cache的存在，而在存储器层次结构中每 $k_{i-1}$层都可以视为上一层的缓冲池，故可以把整个存储器层次结构视为一个存储器。<h4 id="命中"><a href="#命中" class="headerlink" title="命中"></a>命中</h4>即所需的数据和指令能在cache中找到，未找到则称之为失效。<h4 id="失效开销"><a href="#失效开销" class="headerlink" title="失效开销"></a>失效开销</h4>失效发生时，数据以及指令需要从低速存储器装入高速存储器，此额外的时间称之为性能开销，在这段时间内CPU暂停以等待数据，而发生失效时CPU等待数据的总时间称为失效开销。<script type="math/tex; mode=display">
t_{avg}=hC+(1-h)M</script>得到CPU的平均访问时间如上。其中，C是访问缓存需要的时间，M是访问主存需要的时间。<br>选取直接装入法或先写入cache再装入CPU会对M产生影响。<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5>若有一个计算机，访问cache需要时间r，访问主存需要时间10r；访问cache失效时转去访问主存，此时传输第一个字需要10r，随后的一块中的7个字需要7r，再访问cache需要1r。<br>故有失效开销：M＝19r<br>假设一个程序有100条指令与数据需要传输，命中率是0.95，则有无cache与有cache的时间对比<script type="math/tex; mode=display">
\frac{无cache}{有cache}＝\frac{100\times r}{100（0.95\times r+0.05\times r ）}</script>由此，发生失效时计算失效开销，否则按访问cache计算。<h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4>正如存储器结构涉及的那样，在CPU上添加两个一级（ $L_1$ ）高速缓存MDR，MAR，分别负责数据以及地址的传输。在某些高性能处理器上，还会存在一个二级($L_2$)高速缓存，其速度比一级慢，但其容量大于一级。<br>相比于此节涉及的CPU和主存之间的统一缓存，有以下优势<h5 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h5>使得访问的随机性更小，也更有聚集性；相比于统一的缓存，访问速度更快</li>
</ol>
</li>
</ol>
<h4 id="处理器芯片上的高速缓存"><a href="#处理器芯片上的高速缓存" class="headerlink" title="处理器芯片上的高速缓存"></a>处理器芯片上的高速缓存</h4><p>这里把二级缓存视为一个较小的主存，那么二级缓存的平均访问时间就是一级缓存的失效开销。假设指令与数据的命中率一致，则：</p>
<script type="math/tex; mode=display">
t_{avg}=h_1C_1+(1-h_1)(h_2C_2+(1-h_2)M)</script><p>此中，$h_1$表示一级缓存的命中率，$C_1$表示一级缓存的信息访问时间；$h_2$表示二级缓存的命中率，$C_2$表示二级缓存的信息访问时间；$M$表示二级缓存的失效开销；$h_2C_2+(1-h_2)M$是二级缓存的平均访问时间，也是一级缓存的失效开销。<br>一级缓存的失效率是$1-h_1$,在此基础上，二级缓存的失效率是$(1-h_1)(1-h_2)$，很小。</p>
<h4 id="其他改进（没讲）"><a href="#其他改进（没讲）" class="headerlink" title="其他改进（没讲）"></a>其他改进（没讲）</h4><h5 id="写缓冲区-write-buffer"><a href="#写缓冲区-write-buffer" class="headerlink" title="写缓冲区(write buffer)"></a>写缓冲区(write buffer)</h5><p>如同主存与磁盘或其他I/O设备之间的控制器DMA，在CPU与主存间也存在一个能提高CPU速度的元件：<strong>写缓冲区</strong>。<br>使用<strong>直接写</strong>时，写的数据内容存入写缓冲区，由于读操作必须先行，CPU需要等待读操作完成才能进行下一个操作，故一般需要与缓冲区中的写数据的主存地址与读比较，有则读取缓冲区中的数据，反之继续读，全部的读操作完成后才开始写操作。<br>使用<strong>写回</strong>时，cache替换的块同样需要写操作，可以把这个块装入缓冲区，其他操作同上。</p>
<h5 id="预取-prefetch"><a href="#预取-prefetch" class="headerlink" title="预取(prefetch)"></a>预取(prefetch)</h5><p>上面提过，当读操作发出时，必须等待其操作完成，此间CPU被暂停。为了避免暂停过程，提出预取：在数据被需要前，就把数据添加到cache中，可以用软件或硬件实现。但后果是，当预取操作后的读失效替换了预取的块时，开销就无故增加了。</p>
<h5 id="无锁定高速缓存"><a href="#无锁定高速缓存" class="headerlink" title="无锁定高速缓存"></a>无锁定高速缓存</h5><p>使用预取时若与其他操作在cache上发生冲突，代表响应失效，这时cache被锁定，无锁定高速缓存可以在响应失效时继续访问。</p>
<h3 id="习题-14"><a href="#习题-14" class="headerlink" title="习题"></a>习题</h3><p>1 . The effectiveness of the cache mechanism is based on a property of computer programs called —-<br>A. parallelism B. locality of reference C. make the common case fast D. forwarding<br><em>B，局部性原理，注意题意是缓存</em></p>
<p>2 . Which of the following manages the transfer of data between the cache and main memory?<br>A. compiler B. registry C. operating system D. hardware<br><em>D，Cache-主存系统完全由硬件管理</em></p>
<p>3 . If a cache has 64-byte cache lines, it takes —- cycles to fetch a cache line if the main memory takes 20 cycles to respond to each memory request and returns 2 bytes of data in response to each request.<br>A. 128 B. 320 C. 640 D. 256<br><em>C，这题出的莫名其妙</em></p>
<p>4 . In cache system, when a block is to be overwritten, it is sensible to overwrite the one that has gone the longest time without being referenced. This technique is called the —- replacement algorithm.<br>A. FIFO B. Random C. LFU D. LRU<br><em>D</em></p>
<p>5 . True or False? In a direct-mapped cache, it is sensible to use Random replacement policy when a line must be evicted from the cache to make room for incoming data.<br><em>In direct-mapped caches, there is no choice about which line to evict, since the incoming line can only be placed in one location in the cache.</em></p>
<p>6 . True or False? For a Write operation, the cache location and the main memory are updated simultaneously. This technique is called the write-through protocol.<br><em>T</em></p>
<p>7 . What are advantages and disadvantages of write through policy?<br><em>Advantage: Keeps cache main memory consistent at the same time.</em><br><em>Disadvantages:</em><br><em>(1) All writes require main memory access (bus transaction).</em><br><em>(2) Slows down the system - If the there is another read request for main memory due to miss in cache, the read request has to wait until the earlier write was serviced.</em></p>
<p>8 . What are advantages and disadvantages of write back policy?</p>
<h2 id="虚拟存储器（注）"><a href="#虚拟存储器（注）" class="headerlink" title="虚拟存储器（注）"></a>虚拟存储器（注）</h2><p>当CPU的可寻址空间大于主存时，一般的主存无法满足CPU的要求，这时就需要虚拟存储器。CPU正在需要的部分存放在主存，其余放置在虚拟存储器（一般是辅助存储器，如磁盘）。当CPU引用了一个数据或指令时，会发出<strong>虚拟地址</strong>（也叫虚拟地址），<strong>存储器管理部件（MMU）</strong>（MMU一般放置在CPU中） 会比较此虚拟地址对应的数据是否在主存中，若在主存中，则转换为物理地址；反之，则通知CPU把数据从磁盘传输到主存中。<br>注：虚拟存储器指虚拟主存，是一种抽象概念，而不是特指磁盘。<br>如下图所示：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241021231127.png></p>
<h3 id="覆盖（Overlaying）"><a href="#覆盖（Overlaying）" class="headerlink" title="覆盖（Overlaying）"></a>覆盖（Overlaying）</h3><p>是一种用于内存管理的技术，通常在物理内存有限时使用。程序被分成若干部分（称为“段”或“覆盖区”），并且在程序执行时，根据需要动态加载某些段，而不是将整个程序一次性加载到内存中。<br><strong>使用了局部性原理</strong><br>通过覆盖技术，程序员可以在有限的内存资源下运行大规模程序，但手动管理这些段的调度和加载过程非常繁琐，因此该方法在现代系统中不常用。</p>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>当MMU确定需要把数据从硬盘传输到主存时，把硬盘中的数据规划为<strong>页</strong>（与块对应），页的大小一般为2K到16K个字节。<br>CPU产生的虚拟地址，被解释为<strong>虚拟页号(virtual page number)</strong> 和<strong>偏移值(offset)</strong>（用来在大小为page size的空间中找寻对应的字节或字）。还在<strong>主存</strong>维护了一个<strong>页表(page table)</strong>，用来指示页所在的主存地址(从虚存映射)（也可以称为<strong>物理页号PPN</strong>），此外，还有一个<strong>页表基址寄存器（page table base register）</strong>，用来存储页表的起始地址；主存按页的大小分划为<strong>页帧(page frame)</strong>。<br>页表存储了<strong>页表项(page table entry)</strong>，包含：</p>
<ol>
<li><strong>页帧码(page frame number)</strong>，用于找到页帧的地址，或一个指向磁盘的地址，表示虚拟页目前不在主存，而是磁盘</li>
<li>有效位：表示该页是否有效</li>
<li><strong>修改位(modify bit)</strong>：表示该页是否被使用过</li>
<li><strong>使用位(use bit)</strong>：表示该页最近是否被用过，用来评判活跃以便替换</li>
<li><strong>访问控制位(Accress Control bit)</strong>：表示读写等操作的控制位<br>根据给出的虚拟页号和页表基址寄存器得到映射的页表的起始地点，可以直接按索引找到这个页在页表中的位置（直接映射：虚拟页号到实际页号），再通过这个位置拿到页在主存中的地址（<strong>页帧</strong>），然后根据偏移值拿到对应页帧中需要的那一个字（或字节）。<br>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241021231212.png style="zoom:67%;" /><br>注：页表中不存储页号，因为可以按虚拟地址直接访问。<h4 id="转换监视缓冲区（TLB）"><a href="#转换监视缓冲区（TLB）" class="headerlink" title="转换监视缓冲区（TLB）"></a>转换监视缓冲区（TLB）</h4>MMU中存在转换监视缓冲区，用来存放那些最近被使用的页的表项（因为页表太大而存放在主存中）（相联映射：虚拟页号到TLB的相联）。<br>TLB的状态信息需要与页表时刻保持一致，当操作系统修改页表中的内容时，同把TLB中对应的项置为无效。<br>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241021231945.png style="zoom:67%;" /><br>注：TLB需要空间存储页码，因为不按顺序存储，且需要一一比对。<h5 id="TLB-Hit-amp-Miss"><a href="#TLB-Hit-amp-Miss" class="headerlink" title="TLB Hit&amp;Miss"></a>TLB Hit&amp;Miss</h5>当MMU在TLB中搜索页时，若找到，则提供物理地址，否则，在页表中搜索，同时更新TLB。<h4 id="页故障（page-fault）"><a href="#页故障（page-fault）" class="headerlink" title="页故障（page fault）"></a>页故障（page fault）</h4>当TLB和页表中都没有找到要求的页，表明发生<strong>页故障</strong>，此时要求此页的程序被中断，控制权移交给操作系统，操作系统把请求的页从磁盘拷贝到主存中，此间CPU可能转而去处理其他的程序。传输完毕后，中断的程序恢复运行。<br>若仅在TLB中未找到，<strong>则称为miss</strong><h4 id="弹出页"><a href="#弹出页" class="headerlink" title="弹出页"></a>弹出页</h4>当主存满了之后，需要弹出主存中的页，即页的替换。<br>一般有三种：</li>
<li>LRU</li>
<li>FIFO</li>
<li>Software (OS) implementation<h4 id="修改页"><a href="#修改页" class="headerlink" title="修改页"></a>修改页</h4>只考虑写回，直接写需要频繁的磁盘访问<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li>
<li>增加可地址空间</li>
<li>简化重定位：同一个程序可以在任意位置运行</li>
<li>减少启动程序的时间：并非所有代码和数据都需要全部放置到内存中</li>
<li>将程序员从覆盖（overlaying）的负担中解放出来<h4 id="内部碎片-internal-fragnebtation-（缺点）"><a href="#内部碎片-internal-fragnebtation-（缺点）" class="headerlink" title="内部碎片(internal fragnebtation)（缺点）"></a>内部碎片(internal fragnebtation)（缺点）</h4>当主存为每个页分配空间时，不能总是刚好分配完，主存最后一点不够一个页的空间也会塞入一个页，显然不是完整的页，称为内部碎片<h4 id="大容量的页的优点"><a href="#大容量的页的优点" class="headerlink" title="大容量的页的优点"></a>大容量的页的优点</h4></li>
<li>页表大小减小，TLB能存储更多的页表项</li>
<li>传输速度加快<h4 id="大容量的页的缺点"><a href="#大容量的页的缺点" class="headerlink" title="大容量的页的缺点"></a>大容量的页的缺点</h4><strong>内部碎片(internal fragnebtation)</strong> 问题加剧</li>
</ol>
<h3 id="习题-15"><a href="#习题-15" class="headerlink" title="习题"></a>习题</h3><p>1.Which one of the following about benefits of virtual memory is NOT true?<br>A. provide large address space B. relieve programmers from burden of overlays C. resolve internal fragmentation D. simplify relocation<br><em>C</em><br>2 .  In a paging system, which of the following is NOT true?<br>A. When a TLB miss occurs, the operating system must copy the requested page from the disk into the main memory<br>B. Transferring larger pages to or from secondary storage is more efficient than transferring smaller pages<br>C. Paging has a problem called internal fragmentation<br>D. “Write though” is not suitable for this system<br><em>A</em><br>3 . A processor uses 46-bit virtual addresses with 2MB pages. Which bits in the virtual address correspond to the “offset” field?<br>A. The most significant 34 bits B. The least significant 12 bits C. The most significant 25 bits D. The least significant 21 bits<br><em>D</em><br>4 . A page fault is —-<br>A. an attempt by the computer to run instructions stored on the hard disk<br>B. the process the computer uses to start itself<br>C. an error the computer makes when a device driver is missing<br>D. an out of memory error<br><em>A</em><br>5 . About TLB, which of the following is true?<br>A. It’s a small cache which consists of a small portion of the page table<br>B. When a TLB miss occurs, the operating system must copy the requested page from the disk into the main memory<br>C. TLB misses can only be handled in hardware<br>D. Its content is accessed based on the address<br><em>A</em><br>6 . Suppose the paging hardware with TLB has a 90 percent hit ratio. Page numbers found in the TLB have a total access time of 100 ns. Those which are not found there have a total access time of 200 ns. What is the average access time?<br>A. 100ns B. 110ns C. 190ns D. 200ns<br><em>B</em><br>7 . True or False? A Translation Lookaside Buffer (TLB) acts as a cache for the page table.<br><em>T</em><br>8 . What are advantages and disadvantages of choosing smaller page size in a paging system?<br><em>Advantages: A small page size will result in less wasted storage when a contiguous region of virtual memory is not equal in size to a multiple of the page size.<br>Disadvantages: (1) The size of the page table is inversely proportional to the page size. Memory can therefore be wasted by making the pages smaller.<br>(2) Transferring smaller pages to or from secondary storage, possibly over a network, is less efficient than transferring larger pages.</em><br>9 . Under what circumstances do page faults occur? Describe the actions taken by the operating system when a page fault occurs.<br><em>A page fault occurs when an access to a page that has not been brought into main memory takes place.</em><br><em>The operating system verifies the memory access, aborting the program if it is invalid. If it is valid, a free frame is located and I/O is requested to read the needed page into the free frame. Upon completion of I/O, the process table and page table are updated and the instruction is restarted.</em></p>
<h3 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h3><ol>
<li>给出page size，表示偏移量，即存储在其中的数据的位数。</li>
<li>给出映射方法</li>
<li>给出总的虚拟存储可寻址空间，根据偏移量求出虚拟页号</li>
<li>根据虚拟页号得到物理页号</li>
<li>根据物理页号和偏移量得到物理地址</li>
<li>现在对应到主存与缓存<br>注：所有的加减法都需要转换为二进制（从右到左）再计算<br>例如：物理地址12位，偏移量6位：00 1101，剩余转换为16进制是1E，则转换为2进制是01 1111 00 1101——0111 1100 1101——78D</li>
</ol>
<h2 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘有读写头，写入时将对应的磁体极化，当读取到变化的磁场时，就代表读取了数据1。<br>磁盘按同心圆分割为多个<strong>磁道(track)</strong>，磁道按圆心角划分为<strong>扇区(secor)</strong>，如下所示：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241023191025.png><br>每个磁道的扇区数一致<br>磁盘分单面与双面，单面需要一个读写头，双面两个。</p>
<h4 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h4><p>自同步时钟</p>
<h4 id="温切斯特-winchestaer-技术"><a href="#温切斯特-winchestaer-技术" class="headerlink" title="温切斯特(winchestaer)技术"></a>温切斯特(winchestaer)技术</h4><p>盘体和读写头放置在密闭的，去尘的空间内<br>优点：数据密度更大</p>
<h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><p>每个盘一个读写头，写头使用电流脉冲磁化材料，读头因为线圈运动发生电压改变</p>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>数据被存储在磁道上，在每个扇区的开始，有一个<strong>扇区头(sector header)</strong>，用来存储寻址信息，用来在选定的磁道上找到所需要的扇区（因为磁盘是先直接寻址，在顺序寻址，即要一个个比对）；此外，还有<strong>纠错码（ECC）</strong>，用来检测与纠正读写时发生的错误。扇区间还存在扇区间隙，用来区分不同的扇区。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241023191417.png><br>磁盘需要格式化，用来划分磁盘得到磁道与扇区，这通常也需要花费存储空间。<br>磁盘堆上所有的相同磁道和集合称为<strong>柱面(Cylinder)</strong>，多个读写头按盘面搭在同一个柱面上。<br>磁盘一般以盘面为读取单位。</p>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ol>
<li><strong>寻道时间(seek time)</strong>：把读写磁头移动到磁道所需的时间</li>
<li><strong>旋转延迟（等待时间）(rotational time)</strong>：读写磁头找到对应的扇区的时间。</li>
<li><strong>访问时间(access time)</strong>：前面两个时间之和；<h2 id="习题-16"><a href="#习题-16" class="headerlink" title="习题"></a>习题</h2>1 . The data of all tracks of a <strong>__</strong> can be accessed without moving the readwrite head.<br>A. surface B. platter C. sector D. cylinder<br><em>D</em><br>2 . According to the specifications of a particular hard disk, a seek takes 3ms between adjacent tracks. If the disk has 100 cylinders, how long will it take for the head to move from the innermost cylinder to the outermost cylinder?<br>A. 3ms B. 30ms C. 300ms D. 3000ms<br><em>C</em><br>3 . A hard disk with 5 double-sided platters has 2048 tracks/platter, how many movable heads does it have?<br>A. 5 B. 10 C. 20485 D. 204810<br><em>B</em><br>4 . When we read a block of data from a disk into memory, the seek time refers to —-<br>A. the time required to move the read-write head to the proper track<br>B. the time required to position the read-write head and transfer the data block C. the time required to rotate the correct sector under the head<br>D. none of the above<br><em>A</em><br>5 . The amount of time required to read a block of data from a disk into memory is composed of seek time, rotational latency, and transfer time. Rotational latency refers to —-<br>A. the time it takes for the platter to make a full rotation<br>B. the time it takes for the read-write head to move into position over the appropriate track<br>C. the time it takes for the platter to rotate the correct sector under the head<br>D. none of the above<br><em>C</em><br>6 . A hard disk with 5 platters has 2048 tracks/platter, 1024 sectors/track (fixed number of sectors per track), and 512 byte sectors. What is its total capacity?<br>A. 5G B. 10G C. 15G D. 20G<br><em>A</em></li>
</ol>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241209-231006.png></p>
<h1 id="指令集体系结构"><a href="#指令集体系结构" class="headerlink" title="指令集体系结构"></a>指令集体系结构</h1><h2 id="指令和指令序列"><a href="#指令和指令序列" class="headerlink" title="指令和指令序列"></a>指令和指令序列</h2><p>计算机必须能够具备执行四种基本指令：<strong>存储器和寄存器数据传送</strong>，<strong>数据算数和逻辑运算</strong>，<strong>程序序列化和控制执行</strong>，<strong>输入、输出发送</strong>。</p>
<h3 id="寄存器传送标记（RTN）"><a href="#寄存器传送标记（RTN）" class="headerlink" title="寄存器传送标记（RTN）"></a>寄存器传送标记（RTN）</h3><p>再此中，使用LOC表示存储单元地址，[ LOC ] 表示LOC的内容。R开头表示寄存器，箭头表示数据传输方向。<br>如：<code>R2&lt;-[LOC]</code>表示把LOC中的数据传入R2。<br><code>R4&lt;-[R2]+[R3]</code>表示把R2和R3中的数据取出，加法运算后写入R4。<br>以上为RTN表达式，式的右边为值，左边是单元名。</p>
<h3 id="汇编语言符号-assembly-language-notation"><a href="#汇编语言符号-assembly-language-notation" class="headerlink" title="汇编语言符号(assembly language notation)"></a>汇编语言符号(assembly language notation)</h3><p>如：<code>Load R2,LOC</code>表示把LOC中的数据写入R2。<br><code>Add R4,R2,R3</code>表示把R2与R3值相加写入R4。<br>使用<strong>助记符</strong>表示执行的操作。比如Load使用LD缩减。不同的处理器的汇编语言使用不同的助记符。</p>
<h3 id="RISC和CISC指令集"><a href="#RISC和CISC指令集" class="headerlink" title="RISC和CISC指令集"></a>RISC和CISC指令集</h3><p>在现代计算机的指令集设计中，有两种根本不同的方法。如果每条指令恰好占据存储器的一个字，那么可以获得更高的性能。<br>每条指令必须恰好放入一个字限制了其复杂度，减少了不同的指令数目，表示为<strong>精简指令集（RISC）</strong>。<br>相对于RISC的是<strong>复杂指令集（CISC）</strong>，他可以使用更复杂的指令，存储空间可以横跨多个存储器字。</p>
<h4 id="RISC指令集介绍"><a href="#RISC指令集介绍" class="headerlink" title="RISC指令集介绍"></a>RISC指令集介绍</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ol>
<li>每条指令一个字长</li>
<li>使用Load/store体系结构<ol>
<li>只能通过Load和Store指令访问存储器操作数</li>
<li>算数和逻辑运算中涉及的操作数必须在处理器寄存器中，或者其中一个操作数在指令字中被明确的给出。<h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><h6 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h6>Load将存储器中的数据加载到寄存器中，如上例所示：<br><code>Load 目的操作数，源操作数</code>或<code>Load CPU寄存器，存储单元</code>。<h6 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h6>我们称Add为<strong>三操作数指令</strong>或<strong>三地址指令</strong>，有格式<br><code>Add 目的操作数，源操作数1，源操作数2</code>。</li>
</ol>
</li>
</ol>
<h6 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h6><p>有格式<code>Store 源操作数，目的操作数</code>，其运行方向与Load相反。</p>
<h5 id="指令执行和线性序列-straight-line-sequence"><a href="#指令执行和线性序列-straight-line-sequence" class="headerlink" title="指令执行和线性序列(straight line sequence)"></a>指令执行和线性序列(straight line sequence)</h5><p>我们之前提及<strong>IR（指令寄存器）</strong> 与<strong>PC（程序计数器）</strong>。<br>PC包含将要执行的下一个指令的地址，当程序开始是，第一条指令必须放入PC，然后PC递增的读取以后的指令。这种执行的方法称为<strong>线性序列</strong>。<br>执行一条指令可以分为两个阶段：</p>
<ol>
<li><strong>取指令(fetch)</strong>：PC根据其中的下一条指令的地址在存储单元中取出指令，随后放入IR中</li>
<li><strong>指令执行(execute)</strong>：IR对指令检查并确定要执行哪种操作，随后处理器执行此操作<br>在这两个过程中，PC自增。<h5 id="转移-branching"><a href="#转移-branching" class="headerlink" title="转移(branching)"></a>转移(branching)</h5>也就是循环，如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101104415.png></li>
</ol>
<p>在左侧我们执行n次的加法，每次把值加入R2，最后存储到SUM中。<br>在右侧我们引入循环，使用R2记录循环的次数，LOOP内的内容为循环内容。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Subtract R2,R2,#1</span><br></pre></td></tr></table></figure><br>表示对R2的内容减一，其中<code>#1</code>表示值为1的常量。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Branch_if_[R2]&gt;0 LOOP</span><br></pre></td></tr></table></figure><br>就是一个典型的<strong>转移指令</strong>，这类指令将一个新的指令加载到PC中，而不是使PC自增的访问下一个指令。被加载到PC中的指令称为<strong>转移目标(branch target)</strong>，当循环条件满足时才进行转移，否则自增的执行下一个指令。</p>
<h2 id="指令格式-instruction-formats-（注）"><a href="#指令格式-instruction-formats-（注）" class="headerlink" title="指令格式(instruction formats)（注）"></a>指令格式(instruction formats)（注）</h2><p><strong>机器指令(machine instruction)</strong> 是说明处理器电路必须执行的动作以完成预期的指令。<br><strong>指令集(instruction set)</strong>：处理器能执行的指令的集合</p>
<h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><ol>
<li>包含<strong>操作码（Opcode）</strong>，表示要执行的操作，用二进制码表示。</li>
<li><strong>源操作数引用（Source operand reference）</strong>，指定指令所需的操作数</li>
<li><strong>结果操作数引用（result operand refence）</strong>,指定操作的结果存放的位置。<br> 源操作数和结果操作数可以存放在主存，虚存，寄存器，IO设备中</li>
<li><strong>下一个指令引用（next instruction refence）</strong>，表示在哪里找到下一个指令，即线性序列。<h3 id="指令表示"><a href="#指令表示" class="headerlink" title="指令表示"></a>指令表示</h3>在计算机中，指令以二进制的形式表示，指令被分为两部分：<strong>操作码</strong>和<strong>地址字段</strong>。<br>如下图:<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027210734.png><h3 id="指令设计准则"><a href="#指令设计准则" class="headerlink" title="指令设计准则"></a>指令设计准则</h3></li>
<li>短指令优于长指令</li>
<li>指令格式中有足够的空间表示所有的操作</li>
<li>地址栏位数有限<h3 id="地址字段格式（注－）"><a href="#地址字段格式（注－）" class="headerlink" title="地址字段格式（注－）"></a>地址字段格式（注－）</h3><h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4>只有一个操作码的指令<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027222227.png><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4>通常，可以隐含地理解第二个操作数是在处理器的累加器中<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027222449.png></li>
</ol>
<h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027222528.png><br>A1为结果操作数，A2为源操作数</p>
<h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027222916.png><br>A2,A3为源操作数，A1为结果操作数</p>
<h3 id="指令长度-instruction-length"><a href="#指令长度-instruction-length" class="headerlink" title="指令长度(instruction length)"></a>指令长度(instruction length)</h3><p>根据地址指令的数量，能够为每个操作码和地址指令的长度可能也不同。<br>指令长度一般固定，根据不同的规则区分不同的指令格式。</p>
<h3 id="做题-1"><a href="#做题-1" class="headerlink" title="做题"></a>做题</h3><p>给出指令长度与操作码长度，给出地址长度的数目：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027223901.png><br>此类型题从三地址指令向零指令地址过度，我们分配的是操作码，在此之外留意剩余空间是否能容纳指令地址：</p>
<h4 id="三地址指令-1"><a href="#三地址指令-1" class="headerlink" title="三地址指令"></a>三地址指令</h4><p>地址为4位，三个地址位共12位，剩下左边4位表示opcode，得到<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027225211.png><br>第二个16进制字符的二进制由0000到1101,表示15个三地址指令</p>
<h4 id="二地址指令-1"><a href="#二地址指令-1" class="headerlink" title="二地址指令"></a>二地址指令</h4><p>我们需要一个特征区分三地址和二地址，在上一个步骤中，前4位不可改变，后8位无意义，需要留给其他指令格式，所以要取左侧第5~8位的某个序列固定地表示现在是二地址，故使用1111表示二地址，即前4位都是1<br>现在剩下右侧8位，我们逐个分配给14个二地址<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027224308.png></p>
<h4 id="一地址"><a href="#一地址" class="headerlink" title="一地址"></a>一地址</h4><p>和上文一致，我们使用1110和1111表示一地址，即前6位都是1<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027225522.png></p>
<h4 id="零地址"><a href="#零地址" class="headerlink" title="零地址"></a>零地址</h4><p>零地址不需要地址字段，全部分配即可<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241027230156.png>完成。</p>
<h2 id="寻址方式-addressing-modes-（注－）"><a href="#寻址方式-addressing-modes-（注－）" class="headerlink" title="寻址方式(addressing modes)（注－）"></a>寻址方式(addressing modes)（注－）</h2><p>如下图，RISC风格的寻址方式有6种：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101104449.png><br>现在逐个介绍</p>
<h3 id="寄存器方式"><a href="#寄存器方式" class="headerlink" title="寄存器方式"></a>寄存器方式</h3><p>在此前的例子中，我们使用$R_i$表示不同编号的寄存器，操作系统根据名称找到对应的寄存器</p>
<script type="math/tex; mode=display">EA=R_i</script><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>一次地址计算，空间占用小</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>寻址空间小</p>
<h3 id="变量与常量寻址方式"><a href="#变量与常量寻址方式" class="headerlink" title="变量与常量寻址方式"></a>变量与常量寻址方式</h3><h4 id="绝对方式-absolute-mode"><a href="#绝对方式-absolute-mode" class="headerlink" title="绝对方式(absolute mode)"></a>绝对方式(absolute mode)</h4><p>假如我们用变量名声明了一些<strong>变量</strong>，那么我们可以通过这些变量名访问地址空间，如$NUM1$，可以表示此空间的地址而非单独的名称。<br>这些变量存储在主存中，即访问<strong>主存中的数据</strong>使用绝对方式。</p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><p>只有一次的内存访问</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>指令永远指向一个固定的地址，寻址空间有限</p>
<script type="math/tex; mode=display">EA=NUM1</script><h4 id="立即方式-immediate-mode"><a href="#立即方式-immediate-mode" class="headerlink" title="立即方式(immediate mode)"></a>立即方式(immediate mode)</h4><p>我们用<code>#200</code>，表示一个<strong>常量</strong>值（同时也是一个地址），使用时不再需要寻址而是直接拿取值。</p>
<h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><p>不需要访问地址即可获取数据</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>数的大小取决于地址的位数</p>
<h3 id="间接寻址方式-indirect-mode-和指针"><a href="#间接寻址方式-indirect-mode-和指针" class="headerlink" title="间接寻址方式(indirect mode)和指针"></a>间接寻址方式(indirect mode)和指针</h3><h4 id="主存间接寻址"><a href="#主存间接寻址" class="headerlink" title="主存间接寻址"></a>主存间接寻址</h4><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101105705.png></p>
<p>在我们之前给出的关于循环的例子中，我们简单的用文字描述了循环内部信息：在每个循环开始时，确定下一个数的地址，加载到$R_5$中，再加到$R_3$中。我们使用处理器寄存器来保存所有待加数的地址，每次遍历时，我们递增寄存器，把地址加载到$R_5$中，我们把$R_5$称为<strong>指针</strong>，因为它指向了下一个待加数的存储空间。<br>间接方式和指针的使用在程序设计中是一个重要且强大的概念，可以使用相同的代码对不同的数据进行操作，一般在CISC中使用。<br>我们使用<code>(R5)</code>来表示间接寻址，如<code>Load R2，（R5）</code>。</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>寻址空间大，若绝对寻址的大小为n，则间接寻址的大小为2n</p>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>需要计算两次地址</p>
<h4 id="寄存器间接寻址-register-indirect-mode"><a href="#寄存器间接寻址-register-indirect-mode" class="headerlink" title="寄存器间接寻址(register indirect mode)"></a>寄存器间接寻址(register indirect mode)</h4><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101110504.png></p>
<script type="math/tex; mode=display">EA=[R_i]</script><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><p>以较小的寻址空间表达了更大的寻址空间，减少访问时间<br>现在我们更新循环内容，如下图所示：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101104606.png><br>其中，我们使用<code>#NUM1</code>表示NUM1的地址，那么R4成为一个指向NUM1存储空间的指针。<br>我们再给出一个例子：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在c++中，使用</span><br><span class="line">int c=10;</span><br><span class="line">int *b=&amp;c</span><br><span class="line">int a=*b;</span><br><span class="line">则此代码的后一条可以被编译为：</span><br><span class="line">Load R2,b</span><br><span class="line">Load R3，（R2）</span><br><span class="line">Store R3，a</span><br></pre></td></tr></table></figure></p>
<h4 id="多级间接寻址-multilevel-indirect-addressing-："><a href="#多级间接寻址-multilevel-indirect-addressing-：" class="headerlink" title="多级间接寻址(multilevel indirect addressing)："></a>多级间接寻址(multilevel indirect addressing)：</h4><ul>
<li><strong>多级间接寻址</strong>：EA（有效地址）可以通过多层间接寻址得到。</li>
<li><strong>EA = […[A]…]</strong>：表示有效地址（EA）可以通过嵌套层级的方式，从一个初始地址A经过多个间接地址获取到最终的有效地址。</li>
<li><strong>地址中的间接标志位 (I bit)</strong>：在一个完整的字（word）地址中，有一位被用作间接标志位I。<ul>
<li><strong>如果I位为0</strong>，表示该字直接包含了有效地址（EA）。</li>
<li><strong>如果I位为1</strong>，则表示需要通过另一层间接寻址，继续寻找下一个地址。<h3 id="变址寻址方式-indexed-mode-和数组"><a href="#变址寻址方式-indexed-mode-和数组" class="headerlink" title="变址寻址方式(indexed mode)和数组"></a>变址寻址方式(indexed mode)和数组</h3>在变址寻址方式中，我们可以在获取地址后再加上偏移量，使得能够访问到以原地址为中心的，加上偏移量的地址。<br>有两种方式实现：<h4 id="偏移量作为常量给出"><a href="#偏移量作为常量给出" class="headerlink" title="偏移量作为常量给出"></a>偏移量作为常量给出</h4>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101104631.png><br>变址寄存器中存储原地址，偏移量作为常量给出<h4 id="偏移量存储在变址寄存器中"><a href="#偏移量存储在变址寄存器中" class="headerlink" title="偏移量存储在变址寄存器中"></a>偏移量存储在变址寄存器中</h4>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101104654.png><br>给出地址，然后以变址寄存器中的值作为偏移量<h4 id="变址寻址方式"><a href="#变址寻址方式" class="headerlink" title="变址寻址方式"></a>变址寻址方式</h4>如下例：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101104830.png><br>我们使用<code>8(R2)</code>表示对R2对应的存储空间<strong>向下</strong>移动8个字节<script type="math/tex; mode=display">EA = x + [Ri]</script></li>
</ul>
</li>
</ul>
<h4 id="基址寻址方式-base-index"><a href="#基址寻址方式-base-index" class="headerlink" title="基址寻址方式(base index)"></a>基址寻址方式(base index)</h4><h5 id="基址寄存器（base-register）"><a href="#基址寄存器（base-register）" class="headerlink" title="基址寄存器（base register）"></a>基址寄存器（base register）</h5><p>将偏移值存入基址寄存器，地址存储在变址寄存器中，如<code>(Ri,Rj)</code>。</p>
<script type="math/tex; mode=display">EA=R_i+R_j</script><h5 id="基址变址"><a href="#基址变址" class="headerlink" title="基址变址"></a>基址变址</h5><p>在<code>Ri,Rj</code>前加上常数偏移值，如<code>X(Ri,Rj)</code>。</p>
<script type="math/tex; mode=display">EA=x+R_i+R_j</script><h2 id="堆栈-stacks"><a href="#堆栈-stacks" class="headerlink" title="堆栈(stacks)"></a>堆栈(stacks)</h2><ol>
<li><strong>后进先出（LIFO）</strong>，弹出的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。有时也将堆栈称为<strong>下推栈</strong>。</li>
<li>堆栈一般使用主存的一部分组成</li>
<li>有一个特殊的处理器堆栈（在存储器中）<br>堆栈可以用来存储中断嵌套，子程序嵌套，递归，临时变量<h3 id="处理器堆栈"><a href="#处理器堆栈" class="headerlink" title="处理器堆栈"></a>处理器堆栈</h3>CPU中存在一个<strong>栈指针（SP）</strong> 寄存器来指向处理器堆栈的栈顶</li>
</ol>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101112730.png></p>
<p>故使用push时为<code>Subtract SP, SP, #4  Store Rj,(SP)</code></p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101112807.png></p>
<p>使用pop为<code>Load Rj,(SP)  Add SP,SP,#4</code>。+4时栈指针指向下一格。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101112824.png></p>
<h2 id="子程序（Subroutines）"><a href="#子程序（Subroutines）" class="headerlink" title="子程序（Subroutines）"></a>子程序（Subroutines）</h2><p><strong>子程序</strong>是一个封装好的程序块，考虑到我们常常有对不同的数据应用同一组指令的行为，所以实现子程序以应对这些情况。<br>是一种特殊的转移。<br>主程序在需要使用到子程序时，为了节省空间，我们在存储器中存放一份子程序的拷贝，下次使用时跳转到子程序的起始位置即可，此操作称为<strong>调用（Call）</strong>。<br>执行完子程序后，需要跳回原主程序的位置，此方法称为<strong>跳回（return）</strong>，为了能够回到原位置，使用Call时必须保存<strong>PC</strong>中的内容。</p>
<h3 id="子程序链接法（subroutine-linkage）"><a href="#子程序链接法（subroutine-linkage）" class="headerlink" title="子程序链接法（subroutine linkage）"></a>子程序链接法（subroutine linkage）</h3><p>上述的能够在计算机中调用子程序并从子程序返回的方法称为<strong>子程序链接法</strong><br>Call方法存储的PC的内容一般存储在<strong>链接寄存器（link register）</strong>。</p>
<h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><ol>
<li>将PC中的内容存储到链接寄存器中</li>
<li>转移到由Call指令指定的目标地址中<h4 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h4></li>
<li>转移到链接寄存器所保存的地址中</li>
</ol>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101114359.png></p>
<h2 id="CISC指令集"><a href="#CISC指令集" class="headerlink" title="CISC指令集"></a>CISC指令集</h2><p>CISC指令集不受限于<strong>load/store体系结构(load/store archecture)</strong>（此体系结构中只能对处理器寄存器中的操作数执行算数和逻辑运算），CISC的指令不需要放在一个单字中，一个指令可能在一个字中，也可能跨越多个字。</p>
<h3 id="Move指令"><a href="#Move指令" class="headerlink" title="Move指令"></a>Move指令</h3><p>相别于Load和Store，Move的格式为<code>Move destination,source</code>，两个操作数可以在主存中或寄存器中，但至少有一个在寄存器中。</p>
<h3 id="其他寻址模式"><a href="#其他寻址模式" class="headerlink" title="其他寻址模式"></a>其他寻址模式</h3><h4 id="自动增量和自动减量方式"><a href="#自动增量和自动减量方式" class="headerlink" title="自动增量和自动减量方式"></a>自动增量和自动减量方式</h4><h5 id="自动增量-autoincrement"><a href="#自动增量-autoincrement" class="headerlink" title="自动增量(autoincrement)"></a>自动增量(autoincrement)</h5><p>操作数使用<code>(Ri)+</code>，表示访问寄存器Ri中的有效地址<strong>后</strong>自增寄存器的内容，自增的大小为被访问的操作数大小相符的值。</p>
<h5 id="自动减量-autodecrement"><a href="#自动减量-autodecrement" class="headerlink" title="自动减量(autodecrement)"></a>自动减量(autodecrement)</h5><p><strong>先</strong>自减寄存器，再访问其中的操作数的有效地址，使用<code>-(Ri)</code><br>加减的顺序与入栈出栈的顺序有关，入栈是自减后移动数据，出栈是访问栈顶再自加</p>
<h4 id="相对方式-relative-mode"><a href="#相对方式-relative-mode" class="headerlink" title="相对方式(relative mode)"></a>相对方式(relative mode)</h4><p>使用PC代替通用寄存器（Ri）进行变址寻址，用<code>X(PC)</code>来表示距离PC所指向的地址距离X的指令。<br>可能更为灵活</p>
<h3 id="条件码-condition-codes"><a href="#条件码-condition-codes" class="headerlink" title="条件码(condition codes)"></a>条件码(condition codes)</h3><p>上文提及，CISC可以执行不限于算术与逻辑的运算，处理器执行的运算通常会产生如正数，负数或0等结果，处理器保存这些信息以便后续的条件转移指令执行。<br>处理器保存的这些位是<strong>条件码标志(flags)</strong>，他们存储在<strong>条件码寄存器或状态寄存器(status register)</strong>中，以下为4个常用的标志：</p>
<ol>
<li>N（负数）：若结果是负数则置为1，反之置为0</li>
<li>Z（零）：若结果是0则置为1，反之为0</li>
<li>V（溢出）：若结果溢出，则置为1，反之为0</li>
<li>C（进位）:若结果有一个进位输出则置为1，否则为0<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241101141957.png><br>在算术操作Subtract后，条件码重置，若n次循环没有结束，那么N与Z就都为0，则N+Z=0，不满足Branch的要求，回到循环起点。<br>对信号位V，有指令<code>Branch_if_overflow</code>判断是否溢出<br>对信号位C，有指令<code>Branch_if_carry</code>判断有进位<h3 id="习题-17"><a href="#习题-17" class="headerlink" title="习题"></a>习题</h3>1 . In which addressing mode the operand is actually present in instruction?<br>A. Immediate mode（立即数模式）；B. Direct mode（直接模式）；C. Register mode（寄存器模式）；D. Index mode（索引模式）<br><em>A</em><br>2 . In the following addressing modes, which does not belong to RISC style computers?（在以下寻址模式中，哪个不属于 RISC 风格计算机？）<br>A. absolute mode（绝对模式）；B. register indirect mode（寄存器间接模式）；C. index mode（索引模式）；D. indirect mode（间接模式）<br><em>C</em><br>3 . The condition flag Z is set to 1 to indicate（条件标志 Z 被设置为 1 表示）<br>A. the operation has resulted in an error（操作导致错误）；B. the operation requires an interrupt call（操作需要中断调用）；C. the result is zero（结果为零）；D. there is no empty register available（没有可用的空寄存器）<br><em>C</em><h2 id="RISC与CISC对比（注－）"><a href="#RISC与CISC对比（注－）" class="headerlink" title="RISC与CISC对比（注－）"></a><em>RISC与CISC对比</em>（注－）</h2><h3 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h3></li>
<li>寻址模式简单</li>
<li>所有指令在一个字内</li>
<li>总指令数少</li>
<li>寄存器上实现算术与逻辑运算</li>
<li>使用Load/Store架构传输</li>
<li>每个程序执行更多的指令<br>简单的指令使得设计更快的硬件变得简单<h3 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h3></li>
<li>更复杂的寻址方式</li>
<li>指令不局限于一个字</li>
<li>指令集有更多的指令</li>
<li>主存上实现算术与逻辑运算</li>
<li>Move架构传输</li>
<li>一个程序使用更少的数据<br>更复杂的指令使得设计快速的硬件变得困难<h3 id="习题-18"><a href="#习题-18" class="headerlink" title="习题"></a>习题</h3>1 . Which of the following is not the characteristic of RISC style?<br>A Simple addressing mode<br>B All instructions fitting in a single word<br>C Fewer instructions in the instruction set<br>D Arithmetic and logic operations that can be performed on memory operands as well as operands in processor registers<br><em>D</em><br>2 . Compare the RISC-style and CISC-style instruction set. Please list 3 differences at least.</li>
</ol>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241210-160640.png></p>
<h1 id="基本处理部件-basic-processing-unit"><a href="#基本处理部件-basic-processing-unit" class="headerlink" title="基本处理部件(basic processing unit)"></a>基本处理部件(basic processing unit)</h1><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><ol>
<li><strong>程序计数器（PC）</strong>，读取下一条指令的地址，一次一条</li>
<li><strong>指令寄存器（IR）</strong>，指令在IR中译码，保存该指令直到此指令被执行完成或中断。<h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3></li>
<li>IR取出PC的指令，如<code>IR &lt;-- [[PC]]</code></li>
<li>递增PC，如<code>PC &lt;-- [PC]+4</code></li>
<li>执行指令<br>前两部为<strong>取指令阶段</strong>，后一步为<strong>指令执行阶段</strong><h3 id="一般动作"><a href="#一般动作" class="headerlink" title="一般动作"></a>一般动作</h3>指令要求的动作一般包括：</li>
<li>读取一个给定的存储单元的内容，并装入处理器寄存器中</li>
<li>读取多个寄存器的内容</li>
<li>执行算术或逻辑运算，并将结果放入处理器寄存器</li>
<li>将处理器寄存器中的数据存入指定的存储单元中<h3 id="数据处理硬件-data-processing"><a href="#数据处理硬件-data-processing" class="headerlink" title="数据处理硬件(data processing)"></a>数据处理硬件(data processing)</h3><h4 id="大阶段"><a href="#大阶段" class="headerlink" title="大阶段"></a>大阶段</h4>如下图，将一次计算分布在一次长时间的时钟上升沿中<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111002406.png><h4 id="小阶段"><a href="#小阶段" class="headerlink" title="小阶段"></a>小阶段</h4>考虑到<strong>流水线(pipeline)</strong>，我们将一次计算分为多个小阶段，每个时钟周期缩短，但总计算时间不变<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111002431.png></li>
</ol>
<h2 id="指令的执行"><a href="#指令的执行" class="headerlink" title="指令的执行"></a>指令的执行</h2><p>再RISC中，处理器一般有5个硬件阶段，每条指令我们也分5步进行</p>
<h3 id="Load-1"><a href="#Load-1" class="headerlink" title="Load"></a>Load</h3><p>考虑 <code>Load R5,X(R7)</code>，有如下步骤</p>
<ol>
<li>从存储器中取出指令，PC自增</li>
<li>译码并读取R7</li>
<li>将X与R7相加</li>
<li>将上一步的值作为地址读取相应单元中的内容</li>
<li>将内容装入R5</li>
</ol>
<h3 id="Add-1"><a href="#Add-1" class="headerlink" title="Add"></a>Add</h3><p>对<code>Add R3,R4,R5</code>，有如下步骤</p>
<ol>
<li>取出指令并自增</li>
<li>译码读取R4，R5的值</li>
<li>计算二者的和</li>
<li><strong>空指令</strong>（即Add操作只需5步完成，但考虑到流水线的效率，增加为5步）</li>
<li>将结果装入R3</li>
</ol>
<h3 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h3><p>对<code>Store R6,X(R8)</code>，有步骤</p>
<ol>
<li>取出指令，自增</li>
<li>译码读取R6，R8</li>
<li>计算地址</li>
<li>将内容装入X（R8）中</li>
<li>空操作</li>
</ol>
<h3 id="统一"><a href="#统一" class="headerlink" title="统一"></a>统一</h3><ol>
<li>取出指令，自增</li>
<li>译码并读取寄存器中的内容</li>
<li>ALU</li>
<li>若包含存储器操作数，则读或写</li>
<li>如需要，将结果写入<br>因为X可以为0，实际中我们只需要实现变址操作，对其他操作，令X＝0即可</li>
</ol>
<h2 id="硬件组件-hardware-components"><a href="#硬件组件-hardware-components" class="headerlink" title="硬件组件(hardware components)"></a>硬件组件(hardware components)</h2><h3 id="寄存器文件-register-file"><a href="#寄存器文件-register-file" class="headerlink" title="寄存器文件(register file)"></a>寄存器文件(register file)</h3><p>我们把多个寄存器集合在一起，再搭配上接入电路使得能同时访问两个不同的寄存器，并使其内容出现在两个独立的输出端A和B中，形成了一个<strong>寄存器文件</strong>。<br>寄存器文件中还有一个数据输入端和地址输入端，前者用于写入数据，后者用于选择写入的寄存器</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="双端口寄存器文件-2-port-register-file"><a href="#双端口寄存器文件-2-port-register-file" class="headerlink" title="双端口寄存器文件(2-port register file)"></a>双端口寄存器文件(2-port register file)</h5><p>使用一组寄存器，接入双重的数据通路和接入电路<br>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111002522.png></p>
<h5 id="双存储器实现-two-single-ported-memeory-blocks"><a href="#双存储器实现-two-single-ported-memeory-blocks" class="headerlink" title="双存储器实现(two single-ported memeory blocks)"></a>双存储器实现(two single-ported memeory blocks)</h5><p>用两个存储区存储寄存器的副本，读写单独作用在每一个副本上<br>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111002540.png></p>
<h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>对于以上的每个指令，都需要ALU的参与，或是计算内容和，或是计算地址和<br>如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111002615.png></p>
<h3 id="数据通路-datapath"><a href="#数据通路-datapath" class="headerlink" title="数据通路(datapath)"></a>数据通路(datapath)</h3><p>指令处理包括<strong>指令读取和指令执行</strong>两个阶段，我们也将处理器划分为两个部分，分别处理两个不同的阶段。如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111002706.png></p>
<h3 id="指令执行"><a href="#指令执行" class="headerlink" title="指令执行"></a>指令执行</h3><p>指令执行包括：<strong>源寄存器，ALU，存储器访问，目的寄存器</strong>四个步骤</p>
<h5 id="Load-2"><a href="#Load-2" class="headerlink" title="Load"></a>Load</h5><p>把数据加载到寄存器中，第二阶段读取后一个地址，第三阶段与偏移值取和后作为存储器地址，第四阶段得到存储器数据，第五阶段存入对应的寄存器</p>
<h5 id="Add-2"><a href="#Add-2" class="headerlink" title="Add"></a>Add</h5><p>第二阶段读取后两个寄存器的内容，第三阶段求和，第四阶段直接输出，第五阶段写入</p>
<h5 id="Store-2"><a href="#Store-2" class="headerlink" title="Store"></a>Store</h5><p>第二阶段读取两个寄存器的地址，第三阶段计算和，第四阶段输出和代表的存储器地址和前一个寄存器中的数据，无第五阶段</p>
<h3 id="指令读取"><a href="#指令读取" class="headerlink" title="指令读取"></a>指令读取</h3><p>指令读取包括<strong>取指令(instruction fetch)</strong></p>
<h4 id="PC自增"><a href="#PC自增" class="headerlink" title="PC自增"></a>PC自增</h4><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111010359.png></p>
<p>如图，<strong>MuxINC</strong>选择正常的<strong>自增常数4</strong>或<strong>IR给出的偏移量</strong>，后者常用于中断或子程序的定位（即相对方式）。与PC原有的值相加后得到新的地址。<strong>MuxPC</strong>选择其加法器的结果或此前用<strong>链接存储器存储的返回的地址</strong>。当因为第一次进入中断或子程序而需要记录原地址时，就把原地址存储在寄存器<em>PC-Temp</em>中，再作为返回地址存储到链接寄存器中。</p>
<h4 id="IR存储指令"><a href="#IR存储指令" class="headerlink" title="IR存储指令"></a>IR存储指令</h4><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111011038.png></p>
<p>PC一般都被封装在一个<strong>指令地址发生器(instruction address generator)</strong> 中，因为小程序或中断，所以需要和外界的寄存器交换信息。<br>在存储器——处理器接口中，传入的存储器地址来源有二：PC传来的指向下一个指令的地址；某些指令要求的存储器地址<br>在取指令阶段，PC传入指令地址，对应的存储器数据传入IR，控制电路会检查IR中的指令，生成对应的控制信号等。IR会保存此指令直到完成该指令的所有阶段，此外，指令中涉及的立即数扩展到32位后被发向MuxB和PC</p>
<h2 id="指令的读取和执行操作（注－大题）"><a href="#指令的读取和执行操作（注－大题）" class="headerlink" title="指令的读取和执行操作（注－大题）"></a>指令的读取和执行操作（注－大题）</h2><h3 id="Add-3"><a href="#Add-3" class="headerlink" title="Add"></a>Add</h3><p>对指令<code>Add R3,R4,R5</code>，我们有如下操作步骤 </p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111193819.png></p>
<p>第一步：PC中的指令地址被取出，读取到存储器数据后装入IR，PC自增<br>第二步：对指令译码，如下图：</p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111194831.png></p>
<p>对本指令，前两个地址位是源寄存器，将R4中的内容提取到RA，将R5中的内容提取到RB<br>第三步：计算两个寄存器中的内容之和，存入RZ<br>第四步：将RZ中的值存入RY<br>第五步：将RZ中的值存入R3</p>
<p>考试中此题一般按操作步骤中的符号所示作答</p>
<p>剩下两个步骤：</p>
<h3 id="Load-amp-Store-注：第一步还应加上等待MFC"><a href="#Load-amp-Store-注：第一步还应加上等待MFC" class="headerlink" title="Load&amp;Store(注：第一步还应加上等待MFC)"></a>Load&amp;Store(注：第一步还应加上等待MFC)</h3><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241111195747.png><br>注：Store指令中，第四步的读取存储器应该为存储器数据<br>做题时注意要求和的值写入RZ，作为数据的值写入RM</p>
<h3 id="无条件分支"><a href="#无条件分支" class="headerlink" title="无条件分支"></a>无条件分支</h3><ol>
<li>与上文一致，老三套</li>
<li>译码</li>
<li><code>PC&lt;-[ PC ]+Branch offset</code></li>
<li>无</li>
<li>无<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3>以<code>Branch_if_[R5]=[R6] LOOP</code>为例</li>
<li>老三样</li>
<li>译码，<code>RA&lt;-[R5],RB&lt;-[R6]</code></li>
<li>对比寄存器中的值，如果满足条件，则<code>PC&lt;-[ PC ]+Branch offset</code></li>
<li>无</li>
<li>无<h3 id="Call（注意）"><a href="#Call（注意）" class="headerlink" title="Call（注意）"></a>Call（注意）</h3>以<code>Call_register R9</code>为例</li>
<li>老三样</li>
<li>译码，<code>RA&lt;-[R9]</code></li>
<li><code>PC-Temp&lt;-[PC],PC&lt;-[RA]</code></li>
<li><code>RY&lt;-[PC-Temp]</code></li>
<li><code>链接寄存器&lt;-[RY]</code><br><strong>注意：第三步要要对PC和PC_temp修改，第四步获得内容，第五步再写入</strong><h3 id="等候时间-wait-for-memory"><a href="#等候时间-wait-for-memory" class="headerlink" title="等候时间(wait for memory)"></a>等候时间(wait for memory)</h3>处理器-存储器接口提供了一个<strong>MFC(memory function completed)</strong> 信号，来表示向内存所求的数据是否已经找到。<br>若数据已在缓存，则此信号提前于向主存发送数据请求的信号产生；反之，当数据从主存中找到，转移到缓存中后，此信号才产生<h2 id="控制信号-control-signals"><a href="#控制信号-control-signals" class="headerlink" title="控制信号(control signals)"></a>控制信号(control signals)</h2>我们在这一节中丰富上一节的三个控件的信号元素。<br>首先我们对器件分类，分为需要信号控制和不需要信号控制的<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3>对于RA，RB，RZ，RY，RM，PC-Temp，这些寄存器需要一直启用，以存储每一步中传入的数据，即其必须不断地接受数据而不加选择，他们只受时钟信号控制<br>对于复用器和IR，PC等器件，部分功能的使用需要信号指示</li>
</ol>
<p>先给出图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118125735.png></p>
<p>从上往下看：<br>我们在指令的第五步中常常遇见需要把数据传入寄存器文件的操作，现在扩展寄存器地址输入接口。</p>
<ol>
<li>MuxC复用器有4个输入，接受<strong>三指令</strong>的第21－17位，其他<strong>指令</strong>的26－22位和<strong>Call</strong>指令指定的链接寄存器，还接受一个<strong>选择信号C_select</strong>（2位，表示范围为0－3）</li>
<li>当RF_wirte发出后，新数据才会装入所选择的寄存器中</li>
</ol>
<p>在对立即值的选择中：</p>
<ol>
<li>MuxB只有一个输入B_select，一位，选择RB或立即值</li>
</ol>
<p>在ALU的运算选择中</p>
<ol>
<li>假设输入ALU_op有k位，则其可以选择$2^k$种运算</li>
<li>条件信号(condition signals)，此前提及ALU会指示比较运算的结果</li>
</ol>
<p>在处理器-存储器接口处的选择中:<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118125807.png></p>
<ol>
<li>我们在此前提及，此接口只有两个地址输入：PC，RZ。这里使用MA_select选择两个中的一个。</li>
<li>使用MEM_read,MEM_write区分读写操作，当对应的信号传来时，才进行相应的读写操作。</li>
<li>对读指令，当MFC响应时，<strong>IR_enable</strong>才被激活，IR才读取指令；对读写操作，只有MFC响应时，才表示操作完成</li>
<li>对指令中时立即数，有三个扩展：16位无符号，16位有符号，26位特殊处理，需要两位的选择信号</li>
<li>有时RM会传来存储器数据，但有时也需要发出存储器数据到RY</li>
</ol>
<p>在指令发生器中：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118125829.png></p>
<ol>
<li>使用ING_select选择两种立即值</li>
<li>使用PC_select选择寄存器中的Return或自增</li>
<li>使用PC_enable，当其被激活时，MuxPC才传入数据到PC</li>
</ol>
<h2 id="硬件控制-Hardwried-control-（不考表达式）（注－）"><a href="#硬件控制-Hardwried-control-（不考表达式）（注－）" class="headerlink" title="硬件控制(Hardwried control)（不考表达式）（注－）"></a>硬件控制(Hardwried control)（不考表达式）（注－）</h2><p>此节研究处理器如何产生所需要的控制信号，有两种方法：<strong>硬件控制(hardwires control)和微程序控制(microprogramming)</strong>。<br>我们需要解析指令来了解需要哪些指令，还需要根据当前的步数来激活对应的指令，还需要根据ALU比较运算的结果决定数据的流向，还需要根据外界信号，比如中断来控制指令执行。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118125908.png><br><strong>指令译码器(instruction decoder)</strong> 解读指令的opcode和寻址模式信息，根据opcode的不同，设置不同的运算信号，根据寻址模式的不同使用不同的信号模式获得数据<br><strong>步计数器(step counter)</strong> 在每个对应的时钟周期内将对应周期的信号（$T_1$到$T_5$）激活，表示现在正在哪个周期<br><strong>控制信号发生器(control signal generator)</strong>，作为组合电路，立刻产出指令运行的必要信号</p>
<p>控制信号的设置取决于：</p>
<ol>
<li>步计数器</li>
<li>IR</li>
<li>计算结果或比较结果</li>
<li>外部输入信号<h3 id="数据通路控制信号"><a href="#数据通路控制信号" class="headerlink" title="数据通路控制信号"></a>数据通路控制信号</h3>我们尝试使用指令名，步骤名等拼凑出对应信号的表达式<br>如写入寄存器的操作均发生在第五步，那么<code>RF_write=T5(ALU+Load+Call)</code><br>但对于不需要步数对应的，例如立即数选择<code>B_select=Immediate</code>，其中Immediate表示所有在IR中使用立即数的指令。<h3 id="存储器延迟处理"><a href="#存储器延迟处理" class="headerlink" title="存储器延迟处理"></a>存储器延迟处理</h3>步计数器一般来说会自增的使信号按$T1$到$T5$的顺序发出，但是，若在某个步骤访问存储器发生miss的时候，这种自增的发送信号的方式就行不通了。我们需要在某个步骤禁用步计数器以等待实际步骤完成，我们使用控制信号<strong>WMFC</strong>来表示是否有写存储器操作，使用<strong>Counter_enable</strong>信号指示步计数器运作。若WMFC没有被激活，则后者enable信号被激活</li>
</ol>
<script type="math/tex; mode=display">Counterenable=\overline{WMFC}+MFC</script><p>对PC而言，只有当上一个操作结束，且PC_enable被激活的条件下，其才会自增。</p>
<h2 id="CICS风格的处理器（了解，待补充）"><a href="#CICS风格的处理器（了解，待补充）" class="headerlink" title="CICS风格的处理器（了解，待补充）"></a>CICS风格的处理器（了解，待补充）</h2><p>CICS风格的处理器将部件分离，各个部件使用<strong>总线</strong>连接，总线是连接多个设备的一组线路组成的能够使数据在两个设备之间传输。<br>为保证同一时刻只有一个设备驱动总线，设置一个<strong>三态门</strong>。</p>
<h2 id="微程序控制-microprogramming-（注）"><a href="#微程序控制-microprogramming-（注）" class="headerlink" title="微程序控制(microprogramming)（注）"></a>微程序控制(microprogramming)（注）</h2><p>使用软件而非硬件的方法生成控制信号的方法，这个软件存储在一个特殊的存储器中，作为微程序。它一般存储在<strong>处理器</strong>中的<strong>微程序存储器(micropogram memory)或下文的控制存储器中</strong> 中。<br>对每个信号，我们使用一个字中的一位来表示其状态。字长为信号数，称为<strong>控制字(control word)</strong> 或<strong>微指令(microinstruction)</strong>。对每一步操作，都会生成一个控制字存储在微程序存储器中，微程序存储器中还存在<strong>下地址</strong>，存储下一条微指令。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118130230.png></p>
<h3 id="长微指令-long-microinstruction"><a href="#长微指令-long-microinstruction" class="headerlink" title="长微指令(long microinstruction)"></a>长微指令(long microinstruction)</h3><p>缺点：<br>每个信号独占一位，利用率少</p>
<h3 id="分组微指令-Grouping-microinstruction"><a href="#分组微指令-Grouping-microinstruction" class="headerlink" title="分组微指令(Grouping microinstruction)"></a>分组微指令(Grouping microinstruction)</h3><p>将不能同时出现的信号放在一组，再通过二进制解码的形式缩减位数<br>优点：减少了每条微指令的大小<br>缺点：需要更多的解码电路</p>
<p>对一条指令的五步操作构成的微指令序列称为<strong>微程序(microprogram)或微例程(microroutine)</strong>，微程序存储在<strong>控制存储器(contrl store)</strong> 中。微程序控制部件存在一个<strong>微程序地址发生器(microinstruction address generater)</strong>，生成了IR存储的指令对应的微历程的起始地址以及借助$\micro PC$连续的访问下一个微指令，$\micro PC$（微程序计数器用于自增微指令地址发生器给出的初始起始地址，来产生下一条微指令的地址，下地址某位指示了微例程的结束，若此位为1，则地址发生器将地址返回到第一条微指令处。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118130044.png></p>
<h3 id="优缺点分析："><a href="#优缺点分析：" class="headerlink" title="优缺点分析："></a>优缺点分析：</h3><p>对硬件控制：</p>
<h2 id="1-操作速度快"><a href="#1-操作速度快" class="headerlink" title="1. 操作速度快"></a>1. 操作速度快</h2><ol>
<li>成本高</li>
<li>不灵活</li>
<li>需要极高的时间成本设计新增的功能<br>对微程序</li>
<li>成本低</li>
<li>灵活性高</li>
</ol>
<hr>
<ol>
<li>速度慢，延迟高</li>
</ol>
<h3 id="习题-19"><a href="#习题-19" class="headerlink" title="习题"></a>习题</h3><p>1 . In hardwired control unit, the required control signals are<br>determined by the following information except .<br>A. contents of the control step counter<br>B. contents of the condition code flags<br>C. contents of the instruction register<br>D. contents of the program counter<br><em>D，B是条件码</em><br>2 . In microprogram-controlled machines, the control signals<br>required by a machine instruction are generated by a .<br>A. control store<br>B. control word<br>C. microroutine<br>D. microinstruciton<br><em>D，注意此题，有些问题</em><br>3 . The microprograms for all instructions in the instruction set of<br>a computer are stored in a special memory called the .<br>A. memory controller<br>B. main memory<br>C. cache<br>D. control store<br><em>D</em><br>4 . In microprogram-controlled machines, the relationship between<br>the machine instruction and the microinstruction is .<br>A. a machine instruction is executed by a microinstruction<br>B. a microinstruciton is composed of several machine<br>instructions<br>C. a machine instruction is executed by a microprogram,<br>which is composed of several microinstructions<br>D. None of the above<br><em>D</em><br>5 . What are the advantage(s) and disadvantage(s) of hardwired<br>and microprogramed control?<br><em>The main advantage of hardwired control is fast operation.</em><br><em>The disadvantages include: higher cost, inflexibility</em><br><em>when changes or additions are to be made, and longer</em><br><em>time required to design and implement such units.</em><br><em>Microprogrammed control is characterized by low cost and</em><br><em>high flexibility. Lower speed of operation becomes a</em><br><em>problem in high-performance computers.</em></p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241211-160010.png></p>
<h1 id="流水线-pipelining"><a href="#流水线-pipelining" class="headerlink" title="流水线(pipelining)"></a>流水线(pipelining)</h1><h2 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h2><p>安排硬件架构使得多个操作可以并行的执行的方法，称为<strong>流水线</strong>。基本思想为：前一个指令未完全执行时就有一个新指令开始执行。<br>是多条(multiple)指令的重叠(overlap)执行<br><strong>管道深度(pipeline depth)</strong>：一个流水线的阶段数量<br><strong>延迟(latency)</strong>：在管道中执行一条指令总共需要多久<br><strong>吞吐量(througout)</strong>：每秒完成的指令数量<br><strong>管道段(pipe segment)</strong>：流水线的某个阶段<br>我们将一条指令分为五步：<strong>取指令，译码，计算，访存</strong>。按并行方式执行，如下图所示:<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118130307.png></p>
<h2 id="流水线结构（了解）"><a href="#流水线结构（了解）" class="headerlink" title="流水线结构（了解）"></a>流水线结构（了解）</h2><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241118130404.png></p>
<p><strong>段间缓冲器(interstage buffers)</strong></p>
<ol>
<li><strong>段间缓冲器B1</strong>向译码阶段提供一条新提取的指令</li>
<li><strong>指令译码</strong>得到控制信号的设置值，寄存器地址，从寄存器文件中取得内容放入段间缓冲器B2</li>
<li><strong>段间缓冲器B2</strong>向计算阶段提供寄存器文件中读取的两个操作数，寄存器标识符，立即值，用作子程序调用返回地址的递增后的PC值（PC自增，指向了下一条指令，即Call执行后必须存储的当前的指令地址）</li>
<li><strong>段间缓冲器B3</strong>保存ALU的计算结果，在译码阶段读取的寄存器文件的部分数据，PC自增后的值（以便应对Call后存储值）</li>
<li><strong>段间缓冲器B4</strong>向写回阶段提供一个即将写入寄存器文件的值，这个值可能为：ALU的结果，存储器访问的结果</li>
</ol>
<p>流水线并没有加速一条指令的执行，但他减少了指令的平均时间</p>
<h3 id="习题-20"><a href="#习题-20" class="headerlink" title="习题"></a>习题</h3><p>1.What is the first stage in a typical five-stage CPU pipeline?<br>A. Fetch B. Decode C. Compute D. Write<br><em>A</em><br>2.When multiple-instructions are overlapped during execution of program, then function performed is called<br>A. Multitasking B. Multiprogramming<br><em>D</em><br>C. Hardwired control D. Pipelining<br>3.Ture or False? Pipelining increases processor performance by decreasing the execution time of an instruction.<br><em>F</em></p>
<h2 id="流水线问题-pipeline-issues"><a href="#流水线问题-pipeline-issues" class="headerlink" title="流水线问题(pipeline issues)"></a>流水线问题(pipeline issues)</h2><p><strong>冲突(hazard)</strong>：引起流水线停止的情况<br><strong>数据冲突(data hazard)</strong>：一条指令要求修改后续指令读取的寄存器，写入寄存器文件的操作往往在第五步，而此时后续的指令或许已经执行到了访问寄存器文件的步骤，为了得到正确的结果，后面的那条指令必须等到前面的指令完成。<br><strong>指令冲突(instruction hazard)</strong>：可执行指令的延迟使得流水线停止<br><strong>结构性冲突(struct hazard)</strong>：两个正在执行的指令同时使用一个硬件资源的情况</p>
<h2 id="数据依赖性-data-dependency-（注－大题）"><a href="#数据依赖性-data-dependency-（注－大题）" class="headerlink" title="数据依赖性(data dependency)（注－大题）"></a>数据依赖性(data dependency)（注－大题）</h2><p>三种方法：停顿与气泡，转发，软件<br>对应上述的数据冲突，例如<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add R2,R3,#100</span><br><span class="line">Subtract R9,R2,#30</span><br></pre></td></tr></table></figure><br>解决此问题需要使用B1中存储的Subtract指令的源寄存器标识符和B2中的Add指令的目标寄存器标识符<br>具体时钟如下：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121195414.png><br>由于数据依赖，subtract必须<strong>停顿(stall)</strong>，Add指令向前移动，在B2中为Subtract留下一个<strong>空操作（NOP）</strong>，空指令完成计算，访存，写回三步后，就产生了上图所示的D段，即<strong>气泡(bubble)</strong>，此外，D中还需要一个周期来获取刚写入的数据，下一条指令只能停留在F阶段。</p>
<h3 id="操作数转发-operand-forwanding-（注）"><a href="#操作数转发-operand-forwanding-（注）" class="headerlink" title="操作数转发(operand forwanding)（注）"></a>操作数转发(operand forwanding)（注）</h3><p><em>c的结束到c的开始，m的结束到c的开始</em><br>我们使用<strong>操作数转发技术</strong>来缓解上述延迟。<br>我们仔细分析下气泡带来的延迟：Subtract指令暂停3个周期后继续执行，但实际上Subtract的源寄存器需要的最新信息在第三个周期就被Add计算出来放入了B3中。<br>因此，Subtract可以不被延迟，如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121195438.png></p>
<p>对此，我们更新图8：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121195504.png></p>
<p>添加了MuxA，选择使用读取到的值或是从RZ中得到的计算后的值，MuxB同理，为了对三指令同样适配，如<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add R2,R3,#100</span><br><span class="line">Or R4,R5,R6</span><br><span class="line">Subtract R9,R2,#30</span><br></pre></td></tr></table></figure><br>中间隔了一个指令，此时，RZ的内容移动到RY，且RZ也被更新，所以在MuxA和MuxB上再加一个选择：选择RY的值<br>时钟如下图：<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121195553.png></p>
<h3 id="用软件处理数据依赖性"><a href="#用软件处理数据依赖性" class="headerlink" title="用软件处理数据依赖性"></a>用软件处理数据依赖性</h3><p>编译器检测指令间的关联性，在第一个指令后插入多个流水的空指令，时间延迟与气泡一致。但这些空指令可以被之后的更优先度指令替代，这需要编译器的考量<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121195622.png></p>
<h2 id="存储器延迟（注－）"><a href="#存储器延迟（注－）" class="headerlink" title="存储器延迟（注－）"></a>存储器延迟（注－）</h2><p>存储器延迟（如Miss）时也会引起流水线停顿，一次存储器延迟可能长达十多个周期，后续的指令也需要等待此延迟，<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121195755.png></p>
<p>但不能使用数据依赖性中显示的那样，因为从存储器中读取的在第五个周期装入RY（B4）中才可用，为此，后面的指令必须延迟一个周期，如下图<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121195929.png></p>
<p>延迟译码阶段使得上一条指令的访存紧邻下一条指令的计算阶段</p>
<h3 id="软件处理"><a href="#软件处理" class="headerlink" title="软件处理"></a>软件处理</h3><p>编译器可以在这两条指令间插入一条有用的指令，若找不到这样一条可用的指令，则引入一个周期的停顿，再否则，引入NOP</p>
<h2 id="结构性冲突（资源冲突）"><a href="#结构性冲突（资源冲突）" class="headerlink" title="结构性冲突（资源冲突）"></a>结构性冲突（资源冲突）</h2><p>当取址和访存对同一个缓存操作时，需要为取指令和访问内存两步分别设置单独的缓存(separate caches)，以便两步能够同时进行</p>
<h2 id="转移延迟"><a href="#转移延迟" class="headerlink" title="转移延迟"></a>转移延迟</h2><p>在循环中，转移指令正在执行时，物理结构上的下一条指令执行，但逻辑上应该执行的指令没有执行</p>
<h3 id="无条件延迟"><a href="#无条件延迟" class="headerlink" title="无条件延迟"></a>无条件延迟</h3><p>转移指令在提取，译码，计算偏移量后得到转移地址，即在第四步开始时逻辑上的下一条指令开始执行，而这其中执行的两条物理指令分别执行了提取，译码和提取，这两个周期的延迟称为<strong>转移代价(branch penalty)</strong>，如图<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121200100.png></p>
<p>我们设法在译码阶段结束就输出转移目标地址，为此在译码阶段增加一个额外的加法器。图10中的加法器必须计算PC自增后的值，译码阶段的加法器直接提取指令某个字段计算转移地址，若译码阶段结束，证实指令是转移指令，则立即输出译码计算器的结果写入到PC中<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121201628.png><br>有如上结果，转移代价减少到一个周期</p>
<h3 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h3><p>对<code>Branch_if_[R5]=[R6]   LOOP</code>必须尽快判断出条件成立与否<br>在译码阶段引入一个比较器，同样不加思考的比较与计算，若确实是转移指令，则立刻转移</p>
<h3 id="转移延迟槽-branch-delay-slot"><a href="#转移延迟槽-branch-delay-slot" class="headerlink" title="转移延迟槽(branch delay slot)"></a>转移延迟槽(branch delay slot)</h3><p>在转移的基础上再尝试优化，我们将转移指令后面的指令称为转移槽，在转移槽中填充无关联性的指令或空指令，这是编译器的工作<br>抛弃原有转移延迟槽的内容是必须的，编译器要么装入允许的指令，要么填入空分支。<br>因为对后续指令的选择是对其的重排，把这种转移也称为<strong>延迟转移(delayed brancing)</strong><br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121204708.png></p>
<h2 id="习题-21"><a href="#习题-21" class="headerlink" title="习题"></a>习题</h2><p>1 . A(n) is a situation in which the pipeline is stalled because the data to be operated on are delayed for some reason<br><em>数据冲突</em><br>2 . —- is any condition in which either the source or the destination operands of an instruction are not available at the time expected in the pipeline.<br>A. control hazard B. data hazard C. structural hazard D. instruction hazard<br><em>B</em><br>3 . About the data dependency in a pipeline, which is not true in the following? A. Operand forwarding can handle all data dependencies without the penalty of stalling the pipeline.<br>B. Compiler can detect data dependencies and deal with them by analyzing instructions.<br>C. Compiler puts explicit NOP instructions between instructions having a dependency.<br>D. Even with a cache hit and operand forwarding, the data dependency between “Load R2, (R3)” and “Subtract R9, R2, #30” will also cause onecycle stall.<br><em>A</em><br>4.如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load R1, 4(R2)</span><br><span class="line">Sub R4, R1, R5</span><br><span class="line">And R6, R1, R7</span><br><span class="line">Or R8, R3, R4</span><br></pre></td></tr></table></figure>
<p>1）Identify all the data dependencies in the above instruction sequence. For<br>each dependency, indicate the two instructions and the register that causes<br>the dependency.</p>
<p>There are three data dependencies in this instruction sequence:<br>•<br>Sub instruction depends on Load instruction for register R1<br>•<br>And instruction depends on Load instruction for register R1<br>•<br>Or instruction depends on Sub instruction for register R4<br>注意的点：<br>部分指令的源寄存器和目的寄存器顺序颠倒，如Store，请注意</p>
<p>2）Assume that the pipeline does not use operand forwarding. Also assume that the only sources of pipeline stalls are the data hazards. Draw a diagram thatrepresents instruction flow through the pipeline during each clock cycle.<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121212648.png><br>遇到的问题可能有：</p>
<ol>
<li>题意要求不使用转发，也只有数据延迟</li>
<li>数据放入寄存器文件中后需要一个周期才能读取</li>
<li>前一个阶段完成后下一个指令才能继续此阶段<br>3）Assume that the pipeline uses operand forwarding. The pipeline hardware is<br>similar to figure 2 above, but add separate forwarding paths from the outputs<br>of stage 3 and stage 4 to the input of stage 3. Draw a diagram that represents<br>the flow of instructions through the pipeline during each clock cycle. Indicate<br>operand forwarding by arrows.<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241121212916.png><br>遇到的问题可能有：</li>
<li>题意要求使用转发</li>
<li>Load指令中R1的值最早四阶段才可以使用</li>
<li>一指令五阶段无转发通路，故And指令需要延后一个周期</li>
<li>二指令三阶段不能转发，够不到第四指令的三阶段</li>
</ol>
<h2 id="注：此章剩余内容不考"><a href="#注：此章剩余内容不考" class="headerlink" title="注：此章剩余内容不考"></a>注：此章剩余内容不考</h2><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/Screenshot_20241211-223601.png></p>
<h1 id="基本输入输出-Basic-input-output"><a href="#基本输入输出-Basic-input-output" class="headerlink" title="基本输入输出(Basic input/output)"></a>基本输入输出(Basic input/output)</h1><h2 id="访问-access-IO设备"><a href="#访问-access-IO设备" class="headerlink" title="访问(access)IO设备"></a>访问(access)IO设备</h2><h3 id="存储器-memory-映射I-O"><a href="#存储器-memory-映射I-O" class="headerlink" title="存储器(memory)映射I/O"></a>存储器(memory)映射I/O</h3><p>我们将IO设备视为主存的延伸，因此，IO与主存共享同一片寻址空间，IO也必须存在可以直接寻址的单元，我们把这些单元称为<strong>I/O寄存器</strong>，这种方法称为<strong>存储器映射I/O</strong>。<br>就像处理器不知道缓存的存在一样，可以把存储器映射视为处理器不知道I/O的存在，所有的代码也不区分I/O与否</p>
<p>不同于虚拟内存，存储器映射把IO视为主存的一部分，扩大了主存的内容；而虚拟内存则是一种分配主存资源的手段。即：讲究效率使用虚拟内存，讲究空间使用存储器映射</p>
<h4 id="评价-3"><a href="#评价-3" class="headerlink" title="评价"></a>评价</h4><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><p>任何可以访问内存的机器指令都可以用来将数据传输至 I/O 设备或从 I/O 设备传输数据。</p>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><p>宝贵的内存地址空间被用完</p>
<h3 id="分离式I-O-separated-IO"><a href="#分离式I-O-separated-IO" class="headerlink" title="分离式I/O(separated IO)"></a>分离式I/O(separated IO)</h3><p>与主存的寻址空间分离，使用<strong>特殊的机器指令</strong>，逻辑上有区别于总线的数据线，但不意味着物理上的数据线也是分离的</p>
<p>优点：I/O 设备连接与处理很少的地址线</p>
<h3 id="I-O设备接口-IO-device-interface"><a href="#I-O设备接口-IO-device-interface" class="headerlink" title="I/O设备接口(IO device interface)"></a>I/O设备接口(IO device interface)</h3><p>一个I/O设备通过<strong>I/O设备接口</strong>的电路连接到互联网络中，这个电路包含了<strong>数据(data)寄存器，状态(state)寄存器，控制(control)寄存器</strong>三种寄存器，可以被CPU直接访问<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241125230610.png></p>
<h3 id="习题-22"><a href="#习题-22" class="headerlink" title="习题"></a>习题</h3><p>1 . About memory-mapped I/O, which of the following is not true?<br>A. The I/O devices and the memory share the same address space.<br>B. Any machine instruction that can access memory can be used to transfer<br>data to or from an I/O device.<br>C. Valuable memory address space is used up.<br>D. I/O devices deal with few address lines.<br><em>D</em><br>2 . What is the difference between memory-mapped I/O and isolated I/O?<br><em>Memory-mapped I/O:</em><br><em>• The I/O devices and the memory share the same address space.</em><br><em>• No special commands for I/O. Any machine instruction that can access memory</em><br><em>can be used to transfer data to or from an I/O device.</em><br><em>• Valuable memory address space is used up.</em><br><em>Isolated I/O:</em><br><em>• Separate address spaces</em><br><em>• Special I/O instructions to perform I/O transfers.</em><br><em>• I/O devices deal with few address lines.</em></p>
<h2 id="程序控制I-O-program-controlled-IO"><a href="#程序控制I-O-program-controlled-IO" class="headerlink" title="程序控制I/O(program-controlled IO)"></a>程序控制I/O(program-controlled IO)</h2><p>我们通过软件实现自动读取键盘的数据，存储到主存后显示在屏幕上等一系列行为，这种方法称为<strong>程序控制I/O</strong><br>以键盘输入到显示在屏幕的过程为例，读取键盘并将数据传输到主存对速度的要求远远低于计算机将数据传送到屏幕时对速度的要求。这种速度上高度的差异就催生了<strong>同步机制(synchronization mechanism)</strong></p>
<p>一种同步机制是<strong>信号协议</strong>，每次显示或读取信息，都要等到信号传来才可以进行。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241125233540.png><br>对键盘：<strong>KBD_DATA</strong>作为8位寄存器，存储按下的对应的字符的ASCII码，<strong>KBD_STATUS</strong>是状态寄存器，其中的<strong>KIN</strong>表示是否有按键被按下，若有，则置为1.<br>处理器<strong>轮询（poll）</strong> KIN位，若是1，则读取KBD_DATA的内容。<br>对显示屏同理，<strong>DOUT位表示显示器准备好接收下一个数据</strong>。</p>
<h3 id="一个RISC的示例"><a href="#一个RISC的示例" class="headerlink" title="一个RISC的示例"></a>一个RISC的示例</h3><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241127161306.png></p>
<p>其中：<br>对键盘的输入</p>
<ol>
<li><strong>R2存储了指向主存中存储I/O设备数据的第一个存储单元的地址，每次累加以指向下一个节点</strong></li>
<li><strong>R3存储了指示存储结束的尾字符</strong></li>
<li><strong>R4存储了键盘的状态位，在此后的And指令中，与2以表示对KIN位状态的考察</strong></li>
<li><strong>R5存储了当前读取的字符，之后要存储到主存中去</strong></li>
</ol>
<hr>
<p>对显示的输出</p>
<ol>
<li><strong>R4存储了显示的状态位，与4表示对第三位的值是否为1的考察</strong></li>
<li><strong>R5将刚刚存储的数据再次传入到输出的数据寄存器中</strong></li>
<li>考察是否倒了结尾，否则继续读取</li>
</ol>
<h3 id="一个CISC的示例"><a href="#一个CISC的示例" class="headerlink" title="一个CISC的示例"></a>一个CISC的示例</h3><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241127162343.png><br>同上，不同点为CISC可以直接访问主存中的寄存器，包括其单个位数，以及其可以自增</p>
<h2 id="中断-interrupt-（硬件控制的I-O或中断控制的IO）"><a href="#中断-interrupt-（硬件控制的I-O或中断控制的IO）" class="headerlink" title="中断(interrupt)（硬件控制的I/O或中断控制的IO）"></a>中断(interrupt)（硬件控制的I/O或中断控制的IO）</h2><p>我们使用中断来避免程序控制的I/O陷入不断的循环中。<br>IO设备可以发送一个<strong>中断请求(interrupt request)</strong> 的信号给处理器，处理器中断当前指令的执行，转而响应中断要求执行<strong>中断服务程序(interrupt service routine)</strong>，这就是<strong>中断</strong>。</p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241127165353.png></p>
<p>处理器接收到中断请求时，必须发送信号表示此请求被执行，使得IO设备撤销中断请求的信号，这个信号称为<strong>中断确认信号（interrupt acknowledges）</strong>，或是向对应的IO设备传输数据。</p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241127164131.png></p>
<p><strong>中断延迟(interrupt latency)</strong>：从接收到中断请求信号到开始执行中断服务程序的延迟时间</p>
<h3 id="中断和子程序调用"><a href="#中断和子程序调用" class="headerlink" title="中断和子程序调用"></a>中断和子程序调用</h3><p>子程序是程序执行中常规的一部分，处理器预先知道子程序调用会涉及哪些寄存器的数据，比如家人让你去倒垃圾，你预先就知道了这个步骤会涉及哪个方面，从而可以不加保护的进行子程序调用，而只需要保存PC的内容<br>中断时突发的情况，为应对危险，处理器必须存储一些状态信息和PC（即<strong>返回地址</strong>，一般存储在指定的通用寄存器或处理器堆栈，即<strong>进程控制块(PCB)</strong>）来应对突发的修改。<br>处理器一般自动保存维持程序执行的最小信息量，为PC和<strong>处理器状态寄存器</strong>的内容，若需要保存额外的信息，需要手动指令给出。<br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241213115055.png></p>
<h4 id="保存类型"><a href="#保存类型" class="headerlink" title="保存类型"></a>保存类型</h4><ol>
<li>保存所有寄存器的内容</li>
<li>保存维持程序执行的最小信息量，为PC和<strong>处理器状态寄存器</strong>的内容。</li>
<li>复制处理器的寄存器组，中断服务程序使用另一个不同的寄存器组，称为<strong>影子寄存器</strong><br><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241127194608.png><br>如图，硬件部分负责存储PC和<strong>PSW（程序状态字）</strong>，软件部分负责存储其余的进程信息，处理中断，恢复自己存储的数据。<br>软件部分即程序部分，程序决定了要保留哪些信息，决定了中断服务程序的内容以及如何恢复其他数据，以及何时结束中断服务程序<h3 id="中断的允许与禁止-enable-and-disabling-interrupts"><a href="#中断的允许与禁止-enable-and-disabling-interrupts" class="headerlink" title="中断的允许与禁止(enable and disabling interrupts)"></a>中断的允许与禁止(enable and disabling interrupts)</h3><h4 id="单设备"><a href="#单设备" class="headerlink" title="单设备"></a>单设备</h4>某些时候我们希望程序按设定好的顺序执行，所以必须设定在某些时候，处理器不接受中断请求。<br>处理器的<strong>状态寄存器（PS）</strong> 中存在当前操作状态的信息，其中一位<strong>IE</strong>被分配为允许/禁止中断，IE为1时接受中断，反之全部忽略。IE也叫<strong>中断允许位(interrupt-enable bit)</strong>。<br>IO设备的控制寄存器中也有一位表示能否发出中断，此位为1时才会发出中断请求，即<strong>KIE,DIE</strong>。<br>处理器在处理一个中断前会自动禁止中断，PS中的IE的值为1，且被保存。之后IE被更新为0，直到执行中断返回指令时，IE才会变为之前保存的数据1<br>有顺序：<strong>发出中断请求-&gt;中止指令，存储信息-&gt;IE置为0-&gt;通知设备中断请求被识别-&gt;中断结束后恢复原数据</strong></li>
</ol>
<h5 id="习题-23"><a href="#习题-23" class="headerlink" title="习题"></a>习题</h5><p>1 . In an interrupt process, the usage of saving PC is .<br>A. to make CPU find the entry address of the interrupt service routine<br>B. to continue from the program breakpoint when returning from interrupt<br>C. to make CPU and peripherals working in parallel<br>D. to enable interrupt nesting<br><em>B</em><br>2 . What is interrupt? What advantage does Interrupt-Driven I/O have over<br>Program-Controlled I/O?<br><em>Solution:</em><br><em>An interrupt is an event that causes the processor to stop its current program</em><br><em>execution and switch to performing an interrupt service routine.</em><br><em>Interrupt-Driven I/O allows the computer to process other tasks while waiting</em><br><em>for I/O.</em></p>
<h4 id="多设备-multiple"><a href="#多设备-multiple" class="headerlink" title="多设备(multiple)"></a>多设备(multiple)</h4><p>若多台设备刚好在同一时间发出中断请求，处理器必须确定哪个仪器发出了哪个中断请求，必须确定获取哪个中断服务程序的起始地址等。</p>
<h5 id="多中断请求线-Multiple-Interrupt-request-Lines"><a href="#多中断请求线-Multiple-Interrupt-request-Lines" class="headerlink" title="多中断请求线(Multiple Interrupt-request Lines)"></a>多中断请求线(Multiple Interrupt-request Lines)</h5><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241213114437.png></p>
<p>快捷的根据优先级查找中断，但每个中断线后可能有多个IO设备</p>
<h5 id="轮询-polling"><a href="#轮询-polling" class="headerlink" title="轮询(polling)"></a>轮询(polling)</h5><p>为每个IO设备的状态寄存器添加一位<strong>IRQ</strong>，表示<strong>设备是否发出了中断请求</strong>。一旦一个中断请求被发出，我们就通过轮询此状态位来确定是哪个IO设备发出了中断请求</p>
<h5 id="向量中断-vector-interrupt"><a href="#向量中断-vector-interrupt" class="headerlink" title="向量中断(vector interrupt)"></a>向量中断(vector interrupt)</h5><p>为了减少轮询花费的时间，中断请求中会包含此设备的信息，或设备通过互联网络发送专门的代码标识自己。处理器的电路会从中得到设备提供的中断服务程序的地址。</p>
<p>多设备的中断服务程序的地址通常放置在主存的<strong>中断向量表(interrupt vector table)</strong> 中，表中每一项叫<strong>中断向量(interrupt vector)</strong>，他是指向中断服务地址的指针。</p>
<p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241213114943.png></p>
<h5 id="中断嵌套-interrupt-nesting"><a href="#中断嵌套-interrupt-nesting" class="headerlink" title="中断嵌套(interrupt nesting)"></a>中断嵌套(interrupt nesting)</h5><p>处理器处理中断时会停止接受其他的中断请求，但有时某些请求不能被延迟执行太久，我们必须在中断服务程序中执行另一个中断服务请求，这就是<strong>中断嵌套</strong>。<br>这意味着IO设备必须存在一个优先级，在处理低优先级时必须立刻处理高优先级，且必须维护一个堆栈存放各级的中断信息，存放必须在IE位设置成1之前。<br>处理器处理中断请求时，<strong>会把自身的优先级提升到正在处理的中断的优先级</strong>，遇到中断时，比较优先级后再确定是否要处理。</p>
<h5 id="同时中断-simultanenous-interrupt"><a href="#同时中断-simultanenous-interrupt" class="headerlink" title="同时中断(simultanenous interrupt)"></a>同时中断(simultanenous interrupt)</h5><p>当两个或多个中断同时到来时，需要选择其中一个中断执行。</p>
<ol>
<li>单个设备有单独的中断请求和确认线路，使用优先级判断。</li>
<li>几个设备共享一条中断请求线<h6 id="软件轮询-software-poll"><a href="#软件轮询-software-poll" class="headerlink" title="软件轮询(software poll)"></a>软件轮询(software poll)</h6></li>
</ol>
<p>处理器轮询IO设备的状态寄存器，轮询的顺序即是优先级的顺序</p>
<h6 id="硬件轮询-Daisy-chain菊花链-herdware-poll"><a href="#硬件轮询-Daisy-chain菊花链-herdware-poll" class="headerlink" title="硬件轮询(Daisy chain菊花链/herdware poll)"></a>硬件轮询(Daisy chain菊花链/herdware poll)</h6><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241213145721.png><br>所有IO设备被菊花链以链表的形式连接，距离处理器最近的优先级最高</p>
<h6 id="优先级组-priority-group"><a href="#优先级组-priority-group" class="headerlink" title="优先级组(priority group)"></a>优先级组(priority group)</h6><p><img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241213154926.png><br>将共享中断请求线的多个设备分成不同的优先级组。在这种方式下，首先确定优先级组的优先级顺序，当有中断请求时，先确定是哪个优先级组发出的请求，然后在该优先级组内部再采用其他方式（如软件轮询或硬件轮询）来确定具体的设备</p>
<h5 id="习题-24"><a href="#习题-24" class="headerlink" title="习题"></a>习题</h5><p>1 . n the process of determining which device is requesting an interrupt, the device identifies itself directly by sending a signal or a binary code to the processor. This approach is called<br>A. polling B. non-vectored interrupt C. vectored interrupt D. interrupt vector<br><em>D</em></p>
<p>2 . The following figure shows the interface of a keyboard. Write functions of (1) KIN  (2) KIRQ (3) KIE.</p>
<p><em>The KIN bit is the status flag for the processor to read to determine when a</em><br><em>character code has been placed in KBD_DATA. If KIN=1, then the character</em><br><em>has been in KBD_DATA, otherwise, KIN=0.</em><br><em>(2) The KIRQ bit is the status flag whether the keyboard is requesting an</em><br><em>interrupt. If KIRQ=1, it shows that the keyboard raises an interrupt,</em><br><em>otherwise, KIRQ=0.</em><br><em>(3) The KIE bit is the bit to control whether the keyboard can raise an interrupt.</em><br><em>If KIE=1, then the keyboard is placed into a mode in which it is allowed to</em><br><em>interrupt the processor whenever it is ready for an I/O transfer.</em></p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>我们在第八章就已经简单提及过DMA了，我们现在仔细讨论这个设备<br>假设处理器要把磁盘内容传到主存，需要把磁盘内容写入缓存，再写入寄存器，最后写入主存，故使用DMA避免复杂的操作。<br>DMA接管了主存和IO设备之间的数据传输，当传输完毕后，DMA向处理器发送中断，通知其收回总线的授权<br>CPU将信息传输到<strong>DMA controller（DMAC）</strong> 中，信息包括：<strong>数据在设备上的地址，数据在主存中的地址，传输的块的大小，传输方向，传输模式</strong></p>
<h3 id="DMAC"><a href="#DMAC" class="headerlink" title="DMAC"></a>DMAC</h3><p>DMAC会为传输<strong>提供内存地址，控制传输的信号，为连续的字递增内存地址，记录传输的次数</strong></p>
<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><ol>
<li><strong>brust突发</strong>，也叫块传输，应用于一次性大片传输。但会占用总线，CPU此时无法使用总线<br> 缺点：会使处理器在相对较长的时间内处于限制状态</li>
<li><strong>cycle steal周期窃取</strong>，每个周期占用一定的传输份额进行传输<br> DMA不断的获取总线的使用权限，但每次只传输一个字节的数据，直到所有数据被传输完毕</li>
<li><strong>Transparent Mode透明模式</strong>：只在处理器不执行有关总线的指令时才获取总线权限传输<br> 优点：处理器永远不会停止执行其程序<br> 缺点：电路可能会相当复杂<br>当DMA准备好要传输数据时，向处理器请求总线的使用权限，即发送<strong>BR(Bus Request)</strong> 信号，<strong>总线仲裁器(Bus arbiter)</strong> 处理申请总线使用的请求。一旦收到<strong>BG（Bus Grant）</strong> 的信号，DMA就可以开始工作了。</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="单总线，分离式DMAC-Single-bus-Detached-DMA-Controlle"><a href="#单总线，分离式DMAC-Single-bus-Detached-DMA-Controlle" class="headerlink" title="单总线，分离式DMAC( Single-bus, Detached DMA Controlle)"></a>单总线，分离式DMAC( Single-bus, Detached DMA Controlle)</h4><p>传输方向：IO-&gt;DMA,DMA-&gt;主存<br>CPU被中断两次</p>
<h4 id="单总线，集成式DMAC-Single-bus-Integrated-DMA-Controller"><a href="#单总线，集成式DMAC-Single-bus-Integrated-DMA-Controller" class="headerlink" title="单总线，集成式DMAC(Single-bus, Integrated DMA Controller)"></a>单总线，集成式DMAC(Single-bus, Integrated DMA Controller)</h4><p>能与多个IO设备同时交互且集成在一起，只使用一个总线<br>传输方向：DMA-&gt;主存<br>CPU被中断一次</p>
<h4 id="独立IO总线-Separate-I-O-bus"><a href="#独立IO总线-Separate-I-O-bus" class="headerlink" title="独立IO总线(Separate I/O bus)"></a>独立IO总线(Separate I/O bus)</h4><p>使用独立的总线，只要接口合适，可以支持所有的IO<br>传输方向：DMA-&gt;主存<br>CPU被中断一次</p>
<h3 id="习题-25"><a href="#习题-25" class="headerlink" title="习题"></a>习题</h3><p>1 . Which method bypasses the CPU for certain types of data transfer?<br>A. Software interrupts<br>B. Polled I/O<br>C. Interrupted-driven I/O<br>D. Direct Memory Access (DMA)<br><em>D</em><br>2 .  —- is used for high-speed block transfers directly between an external device and the main memory.<br>A. Program-controlled I/O<br>B. Interrupt-driven I/O<br>C. DMA approach<br>D. Event-driven<br><em>C</em><br>3 . Once the DMA controller obtains access to the system bus, it transfers one byte of data and then returns the control of system bus to the processor. This is<br>A. burst mode B. block mode C. cycle stealing mode D. transparent mode<br><em>C</em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.lafael.top">surtr lafael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lafael.top/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">https://www.lafael.top/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lafael.top" target="_blank">Hephaestus</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E5%86%85%E5%9F%BA%E7%A1%80/">课内基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/43cb6326cebfed66.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/78170818.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/08/c%E4%B8%8B%E5%A4%8D%E4%B9%A0%E4%B8%80%E8%A7%88/" title="c下复习一览"><img class="cover" src="https://raw.githubusercontent.com/lafaeier/PicBed/image/img/⚠_96172771_p1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">c下复习一览</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src="https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/78170818.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-03</div><div class="title">数据结构</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">surtr lafael</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lafaeier"><i class="fab fa-github"></i><span>今四,50,喜奔。</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lafaeier" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hamiltonlafael@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">(阴暗的爬行)陆地,太过干燥,无鳞,离群的同胞,我呼唤你,带你归巢(嘶吼)。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">计算机的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">计算机的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%83%A8%E4%BB%B6%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A1%AB%E7%A9%BA%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">功能部件（注－填空）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88memory%EF%BC%89%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">存储器（memory）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">主存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88secondary-storage%EF%BC%89"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">辅助存储器（secondary storage）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">运算器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.3.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%9A%E5%B0%8F%E6%95%B0%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BC%9A%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%80%BC%E8%80%8C%E5%8F%98%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">浮点数：小数点的位置会根据数值而变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.4.</span> <span class="toc-text">并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%EF%BC%88%E6%B3%A8%EF%BC%8D%E9%80%89%E6%8B%A9%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">历史（注－选择）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">第一代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3"><span class="toc-number">1.5.2.</span> <span class="toc-text">第二代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3"><span class="toc-number">1.5.3.</span> <span class="toc-text">第三代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E4%BB%A3"><span class="toc-number">1.5.4.</span> <span class="toc-text">第四代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">习题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97-Arithmetic"><span class="toc-number">2.</span> <span class="toc-text">算数运算(Arithmetic)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.</span> <span class="toc-text">数的表示及算数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85"><span class="toc-number">2.1.2.</span> <span class="toc-text">实际</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">有符号数加减法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E6%B3%A2%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8%EF%BC%88ripple-carry-adder%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">行波进位加法器（ripple-carry adder）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D%EF%BC%88LSB%EF%BC%89"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">最低有效位（LSB）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A7%E8%81%94"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">级联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">溢出检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%88%86%E6%9E%90"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">延迟分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-2"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.</span> <span class="toc-text">快速加法器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95-Carry-Lookahead-addition"><span class="toc-number">2.3.1.</span> <span class="toc-text">超前进位加法(Carry-Lookahead addition)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D-1"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">整体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%87%E5%85%A5%E9%99%90%E5%88%B6-Fan-In"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">扇入限制(Fan-In)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A7%E8%81%94-1"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">级联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-number">2.3.1.5.</span> <span class="toc-text">改进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E6%B3%A2%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.2.</span> <span class="toc-text">行波进位加法器与超前进位的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-3"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95-multipication-of-unsigned-numbers"><span class="toc-number">2.4.</span> <span class="toc-text">无符号数乘法(multipication of unsigned numbers)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%88%E5%88%97"><span class="toc-number">2.4.1.</span> <span class="toc-text">陈列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B5%E5%88%97%E4%B9%98%E6%B3%95%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">阵列乘法器（了解即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D-2"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93-1"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">整体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%94%B5%E8%B7%AF%E4%B9%98%E6%B3%95%E5%99%A8-sequence-Multiplication-%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A4%A7%E9%A2%98%EF%BC%89"><span class="toc-number">2.4.3.</span> <span class="toc-text">顺序电路乘法器(sequence Multiplication)（注－大题）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93-2"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">整体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-4"><span class="toc-number">2.4.4.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95-Multiplication-of-signed-Numbers-%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">有符号数乘法(Multiplication of signed Numbers)（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Booth%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">Booth算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.5.2.</span> <span class="toc-text">流程表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E7%AE%97%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.5.3.</span> <span class="toc-text">手算表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-5"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">快速乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%95%B0%E4%BD%8D%E5%81%B6%E9%87%8D%E7%BC%96%E7%A0%81-Multiplier-Digit-Even-Weighted-Encoding-%EF%BC%88%E6%B3%A8-%EF%BC%89"><span class="toc-number">2.6.1.</span> <span class="toc-text">乘数位偶重编码(Multiplier Digit Even-Weighted Encoding)（注-）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%92%8C%E9%A1%B9%E7%9A%84%E8%BF%9B%E4%BD%8D%E4%BF%9D%E7%95%99%E5%8A%A0%E6%B3%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">求和项的进位保留加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A83-2%E7%AE%80%E5%8C%96%E5%99%A8%E7%9A%84%E6%B1%82%E5%92%8C%E9%A1%B9%E5%8A%A0%E6%B3%95%E6%A0%91"><span class="toc-number">2.6.3.</span> <span class="toc-text">使用3-2简化器的求和项加法树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A84-2%E7%AE%80%E5%8C%96%E5%99%A8%E7%9A%84%E6%B1%82%E5%92%8C%E9%A1%B9%E5%8A%A0%E6%B3%95%E6%A0%91"><span class="toc-number">2.6.4.</span> <span class="toc-text">使用4-2简化器的求和项加法树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">整数除法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E9%99%A4%E6%B3%95-restoring-division-%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">2.7.1.</span> <span class="toc-text">恢复除法(restoring division)（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%81%A2%E5%A4%8D%E9%99%A4%E6%B3%95-Non-Restoring-%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A4%A7%E9%A2%98%EF%BC%89"><span class="toc-number">2.7.2.</span> <span class="toc-text">不恢复除法(Non-Restoring)（注－大题）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-6"><span class="toc-number">2.7.3.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0-FP-%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A4%A7%E9%A2%98%EF%BC%8C%E5%A1%AB%E7%A9%BA%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">浮点数(FP)及其运算（注－大题，填空）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0-Fixed-point"><span class="toc-number">2.8.1.</span> <span class="toc-text">定点数(Fixed-point)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">2.8.2.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E4%BD%8DS"><span class="toc-number">2.8.3.</span> <span class="toc-text">符号位S</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%99%E6%95%B0E%E2%80%98-exponent"><span class="toc-number">2.8.4.</span> <span class="toc-text">余数E‘(exponent)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E6%95%B0M-mantissa"><span class="toc-number">2.8.5.</span> <span class="toc-text">尾数M(mantissa)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="toc-number">2.8.6.</span> <span class="toc-text">特殊值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="toc-number">2.8.7.</span> <span class="toc-text">加减乘除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E4%BD%8D-guard-bits-%E4%B8%8E%E6%88%AA%E5%8F%96-truncation"><span class="toc-number">2.8.8.</span> <span class="toc-text">保护位(guard bits)与截取(truncation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%96%AD-truncation"><span class="toc-number">2.8.8.1.</span> <span class="toc-text">截断(truncation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%88%8D%E5%85%A5-Von-Neumann-Rounding"><span class="toc-number">2.8.8.2.</span> <span class="toc-text">冯诺依曼舍入(Von Neumann Rounding)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%88%8D%E5%85%A5-Rounding"><span class="toc-number">2.8.8.3.</span> <span class="toc-text">舍入(Rounding)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA-1"><span class="toc-number">2.8.9.</span> <span class="toc-text">溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E4%B8%8A%E6%BA%A2"><span class="toc-number">2.8.9.1.</span> <span class="toc-text">指数上溢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E4%B8%8B%E6%BA%A2"><span class="toc-number">2.8.9.2.</span> <span class="toc-text">指数下溢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">2.8.9.3.</span> <span class="toc-text">尾数溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%95%B0%E4%B8%8B%E6%BA%A2"><span class="toc-number">2.8.9.4.</span> <span class="toc-text">尾数下溢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.8.10.</span> <span class="toc-text">加减操作的实现（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.8.11.</span> <span class="toc-text">定点数和浮点数的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-7"><span class="toc-number">2.8.12.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%B3%A8%E6%84%8F%E5%90%84%E5%85%83%E4%BB%B6%E4%B8%8E%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">存储器系统（注意各元件与方法之间的比较）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84-main-mempry-organization"><span class="toc-number">3.1.1.</span> <span class="toc-text">主存组织架构(main mempry organization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F%EF%BC%88%E6%B3%A8%EF%BC%8D%E9%80%89%E6%8B%A9%E5%8F%AF%E8%83%BD%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">主存访问顺序（注－选择可能）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AD%97%E8%8A%82%E5%88%86%E9%85%8D-Big-endian-Assignment"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">大字节分配(Big-endian Assignment)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%AD%97%E8%8A%82%E5%88%86%E9%85%8D-little-endian-assignment"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">小字节分配(little-endian assignment)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E4%BA%A4%E4%BA%92%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">主存交互（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">读操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">写操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.4.</span> <span class="toc-text">特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%89%B9%E5%BE%81-physical-types"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">物理特征(physical types)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8-capacity"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">存储(capacity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93-transfer"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">传输(transfer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-access-methods"><span class="toc-number">3.1.4.4.</span> <span class="toc-text">访问方式(access methods)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE-sequential-access"><span class="toc-number">3.1.4.4.1.</span> <span class="toc-text">顺序访问(sequential access)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE-random-access"><span class="toc-number">3.1.4.4.2.</span> <span class="toc-text">随机访问(random access)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE-direct-access"><span class="toc-number">3.1.4.4.3.</span> <span class="toc-text">直接访问(direct access)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%95%BF"><span class="toc-number">3.1.5.</span> <span class="toc-text">时长</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%97%B6%E9%95%BF-memory-access-time"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">访问时长(memory access time)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E6%97%B6%E9%95%BF-memory-cycle-time"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">周期时长(memory cycle time)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87-transfer-rate"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">传输速率(transfer rate)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E5%A4%B1-%E4%B8%8D%E6%98%93%E5%A4%B1%EF%BC%88Volatile-Nonvolatile%EF%BC%89"><span class="toc-number">3.1.6.</span> <span class="toc-text">易失&#x2F;不易失（Volatile&#x2F;Nonvolatile）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%93%A6%E5%86%99-%E4%B8%8D%E5%8F%AF%E6%93%A6%E5%86%99%EF%BC%88Erasable-Non-erasable%EF%BC%89"><span class="toc-number">3.1.7.</span> <span class="toc-text">可擦写&#x2F;不可擦写（Erasable&#x2F;Non-erasable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-8"><span class="toc-number">3.1.8.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAM-%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">RAM(半导体随机存储器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SRAM%EF%BC%88%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">SRAM（静态存储器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMOS%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">CMOS的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SRAM%E5%86%85%E9%83%A8%E7%BB%84%E7%BB%87"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">SRAM内部组织</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%8E%92%E5%88%97"><span class="toc-number">3.2.1.5.1.</span> <span class="toc-text">一维排列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB-1"><span class="toc-number">3.2.1.5.1.1.</span> <span class="toc-text">读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99-1"><span class="toc-number">3.2.1.5.1.2.</span> <span class="toc-text">写</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E4%BB%B6"><span class="toc-number">3.2.1.5.2.</span> <span class="toc-text">元件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BA%BF"><span class="toc-number">3.2.1.5.2.1.</span> <span class="toc-text">地址线</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%BA%BF"><span class="toc-number">3.2.1.5.2.2.</span> <span class="toc-text">输入&#x2F;输出线</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#R-W"><span class="toc-number">3.2.1.5.2.3.</span> <span class="toc-text">R&#x2F;W</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CS%EF%BC%88%E5%BC%95%E8%84%9A%EF%BC%89"><span class="toc-number">3.2.1.5.2.4.</span> <span class="toc-text">CS（引脚）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%B0%E7%BA%BF"><span class="toc-number">3.2.1.5.2.5.</span> <span class="toc-text">地线</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%9B%E7%94%B5%E7%BA%BF"><span class="toc-number">3.2.1.5.2.6.</span> <span class="toc-text">供电线</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%8E%92%E5%88%97"><span class="toc-number">3.2.1.5.3.</span> <span class="toc-text">二维排列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SRAM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.1.6.</span> <span class="toc-text">SRAM的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-9"><span class="toc-number">3.2.1.7.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DRAM%EF%BC%88%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">DRAM（动态随机存储器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB-2"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99-2"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8-asynchronous-DRAM"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">异步动态随机存储器(asynchronous DRAM)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%A1%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.2.6.</span> <span class="toc-text">快速页模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88SDRAM%EF%BC%89-synchronous-DRAM"><span class="toc-number">3.2.2.7.</span> <span class="toc-text">同步随机存储器（SDRAM）(synchronous DRAM)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%81%E5%8F%91%E4%BC%A0%E8%BE%93-burst-opration"><span class="toc-number">3.2.2.7.1.</span> <span class="toc-text">突发传输(burst opration)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F-latency"><span class="toc-number">3.2.2.8.</span> <span class="toc-text">延迟(latency)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%AE%BD-bandwidth"><span class="toc-number">3.2.2.9.</span> <span class="toc-text">带宽(bandwidth)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DDR-SDRAM"><span class="toc-number">3.2.2.10.</span> <span class="toc-text">DDR SDRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DRAM%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">3.2.2.11.</span> <span class="toc-text">DRAM的优劣</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-10"><span class="toc-number">3.2.2.12.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A4%A7%E9%A2%98%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">大容量存储器结构（注－大题）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">静态存储器系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E6%89%A9%E5%B1%95%E6%B3%95"><span class="toc-number">3.2.3.1.1.</span> <span class="toc-text">位扩展法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%89%A9%E5%B1%95%E6%B3%95"><span class="toc-number">3.2.3.1.2.</span> <span class="toc-text">字扩展法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95"><span class="toc-number">3.2.3.1.3.</span> <span class="toc-text">字位同时扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%AD%97%E8%8A%82%E4%B8%8E%E6%8C%89%E5%AD%97%E7%BC%96%E5%9D%80"><span class="toc-number">3.2.3.1.4.</span> <span class="toc-text">按字节与按字编址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">动态存储器系统（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SIMM%E5%8D%95%E5%88%97%E7%9B%B4%E6%8F%92%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">3.2.3.2.1.</span> <span class="toc-text">SIMM单列直插存储器模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DIMM%E5%8F%8C%E5%88%97%E7%9B%B4%E6%8F%92%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">3.2.3.2.2.</span> <span class="toc-text">DIMM双列直插存储器模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">存储控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%BC%80%E9%94%80-refresh-overhead"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">刷新开销(refresh overhead)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-11"><span class="toc-number">3.2.4.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">只读存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="toc-number">3.3.1.</span> <span class="toc-text">内存层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROM%EF%BC%88%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">ROM（只读存储器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PROM%EF%BC%88%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">PROM（可编程只读存储器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EPROM%EF%BC%88%E5%8F%AF%E6%93%A6%E9%99%A4%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">3.3.4.</span> <span class="toc-text">EPROM（可擦除可编程只读存储器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EEPROM%EF%BC%88%E7%94%B5%E5%8F%AF%E6%93%A6%E9%99%A4%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">3.3.5.</span> <span class="toc-text">EEPROM（电可擦除可编程只读存储器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AA%E5%AD%98"><span class="toc-number">3.3.6.</span> <span class="toc-text">闪存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AA%E5%AD%98%E5%8D%A1"><span class="toc-number">3.3.6.1.</span> <span class="toc-text">闪存卡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AA%E5%AD%98%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-number">3.3.6.2.</span> <span class="toc-text">闪存驱动器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE%EF%BC%88DMA%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">直接存储访问（DMA）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-Memory-Hierarchy-%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">存储器层次结构(Memory Hierarchy)（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer%EF%BC%88%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">buffer（缓冲区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-12"><span class="toc-number">3.5.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98-cache-%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A4%A7%E9%A2%98%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">高速缓存(cache)（注－大题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7-locality-of-refence"><span class="toc-number">3.6.1.</span> <span class="toc-text">局部性(locality of refence)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">时间局部性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">空间局部性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84-mapping"><span class="toc-number">3.6.2.</span> <span class="toc-text">映射(mapping)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84-direct-mapping"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">直接映射(direct mapping)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7"><span class="toc-number">3.6.2.1.1.</span> <span class="toc-text">评价</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-Associative-Mapping"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">相联映射(Associative Mapping)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.7.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%84%E5%88%A4"><span class="toc-number">3.7.0.0.1.</span> <span class="toc-text">评判</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-set-associative-mapping"><span class="toc-number">3.7.0.1.</span> <span class="toc-text">组相联映射(set associative mapping)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7-1"><span class="toc-number">3.7.0.1.1.</span> <span class="toc-text">评价</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%97%B6-out-data-%E6%95%B0%E6%8D%AE"><span class="toc-number">3.7.0.2.</span> <span class="toc-text">过时(out data)数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.7.0.2.1.</span> <span class="toc-text">高速缓存一致性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-replacement-algorithm"><span class="toc-number">3.7.1.</span> <span class="toc-text">替换算法(replacement algorithm)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU%EF%BC%88%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%EF%BC%89"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">LRU（最近最少）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO"><span class="toc-number">3.7.1.2.</span> <span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA"><span class="toc-number">3.7.1.3.</span> <span class="toc-text">随机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E6%B3%A8%EF%BC%89%E4%BE%8B%E5%AD%90"><span class="toc-number">3.7.1.4.</span> <span class="toc-text">（注）例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="toc-number">3.7.1.4.1.</span> <span class="toc-text">直接映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">3.7.1.4.2.</span> <span class="toc-text">相联映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">3.7.1.4.3.</span> <span class="toc-text">组相联映射</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-13"><span class="toc-number">3.7.1.5.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD-Hit"><span class="toc-number">3.7.2.</span> <span class="toc-text">高速缓存命中(Hit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%88%96%E5%86%99%E5%91%BD%E4%B8%AD%EF%BC%88read-or-write-hit%EF%BC%89"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">读或写命中（read or write hit）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C-1"><span class="toc-number">3.7.2.1.1.</span> <span class="toc-text">读操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C-1"><span class="toc-number">3.7.2.1.2.</span> <span class="toc-text">写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%99-write-through"><span class="toc-number">3.7.2.1.2.1.</span> <span class="toc-text">直接写(write through)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E5%9B%9E-write-back"><span class="toc-number">3.7.2.1.2.2.</span> <span class="toc-text">写回(write back)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%99%E5%92%8C%E5%86%99%E5%9B%9E%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.7.2.1.3.</span> <span class="toc-text">直接写和写回的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%88%96%E5%86%99%E5%A4%B1%E6%95%88-Miss"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">读或写失效(Miss)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C-2"><span class="toc-number">3.7.2.2.1.</span> <span class="toc-text">读操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C-2"><span class="toc-number">3.7.2.2.2.</span> <span class="toc-text">写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%86%99%E5%88%86%E9%85%8D-No-Write-Allocate"><span class="toc-number">3.7.2.2.2.1.</span> <span class="toc-text">不写分配(No-Write Allocate)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E5%88%86%E9%85%8D-write-Allocate"><span class="toc-number">3.7.2.2.2.2.</span> <span class="toc-text">写分配(write Allocate)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E7%8E%87-hit-rate-%E5%92%8C%E5%A4%B1%E6%95%88%E5%BC%80%E6%95%88-miss-penalty"><span class="toc-number">3.7.3.</span> <span class="toc-text">命中率(hit rate)和失效开效(miss penalty)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">命中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E5%BC%80%E9%94%80"><span class="toc-number">3.7.3.2.</span> <span class="toc-text">失效开销</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">3.7.3.2.1.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.7.3.3.</span> <span class="toc-text">多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7-2"><span class="toc-number">3.7.3.3.1.</span> <span class="toc-text">评价</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%8A%AF%E7%89%87%E4%B8%8A%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">3.7.3.4.</span> <span class="toc-text">处理器芯片上的高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%94%B9%E8%BF%9B%EF%BC%88%E6%B2%A1%E8%AE%B2%EF%BC%89"><span class="toc-number">3.7.3.5.</span> <span class="toc-text">其他改进（没讲）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA-write-buffer"><span class="toc-number">3.7.3.5.1.</span> <span class="toc-text">写缓冲区(write buffer)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%8F%96-prefetch"><span class="toc-number">3.7.3.5.2.</span> <span class="toc-text">预取(prefetch)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E5%AE%9A%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">3.7.3.5.3.</span> <span class="toc-text">无锁定高速缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-14"><span class="toc-number">3.7.4.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">虚拟存储器（注）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%EF%BC%88Overlaying%EF%BC%89"><span class="toc-number">3.8.1.</span> <span class="toc-text">覆盖（Overlaying）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.2.</span> <span class="toc-text">地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E7%9B%91%E8%A7%86%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88TLB%EF%BC%89"><span class="toc-number">3.8.2.1.</span> <span class="toc-text">转换监视缓冲区（TLB）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TLB-Hit-amp-Miss"><span class="toc-number">3.8.2.1.1.</span> <span class="toc-text">TLB Hit&amp;Miss</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E6%95%85%E9%9A%9C%EF%BC%88page-fault%EF%BC%89"><span class="toc-number">3.8.2.2.</span> <span class="toc-text">页故障（page fault）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA%E9%A1%B5"><span class="toc-number">3.8.2.3.</span> <span class="toc-text">弹出页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%A1%B5"><span class="toc-number">3.8.2.4.</span> <span class="toc-text">修改页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">3.8.3.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">3.8.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87-internal-fragnebtation-%EF%BC%88%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="toc-number">3.8.3.2.</span> <span class="toc-text">内部碎片(internal fragnebtation)（缺点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%9A%84%E9%A1%B5%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.8.3.3.</span> <span class="toc-text">大容量的页的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%9A%84%E9%A1%B5%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.8.3.4.</span> <span class="toc-text">大容量的页的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-15"><span class="toc-number">3.8.4.</span> <span class="toc-text">习题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E9%A2%98"><span class="toc-number">3.8.5.</span> <span class="toc-text">做题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.9.</span> <span class="toc-text">辅助存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">3.9.1.</span> <span class="toc-text">磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">曼彻斯特编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%A9%E5%88%87%E6%96%AF%E7%89%B9-winchestaer-%E6%8A%80%E6%9C%AF"><span class="toc-number">3.9.1.2.</span> <span class="toc-text">温切斯特(winchestaer)技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99"><span class="toc-number">3.9.1.3.</span> <span class="toc-text">读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-number">3.9.1.4.</span> <span class="toc-text">访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4"><span class="toc-number">3.9.1.5.</span> <span class="toc-text">时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-16"><span class="toc-number">3.10.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">指令集体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%92%8C%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97"><span class="toc-number">4.1.</span> <span class="toc-text">指令和指令序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E6%A0%87%E8%AE%B0%EF%BC%88RTN%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">寄存器传送标记（RTN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%A6%E5%8F%B7-assembly-language-notation"><span class="toc-number">4.1.2.</span> <span class="toc-text">汇编语言符号(assembly language notation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RISC%E5%92%8CCISC%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">RISC和CISC指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RISC%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">RISC指令集介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.3.1.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.3.1.2.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Load"><span class="toc-number">4.1.3.1.2.1.</span> <span class="toc-text">Load</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Add"><span class="toc-number">4.1.3.1.2.2.</span> <span class="toc-text">Add</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Store"><span class="toc-number">4.1.3.1.2.3.</span> <span class="toc-text">Store</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BA%BF%E6%80%A7%E5%BA%8F%E5%88%97-straight-line-sequence"><span class="toc-number">4.1.3.1.3.</span> <span class="toc-text">指令执行和线性序列(straight line sequence)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB-branching"><span class="toc-number">4.1.3.1.4.</span> <span class="toc-text">转移(branching)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F-instruction-formats-%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">指令格式(instruction formats)（注）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%B4%A0"><span class="toc-number">4.2.1.</span> <span class="toc-text">要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text">指令表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99"><span class="toc-number">4.2.3.</span> <span class="toc-text">指令设计准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%AD%97%E6%AE%B5%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">4.2.4.</span> <span class="toc-text">地址字段格式（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">零地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">一地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">二地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">三地址指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6-instruction-length"><span class="toc-number">4.2.5.</span> <span class="toc-text">指令长度(instruction length)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E9%A2%98-1"><span class="toc-number">4.2.6.</span> <span class="toc-text">做题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4-1"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">三地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4-1"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">二地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.6.3.</span> <span class="toc-text">一地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.6.4.</span> <span class="toc-text">零地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-addressing-modes-%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">寻址方式(addressing modes)（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">寄存器方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">变量与常量寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E6%96%B9%E5%BC%8F-absolute-mode"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">绝对方式(absolute mode)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">4.3.2.1.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">4.3.2.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%96%B9%E5%BC%8F-immediate-mode"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">立即方式(immediate mode)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-1"><span class="toc-number">4.3.2.2.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">4.3.2.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-indirect-mode-%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">4.3.3.</span> <span class="toc-text">间接寻址方式(indirect mode)和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">主存间接寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">4.3.3.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-number">4.3.3.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-register-indirect-mode"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">寄存器间接寻址(register indirect mode)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-number">4.3.3.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-multilevel-indirect-addressing-%EF%BC%9A"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">多级间接寻址(multilevel indirect addressing)：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-indexed-mode-%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">4.3.4.</span> <span class="toc-text">变址寻址方式(indexed mode)和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%B8%B8%E9%87%8F%E7%BB%99%E5%87%BA"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">偏移量作为常量给出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">偏移量存储在变址寄存器中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">变址寻址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-base-index"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">基址寻址方式(base index)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88base-register%EF%BC%89"><span class="toc-number">4.3.4.4.1.</span> <span class="toc-text">基址寄存器（base register）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80"><span class="toc-number">4.3.4.4.2.</span> <span class="toc-text">基址变址</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88-stacks"><span class="toc-number">4.4.</span> <span class="toc-text">堆栈(stacks)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%A0%86%E6%A0%88"><span class="toc-number">4.4.1.</span> <span class="toc-text">处理器堆栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%EF%BC%88Subroutines%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">子程序（Subroutines）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E6%B3%95%EF%BC%88subroutine-linkage%EF%BC%89"><span class="toc-number">4.5.1.</span> <span class="toc-text">子程序链接法（subroutine linkage）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Call"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">Call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Return"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">Return</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CISC%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">4.6.</span> <span class="toc-text">CISC指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Move%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.1.</span> <span class="toc-text">Move指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.2.</span> <span class="toc-text">其他寻址模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%87%8F%E5%92%8C%E8%87%AA%E5%8A%A8%E5%87%8F%E9%87%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">自动增量和自动减量方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%87%8F-autoincrement"><span class="toc-number">4.6.2.1.1.</span> <span class="toc-text">自动增量(autoincrement)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%87%8F%E9%87%8F-autodecrement"><span class="toc-number">4.6.2.1.2.</span> <span class="toc-text">自动减量(autodecrement)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E6%96%B9%E5%BC%8F-relative-mode"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">相对方式(relative mode)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81-condition-codes"><span class="toc-number">4.6.3.</span> <span class="toc-text">条件码(condition codes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-17"><span class="toc-number">4.6.4.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RISC%E4%B8%8ECISC%E5%AF%B9%E6%AF%94%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">RISC与CISC对比（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RISC"><span class="toc-number">4.7.1.</span> <span class="toc-text">RISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CISC"><span class="toc-number">4.7.2.</span> <span class="toc-text">CISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-18"><span class="toc-number">4.7.3.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E9%83%A8%E4%BB%B6-basic-processing-unit"><span class="toc-number">5.</span> <span class="toc-text">基本处理部件(basic processing unit)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">一些基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.1.1.</span> <span class="toc-text">一般步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%8A%A8%E4%BD%9C"><span class="toc-number">5.1.2.</span> <span class="toc-text">一般动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%A1%AC%E4%BB%B6-data-processing"><span class="toc-number">5.1.3.</span> <span class="toc-text">数据处理硬件(data processing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%98%B6%E6%AE%B5"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">大阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E9%98%B6%E6%AE%B5"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">小阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">5.2.</span> <span class="toc-text">指令的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Load-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">Load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">Add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Store-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80"><span class="toc-number">5.2.4.</span> <span class="toc-text">统一</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%84%E4%BB%B6-hardware-components"><span class="toc-number">5.3.</span> <span class="toc-text">硬件组件(hardware components)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6-register-file"><span class="toc-number">5.3.1.</span> <span class="toc-text">寄存器文件(register file)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6-2-port-register-file"><span class="toc-number">5.3.1.1.1.</span> <span class="toc-text">双端口寄存器文件(2-port register file)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%9E%E7%8E%B0-two-single-ported-memeory-blocks"><span class="toc-number">5.3.1.1.2.</span> <span class="toc-text">双存储器实现(two single-ported memeory blocks)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ALU"><span class="toc-number">5.3.2.</span> <span class="toc-text">ALU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF-datapath"><span class="toc-number">5.3.3.</span> <span class="toc-text">数据通路(datapath)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">5.3.4.</span> <span class="toc-text">指令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Load-2"><span class="toc-number">5.3.4.0.1.</span> <span class="toc-text">Load</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Add-2"><span class="toc-number">5.3.4.0.2.</span> <span class="toc-text">Add</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Store-2"><span class="toc-number">5.3.4.0.3.</span> <span class="toc-text">Store</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AF%BB%E5%8F%96"><span class="toc-number">5.3.5.</span> <span class="toc-text">指令读取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PC%E8%87%AA%E5%A2%9E"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">PC自增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IR%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">IR存储指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A4%A7%E9%A2%98%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">指令的读取和执行操作（注－大题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-3"><span class="toc-number">5.4.1.</span> <span class="toc-text">Add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load-amp-Store-%E6%B3%A8%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AD%A5%E8%BF%98%E5%BA%94%E5%8A%A0%E4%B8%8A%E7%AD%89%E5%BE%85MFC"><span class="toc-number">5.4.2.</span> <span class="toc-text">Load&amp;Store(注：第一步还应加上等待MFC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-number">5.4.3.</span> <span class="toc-text">无条件分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-number">5.4.4.</span> <span class="toc-text">条件分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Call%EF%BC%88%E6%B3%A8%E6%84%8F%EF%BC%89"><span class="toc-number">5.4.5.</span> <span class="toc-text">Call（注意）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%99%E6%97%B6%E9%97%B4-wait-for-memory"><span class="toc-number">5.4.6.</span> <span class="toc-text">等候时间(wait for memory)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7-control-signals"><span class="toc-number">5.5.</span> <span class="toc-text">控制信号(control signals)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">5.5.1.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6-Hardwried-control-%EF%BC%88%E4%B8%8D%E8%80%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">硬件控制(Hardwried control)（不考表达式）（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.6.1.</span> <span class="toc-text">数据通路控制信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%BB%B6%E8%BF%9F%E5%A4%84%E7%90%86"><span class="toc-number">5.6.2.</span> <span class="toc-text">存储器延迟处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CICS%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">CICS风格的处理器（了解，待补充）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6-microprogramming-%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">微程序控制(microprogramming)（注）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BE%AE%E6%8C%87%E4%BB%A4-long-microinstruction"><span class="toc-number">5.8.1.</span> <span class="toc-text">长微指令(long microinstruction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%BE%AE%E6%8C%87%E4%BB%A4-Grouping-microinstruction"><span class="toc-number">5.8.2.</span> <span class="toc-text">分组微指令(Grouping microinstruction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">5.8.3.</span> <span class="toc-text">优缺点分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E9%80%9F%E5%BA%A6%E5%BF%AB"><span class="toc-number">5.9.</span> <span class="toc-text">1. 操作速度快</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-19"><span class="toc-number">5.9.1.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF-pipelining"><span class="toc-number">6.</span> <span class="toc-text">流水线(pipelining)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">流水线结构（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-20"><span class="toc-number">6.2.1.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%97%AE%E9%A2%98-pipeline-issues"><span class="toc-number">6.3.</span> <span class="toc-text">流水线问题(pipeline issues)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7-data-dependency-%EF%BC%88%E6%B3%A8%EF%BC%8D%E5%A4%A7%E9%A2%98%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">数据依赖性(data dependency)（注－大题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E8%BD%AC%E5%8F%91-operand-forwanding-%EF%BC%88%E6%B3%A8%EF%BC%89"><span class="toc-number">6.4.1.</span> <span class="toc-text">操作数转发(operand forwanding)（注）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-number">6.4.2.</span> <span class="toc-text">用软件处理数据依赖性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%BB%B6%E8%BF%9F%EF%BC%88%E6%B3%A8%EF%BC%8D%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">存储器延迟（注－）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">6.5.1.</span> <span class="toc-text">软件处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%80%A7%E5%86%B2%E7%AA%81%EF%BC%88%E8%B5%84%E6%BA%90%E5%86%B2%E7%AA%81%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">结构性冲突（资源冲突）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%BB%B6%E8%BF%9F"><span class="toc-number">6.7.</span> <span class="toc-text">转移延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E5%BB%B6%E8%BF%9F"><span class="toc-number">6.7.1.</span> <span class="toc-text">无条件延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-number">6.7.2.</span> <span class="toc-text">条件转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%BB%B6%E8%BF%9F%E6%A7%BD-branch-delay-slot"><span class="toc-number">6.7.3.</span> <span class="toc-text">转移延迟槽(branch delay slot)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-21"><span class="toc-number">6.8.</span> <span class="toc-text">习题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E6%AD%A4%E7%AB%A0%E5%89%A9%E4%BD%99%E5%86%85%E5%AE%B9%E4%B8%8D%E8%80%83"><span class="toc-number">6.9.</span> <span class="toc-text">注：此章剩余内容不考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-Basic-input-output"><span class="toc-number">7.</span> <span class="toc-text">基本输入输出(Basic input&#x2F;output)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-access-IO%E8%AE%BE%E5%A4%87"><span class="toc-number">7.1.</span> <span class="toc-text">访问(access)IO设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8-memory-%E6%98%A0%E5%B0%84I-O"><span class="toc-number">7.1.1.</span> <span class="toc-text">存储器(memory)映射I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7-3"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">评价</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-number">7.1.1.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-number">7.1.1.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8FI-O-separated-IO"><span class="toc-number">7.1.2.</span> <span class="toc-text">分离式I&#x2F;O(separated IO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3-IO-device-interface"><span class="toc-number">7.1.3.</span> <span class="toc-text">I&#x2F;O设备接口(IO device interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-22"><span class="toc-number">7.1.4.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6I-O-program-controlled-IO"><span class="toc-number">7.2.</span> <span class="toc-text">程序控制I&#x2F;O(program-controlled IO)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AARISC%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">一个RISC的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AACISC%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">一个CISC的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD-interrupt-%EF%BC%88%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E7%9A%84I-O%E6%88%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E7%9A%84IO%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">中断(interrupt)（硬件控制的I&#x2F;O或中断控制的IO）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">中断和子程序调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">保存类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%85%81%E8%AE%B8%E4%B8%8E%E7%A6%81%E6%AD%A2-enable-and-disabling-interrupts"><span class="toc-number">7.3.2.</span> <span class="toc-text">中断的允许与禁止(enable and disabling interrupts)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%AE%BE%E5%A4%87"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">单设备</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-23"><span class="toc-number">7.3.2.1.1.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%AE%BE%E5%A4%87-multiple"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">多设备(multiple)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E7%BA%BF-Multiple-Interrupt-request-Lines"><span class="toc-number">7.3.2.2.1.</span> <span class="toc-text">多中断请求线(Multiple Interrupt-request Lines)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2-polling"><span class="toc-number">7.3.2.2.2.</span> <span class="toc-text">轮询(polling)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD-vector-interrupt"><span class="toc-number">7.3.2.2.3.</span> <span class="toc-text">向量中断(vector interrupt)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97-interrupt-nesting"><span class="toc-number">7.3.2.2.4.</span> <span class="toc-text">中断嵌套(interrupt nesting)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E4%B8%AD%E6%96%AD-simultanenous-interrupt"><span class="toc-number">7.3.2.2.5.</span> <span class="toc-text">同时中断(simultanenous interrupt)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BD%AE%E8%AF%A2-software-poll"><span class="toc-number">7.3.2.2.5.1.</span> <span class="toc-text">软件轮询(software poll)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%BD%AE%E8%AF%A2-Daisy-chain%E8%8F%8A%E8%8A%B1%E9%93%BE-herdware-poll"><span class="toc-number">7.3.2.2.5.2.</span> <span class="toc-text">硬件轮询(Daisy chain菊花链&#x2F;herdware poll)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%84-priority-group"><span class="toc-number">7.3.2.2.5.3.</span> <span class="toc-text">优先级组(priority group)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-24"><span class="toc-number">7.3.2.2.6.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA"><span class="toc-number">7.4.</span> <span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DMAC"><span class="toc-number">7.4.1.</span> <span class="toc-text">DMAC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.2.</span> <span class="toc-text">传输模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">7.4.3.</span> <span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BF%EF%BC%8C%E5%88%86%E7%A6%BB%E5%BC%8FDMAC-Single-bus-Detached-DMA-Controlle"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">单总线，分离式DMAC( Single-bus, Detached DMA Controlle)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BF%EF%BC%8C%E9%9B%86%E6%88%90%E5%BC%8FDMAC-Single-bus-Integrated-DMA-Controller"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">单总线，集成式DMAC(Single-bus, Integrated DMA Controller)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8BIO%E6%80%BB%E7%BA%BF-Separate-I-O-bus"><span class="toc-number">7.4.3.3.</span> <span class="toc-text">独立IO总线(Separate I&#x2F;O bus)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-25"><span class="toc-number">7.4.4.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By surtr lafael</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Ding Zhen and his animal friends are watching you</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/sakura.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>